var exports = {
}, _dewExec = false;
function dew() {
    if (_dewExec) return exports;
    _dewExec = true;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
        if (val === null || val === undefined) {
            throw new TypeError('Object.assign cannot be called with null or undefined');
        }
        return Object(val);
    }
    function shouldUseNative() {
        try {
            if (!Object.assign) {
                return false;
            }
            var test1 = new String('abc');
            test1[5] = 'de';
            if (Object.getOwnPropertyNames(test1)[0] === '5') {
                return false;
            }
            var test2 = {
            };
            for(var i = 0; i < 10; i++){
                test2['_' + String.fromCharCode(i)] = i;
            }
            var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
                return test2[n];
            });
            if (order2.join('') !== '0123456789') {
                return false;
            }
            var test3 = {
            };
            'abcdefghijklmnopqrst'.split('').forEach(function(letter) {
                test3[letter] = letter;
            });
            if (Object.keys(Object.assign({
            }, test3)).join('') !== 'abcdefghijklmnopqrst') {
                return false;
            }
            return true;
        } catch (err) {
            return false;
        }
    }
    exports = shouldUseNative() ? Object.assign : function(target, source) {
        var from;
        var to = toObject(target);
        var symbols;
        for(var s = 1; s < arguments.length; s++){
            from = Object(arguments[s]);
            for(var key in from){
                if (hasOwnProperty.call(from, key)) {
                    to[key] = from[key];
                }
            }
            if (getOwnPropertySymbols) {
                symbols = getOwnPropertySymbols(from);
                for(var i = 0; i < symbols.length; i++){
                    if (propIsEnumerable.call(from, symbols[i])) {
                        to[symbols[i]] = from[symbols[i]];
                    }
                }
            }
        }
        return to;
    };
    return exports;
}
var exports1 = {
}, _dewExec1 = false;
function dew1() {
    if (_dewExec1) return exports1;
    _dewExec1 = true;
    {
        (function() {
            'use strict';
            var _assign = dew();
            var ReactVersion = '17.0.2';
            var REACT_ELEMENT_TYPE = 60103;
            var REACT_PORTAL_TYPE = 60106;
            exports1.Fragment = 60107;
            exports1.StrictMode = 60108;
            exports1.Profiler = 60114;
            var REACT_PROVIDER_TYPE = 60109;
            var REACT_CONTEXT_TYPE = 60110;
            var REACT_FORWARD_REF_TYPE = 60112;
            exports1.Suspense = 60113;
            var REACT_SUSPENSE_LIST_TYPE = 60120;
            var REACT_MEMO_TYPE = 60115;
            var REACT_LAZY_TYPE = 60116;
            var REACT_BLOCK_TYPE = 60121;
            var REACT_SERVER_BLOCK_TYPE = 60122;
            var REACT_FUNDAMENTAL_TYPE = 60117;
            var REACT_SCOPE_TYPE = 60119;
            var REACT_OPAQUE_ID_TYPE = 60128;
            var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
            var REACT_OFFSCREEN_TYPE = 60130;
            var REACT_LEGACY_HIDDEN_TYPE = 60131;
            if (typeof Symbol === 'function' && Symbol.for) {
                var symbolFor = Symbol.for;
                REACT_ELEMENT_TYPE = symbolFor('react.element');
                REACT_PORTAL_TYPE = symbolFor('react.portal');
                exports1.Fragment = symbolFor('react.fragment');
                exports1.StrictMode = symbolFor('react.strict_mode');
                exports1.Profiler = symbolFor('react.profiler');
                REACT_PROVIDER_TYPE = symbolFor('react.provider');
                REACT_CONTEXT_TYPE = symbolFor('react.context');
                REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
                exports1.Suspense = symbolFor('react.suspense');
                REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
                REACT_MEMO_TYPE = symbolFor('react.memo');
                REACT_LAZY_TYPE = symbolFor('react.lazy');
                REACT_BLOCK_TYPE = symbolFor('react.block');
                REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
                REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
                REACT_SCOPE_TYPE = symbolFor('react.scope');
                REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
                REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
                REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
                REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
            }
            var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
            var FAUX_ITERATOR_SYMBOL = '@@iterator';
            function getIteratorFn(maybeIterable) {
                if (maybeIterable === null || typeof maybeIterable !== 'object') {
                    return null;
                }
                var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
                if (typeof maybeIterator === 'function') {
                    return maybeIterator;
                }
                return null;
            }
            var ReactCurrentDispatcher = {
                current: null
            };
            var ReactCurrentBatchConfig = {
                transition: 0
            };
            var ReactCurrentOwner = {
                current: null
            };
            var ReactDebugCurrentFrame = {
            };
            var currentExtraStackFrame = null;
            function setExtraStackFrame(stack) {
                {
                    currentExtraStackFrame = stack;
                }
            }
            {
                ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
                    {
                        currentExtraStackFrame = stack;
                    }
                };
                ReactDebugCurrentFrame.getCurrentStack = null;
                ReactDebugCurrentFrame.getStackAddendum = function() {
                    var stack = '';
                    if (currentExtraStackFrame) {
                        stack += currentExtraStackFrame;
                    }
                    var impl = ReactDebugCurrentFrame.getCurrentStack;
                    if (impl) {
                        stack += impl() || '';
                    }
                    return stack;
                };
            }
            var IsSomeRendererActing = {
                current: false
            };
            var ReactSharedInternals = {
                ReactCurrentDispatcher: ReactCurrentDispatcher,
                ReactCurrentBatchConfig: ReactCurrentBatchConfig,
                ReactCurrentOwner: ReactCurrentOwner,
                IsSomeRendererActing: IsSomeRendererActing,
                assign: _assign
            };
            {
                ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
            }
            function warn(format) {
                {
                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                        args[_key - 1] = arguments[_key];
                    }
                    printWarning('warn', format, args);
                }
            }
            function error(format) {
                {
                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                        args[_key2 - 1] = arguments[_key2];
                    }
                    printWarning('error', format, args);
                }
            }
            function printWarning(level, format, args) {
                {
                    var ReactDebugCurrentFrame1 = ReactSharedInternals.ReactDebugCurrentFrame;
                    var stack = ReactDebugCurrentFrame1.getStackAddendum();
                    if (stack !== '') {
                        format += '%s';
                        args = args.concat([
                            stack
                        ]);
                    }
                    var argsWithFormat = args.map(function(item) {
                        return '' + item;
                    });
                    argsWithFormat.unshift('Warning: ' + format);
                    Function.prototype.apply.call(console[level], console, argsWithFormat);
                }
            }
            var didWarnStateUpdateForUnmountedComponent = {
            };
            function warnNoop(publicInstance, callerName) {
                {
                    var _constructor = publicInstance.constructor;
                    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
                    var warningKey = componentName + "." + callerName;
                    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
                        return;
                    }
                    error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);
                    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
                }
            }
            var ReactNoopUpdateQueue = {
                isMounted: function(publicInstance) {
                    return false;
                },
                enqueueForceUpdate: function(publicInstance, callback, callerName) {
                    warnNoop(publicInstance, 'forceUpdate');
                },
                enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
                    warnNoop(publicInstance, 'replaceState');
                },
                enqueueSetState: function(publicInstance, partialState, callback, callerName) {
                    warnNoop(publicInstance, 'setState');
                }
            };
            var emptyObject = {
            };
            {
                Object.freeze(emptyObject);
            }
            function Component(props, context, updater) {
                this.props = props;
                this.context = context;
                this.refs = emptyObject;
                this.updater = updater || ReactNoopUpdateQueue;
            }
            Component.prototype.isReactComponent = {
            };
            Component.prototype.setState = function(partialState, callback) {
                if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {
                    {
                        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
                    }
                }
                this.updater.enqueueSetState(this, partialState, callback, 'setState');
            };
            Component.prototype.forceUpdate = function(callback) {
                this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
            };
            {
                var deprecatedAPIs = {
                    isMounted: [
                        'isMounted',
                        'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'
                    ],
                    replaceState: [
                        'replaceState',
                        'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'
                    ]
                };
                var defineDeprecationWarning = function(methodName, info) {
                    Object.defineProperty(Component.prototype, methodName, {
                        get: function() {
                            warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
                            return undefined;
                        }
                    });
                };
                for(var fnName in deprecatedAPIs){
                    if (deprecatedAPIs.hasOwnProperty(fnName)) {
                        defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
                    }
                }
            }
            function ComponentDummy() {
            }
            ComponentDummy.prototype = Component.prototype;
            function PureComponent(props, context, updater) {
                this.props = props;
                this.context = context;
                this.refs = emptyObject;
                this.updater = updater || ReactNoopUpdateQueue;
            }
            var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
            pureComponentPrototype.constructor = PureComponent;
            _assign(pureComponentPrototype, Component.prototype);
            pureComponentPrototype.isPureReactComponent = true;
            function createRef() {
                var refObject = {
                    current: null
                };
                {
                    Object.seal(refObject);
                }
                return refObject;
            }
            function getWrappedName(outerType, innerType, wrapperName) {
                var functionName = innerType.displayName || innerType.name || '';
                return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
            }
            function getContextName(type) {
                return type.displayName || 'Context';
            }
            function getComponentName(type) {
                if (type == null) {
                    return null;
                }
                {
                    if (typeof type.tag === 'number') {
                        error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
                    }
                }
                if (typeof type === 'function') {
                    return type.displayName || type.name || null;
                }
                if (typeof type === 'string') {
                    return type;
                }
                switch(type){
                    case exports1.Fragment:
                        return 'Fragment';
                    case REACT_PORTAL_TYPE:
                        return 'Portal';
                    case exports1.Profiler:
                        return 'Profiler';
                    case exports1.StrictMode:
                        return 'StrictMode';
                    case exports1.Suspense:
                        return 'Suspense';
                    case REACT_SUSPENSE_LIST_TYPE:
                        return 'SuspenseList';
                }
                if (typeof type === 'object') {
                    switch(type.$$typeof){
                        case REACT_CONTEXT_TYPE:
                            var context = type;
                            return getContextName(context) + '.Consumer';
                        case REACT_PROVIDER_TYPE:
                            var provider = type;
                            return getContextName(provider._context) + '.Provider';
                        case REACT_FORWARD_REF_TYPE:
                            return getWrappedName(type, type.render, 'ForwardRef');
                        case REACT_MEMO_TYPE:
                            return getComponentName(type.type);
                        case REACT_BLOCK_TYPE:
                            return getComponentName(type._render);
                        case REACT_LAZY_TYPE:
                            {
                                var lazyComponent = type;
                                var payload = lazyComponent._payload;
                                var init = lazyComponent._init;
                                try {
                                    return getComponentName(init(payload));
                                } catch (x) {
                                    return null;
                                }
                            }
                    }
                }
                return null;
            }
            var hasOwnProperty = Object.prototype.hasOwnProperty;
            var RESERVED_PROPS = {
                key: true,
                ref: true,
                __self: true,
                __source: true
            };
            var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
            {
                didWarnAboutStringRefs = {
                };
            }
            function hasValidRef(config) {
                {
                    if (hasOwnProperty.call(config, 'ref')) {
                        var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
                        if (getter && getter.isReactWarning) {
                            return false;
                        }
                    }
                }
                return config.ref !== undefined;
            }
            function hasValidKey(config) {
                {
                    if (hasOwnProperty.call(config, 'key')) {
                        var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
                        if (getter && getter.isReactWarning) {
                            return false;
                        }
                    }
                }
                return config.key !== undefined;
            }
            function defineKeyPropWarningGetter(props, displayName) {
                var warnAboutAccessingKey = function() {
                    {
                        if (!specialPropKeyWarningShown) {
                            specialPropKeyWarningShown = true;
                            error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
                        }
                    }
                };
                warnAboutAccessingKey.isReactWarning = true;
                Object.defineProperty(props, 'key', {
                    get: warnAboutAccessingKey,
                    configurable: true
                });
            }
            function defineRefPropWarningGetter(props, displayName) {
                var warnAboutAccessingRef = function() {
                    {
                        if (!specialPropRefWarningShown) {
                            specialPropRefWarningShown = true;
                            error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
                        }
                    }
                };
                warnAboutAccessingRef.isReactWarning = true;
                Object.defineProperty(props, 'ref', {
                    get: warnAboutAccessingRef,
                    configurable: true
                });
            }
            function warnIfStringRefCannotBeAutoConverted(config) {
                {
                    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
                        var componentName = getComponentName(ReactCurrentOwner.current.type);
                        if (!didWarnAboutStringRefs[componentName]) {
                            error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
                            didWarnAboutStringRefs[componentName] = true;
                        }
                    }
                }
            }
            var ReactElement = function(type, key, ref, self, source, owner, props) {
                var element = {
                    $$typeof: REACT_ELEMENT_TYPE,
                    type: type,
                    key: key,
                    ref: ref,
                    props: props,
                    _owner: owner
                };
                {
                    element._store = {
                    };
                    Object.defineProperty(element._store, 'validated', {
                        configurable: false,
                        enumerable: false,
                        writable: true,
                        value: false
                    });
                    Object.defineProperty(element, '_self', {
                        configurable: false,
                        enumerable: false,
                        writable: false,
                        value: self
                    });
                    Object.defineProperty(element, '_source', {
                        configurable: false,
                        enumerable: false,
                        writable: false,
                        value: source
                    });
                    if (Object.freeze) {
                        Object.freeze(element.props);
                        Object.freeze(element);
                    }
                }
                return element;
            };
            function createElement(type, config, children) {
                var propName;
                var props = {
                };
                var key = null;
                var ref = null;
                var self = null;
                var source = null;
                if (config != null) {
                    if (hasValidRef(config)) {
                        ref = config.ref;
                        {
                            warnIfStringRefCannotBeAutoConverted(config);
                        }
                    }
                    if (hasValidKey(config)) {
                        key = '' + config.key;
                    }
                    self = config.__self === undefined ? null : config.__self;
                    source = config.__source === undefined ? null : config.__source;
                    for(propName in config){
                        if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                            props[propName] = config[propName];
                        }
                    }
                }
                var childrenLength = arguments.length - 2;
                if (childrenLength === 1) {
                    props.children = children;
                } else if (childrenLength > 1) {
                    var childArray = Array(childrenLength);
                    for(var i = 0; i < childrenLength; i++){
                        childArray[i] = arguments[i + 2];
                    }
                    {
                        if (Object.freeze) {
                            Object.freeze(childArray);
                        }
                    }
                    props.children = childArray;
                }
                if (type && type.defaultProps) {
                    var defaultProps = type.defaultProps;
                    for(propName in defaultProps){
                        if (props[propName] === undefined) {
                            props[propName] = defaultProps[propName];
                        }
                    }
                }
                {
                    if (key || ref) {
                        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
                        if (key) {
                            defineKeyPropWarningGetter(props, displayName);
                        }
                        if (ref) {
                            defineRefPropWarningGetter(props, displayName);
                        }
                    }
                }
                return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
            }
            function cloneAndReplaceKey(oldElement, newKey) {
                var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
                return newElement;
            }
            function cloneElement(element, config, children) {
                if (!!(element === null || element === undefined)) {
                    {
                        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
                    }
                }
                var propName;
                var props = _assign({
                }, element.props);
                var key = element.key;
                var ref = element.ref;
                var self = element._self;
                var source = element._source;
                var owner = element._owner;
                if (config != null) {
                    if (hasValidRef(config)) {
                        ref = config.ref;
                        owner = ReactCurrentOwner.current;
                    }
                    if (hasValidKey(config)) {
                        key = '' + config.key;
                    }
                    var defaultProps;
                    if (element.type && element.type.defaultProps) {
                        defaultProps = element.type.defaultProps;
                    }
                    for(propName in config){
                        if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                            if (config[propName] === undefined && defaultProps !== undefined) {
                                props[propName] = defaultProps[propName];
                            } else {
                                props[propName] = config[propName];
                            }
                        }
                    }
                }
                var childrenLength = arguments.length - 2;
                if (childrenLength === 1) {
                    props.children = children;
                } else if (childrenLength > 1) {
                    var childArray = Array(childrenLength);
                    for(var i = 0; i < childrenLength; i++){
                        childArray[i] = arguments[i + 2];
                    }
                    props.children = childArray;
                }
                return ReactElement(element.type, key, ref, self, source, owner, props);
            }
            function isValidElement(object) {
                return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
            }
            var SEPARATOR = '.';
            var SUBSEPARATOR = ':';
            function escape(key) {
                var escapeRegex = /[=:]/g;
                var escaperLookup = {
                    '=': '=0',
                    ':': '=2'
                };
                var escapedString = key.replace(escapeRegex, function(match) {
                    return escaperLookup[match];
                });
                return '$' + escapedString;
            }
            var didWarnAboutMaps = false;
            var userProvidedKeyEscapeRegex = /\/+/g;
            function escapeUserProvidedKey(text) {
                return text.replace(userProvidedKeyEscapeRegex, '$&/');
            }
            function getElementKey(element, index) {
                if (typeof element === 'object' && element !== null && element.key != null) {
                    return escape('' + element.key);
                }
                return index.toString(36);
            }
            function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
                var type = typeof children;
                if (type === 'undefined' || type === 'boolean') {
                    children = null;
                }
                var invokeCallback = false;
                if (children === null) {
                    invokeCallback = true;
                } else {
                    switch(type){
                        case 'string':
                        case 'number':
                            invokeCallback = true;
                            break;
                        case 'object':
                            switch(children.$$typeof){
                                case REACT_ELEMENT_TYPE:
                                case REACT_PORTAL_TYPE:
                                    invokeCallback = true;
                            }
                    }
                }
                if (invokeCallback) {
                    var _child = children;
                    var mappedChild = callback(_child);
                    var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
                    if (Array.isArray(mappedChild)) {
                        var escapedChildKey = '';
                        if (childKey != null) {
                            escapedChildKey = escapeUserProvidedKey(childKey) + '/';
                        }
                        mapIntoArray(mappedChild, array, escapedChildKey, '', function(c) {
                            return c;
                        });
                    } else if (mappedChild != null) {
                        if (isValidElement(mappedChild)) {
                            mappedChild = cloneAndReplaceKey(mappedChild, escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
                        }
                        array.push(mappedChild);
                    }
                    return 1;
                }
                var child;
                var nextName;
                var subtreeCount = 0;
                var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
                if (Array.isArray(children)) {
                    for(var i = 0; i < children.length; i++){
                        child = children[i];
                        nextName = nextNamePrefix + getElementKey(child, i);
                        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
                    }
                } else {
                    var iteratorFn = getIteratorFn(children);
                    if (typeof iteratorFn === 'function') {
                        var iterableChildren = children;
                        {
                            if (iteratorFn === iterableChildren.entries) {
                                if (!didWarnAboutMaps) {
                                    warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
                                }
                                didWarnAboutMaps = true;
                            }
                        }
                        var iterator = iteratorFn.call(iterableChildren);
                        var step;
                        var ii = 0;
                        while(!(step = iterator.next()).done){
                            child = step.value;
                            nextName = nextNamePrefix + getElementKey(child, ii++);
                            subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
                        }
                    } else if (type === 'object') {
                        var childrenString = '' + children;
                        {
                            {
                                throw Error("Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). If you meant to render a collection of children, use an array instead.");
                            }
                        }
                    }
                }
                return subtreeCount;
            }
            function mapChildren(children, func, context) {
                if (children == null) {
                    return children;
                }
                var result = [];
                var count = 0;
                mapIntoArray(children, result, '', '', function(child) {
                    return func.call(context, child, count++);
                });
                return result;
            }
            function countChildren(children) {
                var n = 0;
                mapChildren(children, function() {
                    n++;
                });
                return n;
            }
            function forEachChildren(children, forEachFunc, forEachContext) {
                mapChildren(children, function() {
                    forEachFunc.apply(this, arguments);
                }, forEachContext);
            }
            function toArray(children) {
                return mapChildren(children, function(child) {
                    return child;
                }) || [];
            }
            function onlyChild(children) {
                if (!isValidElement(children)) {
                    {
                        throw Error("React.Children.only expected to receive a single React element child.");
                    }
                }
                return children;
            }
            function createContext(defaultValue, calculateChangedBits) {
                if (calculateChangedBits === undefined) {
                    calculateChangedBits = null;
                } else {
                    {
                        if (calculateChangedBits !== null && typeof calculateChangedBits !== 'function') {
                            error('createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits);
                        }
                    }
                }
                var context = {
                    $$typeof: REACT_CONTEXT_TYPE,
                    _calculateChangedBits: calculateChangedBits,
                    _currentValue: defaultValue,
                    _currentValue2: defaultValue,
                    _threadCount: 0,
                    Provider: null,
                    Consumer: null
                };
                context.Provider = {
                    $$typeof: REACT_PROVIDER_TYPE,
                    _context: context
                };
                var hasWarnedAboutUsingNestedContextConsumers = false;
                var hasWarnedAboutUsingConsumerProvider = false;
                var hasWarnedAboutDisplayNameOnConsumer = false;
                {
                    var Consumer = {
                        $$typeof: REACT_CONTEXT_TYPE,
                        _context: context,
                        _calculateChangedBits: context._calculateChangedBits
                    };
                    Object.defineProperties(Consumer, {
                        Provider: {
                            get: function() {
                                if (!hasWarnedAboutUsingConsumerProvider) {
                                    hasWarnedAboutUsingConsumerProvider = true;
                                    error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
                                }
                                return context.Provider;
                            },
                            set: function(_Provider) {
                                context.Provider = _Provider;
                            }
                        },
                        _currentValue: {
                            get: function() {
                                return context._currentValue;
                            },
                            set: function(_currentValue) {
                                context._currentValue = _currentValue;
                            }
                        },
                        _currentValue2: {
                            get: function() {
                                return context._currentValue2;
                            },
                            set: function(_currentValue2) {
                                context._currentValue2 = _currentValue2;
                            }
                        },
                        _threadCount: {
                            get: function() {
                                return context._threadCount;
                            },
                            set: function(_threadCount) {
                                context._threadCount = _threadCount;
                            }
                        },
                        Consumer: {
                            get: function() {
                                if (!hasWarnedAboutUsingNestedContextConsumers) {
                                    hasWarnedAboutUsingNestedContextConsumers = true;
                                    error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
                                }
                                return context.Consumer;
                            }
                        },
                        displayName: {
                            get: function() {
                                return context.displayName;
                            },
                            set: function(displayName) {
                                if (!hasWarnedAboutDisplayNameOnConsumer) {
                                    warn('Setting `displayName` on Context.Consumer has no effect. ' + "You should set it directly on the context with Context.displayName = '%s'.", displayName);
                                    hasWarnedAboutDisplayNameOnConsumer = true;
                                }
                            }
                        }
                    });
                    context.Consumer = Consumer;
                }
                {
                    context._currentRenderer = null;
                    context._currentRenderer2 = null;
                }
                return context;
            }
            var Uninitialized = -1;
            var Pending = 0;
            var Resolved = 1;
            var Rejected = 2;
            function lazyInitializer(payload) {
                if (payload._status === Uninitialized) {
                    var ctor = payload._result;
                    var thenable = ctor();
                    var pending = payload;
                    pending._status = Pending;
                    pending._result = thenable;
                    thenable.then(function(moduleObject) {
                        if (payload._status === Pending) {
                            var defaultExport = moduleObject.default;
                            {
                                if (defaultExport === undefined) {
                                    error('lazy: Expected the result of a dynamic import() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + 'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
                                }
                            }
                            var resolved = payload;
                            resolved._status = Resolved;
                            resolved._result = defaultExport;
                        }
                    }, function(error1) {
                        if (payload._status === Pending) {
                            var rejected = payload;
                            rejected._status = Rejected;
                            rejected._result = error1;
                        }
                    });
                }
                if (payload._status === Resolved) {
                    return payload._result;
                } else {
                    throw payload._result;
                }
            }
            function lazy(ctor) {
                var payload = {
                    _status: -1,
                    _result: ctor
                };
                var lazyType = {
                    $$typeof: REACT_LAZY_TYPE,
                    _payload: payload,
                    _init: lazyInitializer
                };
                {
                    var defaultProps;
                    var propTypes;
                    Object.defineProperties(lazyType, {
                        defaultProps: {
                            configurable: true,
                            get: function() {
                                return defaultProps;
                            },
                            set: function(newDefaultProps) {
                                error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
                                defaultProps = newDefaultProps;
                                Object.defineProperty(lazyType, 'defaultProps', {
                                    enumerable: true
                                });
                            }
                        },
                        propTypes: {
                            configurable: true,
                            get: function() {
                                return propTypes;
                            },
                            set: function(newPropTypes) {
                                error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
                                propTypes = newPropTypes;
                                Object.defineProperty(lazyType, 'propTypes', {
                                    enumerable: true
                                });
                            }
                        }
                    });
                }
                return lazyType;
            }
            function forwardRef(render) {
                {
                    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
                        error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
                    } else if (typeof render !== 'function') {
                        error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
                    } else {
                        if (render.length !== 0 && render.length !== 2) {
                            error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
                        }
                    }
                    if (render != null) {
                        if (render.defaultProps != null || render.propTypes != null) {
                            error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
                        }
                    }
                }
                var elementType = {
                    $$typeof: REACT_FORWARD_REF_TYPE,
                    render: render
                };
                {
                    var ownName;
                    Object.defineProperty(elementType, 'displayName', {
                        enumerable: false,
                        configurable: true,
                        get: function() {
                            return ownName;
                        },
                        set: function(name) {
                            ownName = name;
                            if (render.displayName == null) {
                                render.displayName = name;
                            }
                        }
                    });
                }
                return elementType;
            }
            var enableScopeAPI = false;
            function isValidElementType(type) {
                if (typeof type === 'string' || typeof type === 'function') {
                    return true;
                }
                if (type === exports1.Fragment || type === exports1.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports1.StrictMode || type === exports1.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
                    return true;
                }
                if (typeof type === 'object' && type !== null) {
                    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
                        return true;
                    }
                }
                return false;
            }
            function memo(type, compare) {
                {
                    if (!isValidElementType(type)) {
                        error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
                    }
                }
                var elementType = {
                    $$typeof: REACT_MEMO_TYPE,
                    type: type,
                    compare: compare === undefined ? null : compare
                };
                {
                    var ownName;
                    Object.defineProperty(elementType, 'displayName', {
                        enumerable: false,
                        configurable: true,
                        get: function() {
                            return ownName;
                        },
                        set: function(name) {
                            ownName = name;
                            if (type.displayName == null) {
                                type.displayName = name;
                            }
                        }
                    });
                }
                return elementType;
            }
            function resolveDispatcher() {
                var dispatcher = ReactCurrentDispatcher.current;
                if (!(dispatcher !== null)) {
                    {
                        throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
                    }
                }
                return dispatcher;
            }
            function useContext(Context, unstable_observedBits) {
                var dispatcher = resolveDispatcher();
                {
                    if (unstable_observedBits !== undefined) {
                        error('useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\n\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://reactjs.org/link/rules-of-hooks' : '');
                    }
                    if (Context._context !== undefined) {
                        var realContext = Context._context;
                        if (realContext.Consumer === Context) {
                            error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
                        } else if (realContext.Provider === Context) {
                            error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
                        }
                    }
                }
                return dispatcher.useContext(Context, unstable_observedBits);
            }
            function useState(initialState) {
                var dispatcher = resolveDispatcher();
                return dispatcher.useState(initialState);
            }
            function useReducer(reducer, initialArg, init) {
                var dispatcher = resolveDispatcher();
                return dispatcher.useReducer(reducer, initialArg, init);
            }
            function useRef(initialValue) {
                var dispatcher = resolveDispatcher();
                return dispatcher.useRef(initialValue);
            }
            function useEffect(create, deps) {
                var dispatcher = resolveDispatcher();
                return dispatcher.useEffect(create, deps);
            }
            function useLayoutEffect(create, deps) {
                var dispatcher = resolveDispatcher();
                return dispatcher.useLayoutEffect(create, deps);
            }
            function useCallback(callback, deps) {
                var dispatcher = resolveDispatcher();
                return dispatcher.useCallback(callback, deps);
            }
            function useMemo(create, deps) {
                var dispatcher = resolveDispatcher();
                return dispatcher.useMemo(create, deps);
            }
            function useImperativeHandle(ref, create, deps) {
                var dispatcher = resolveDispatcher();
                return dispatcher.useImperativeHandle(ref, create, deps);
            }
            function useDebugValue(value, formatterFn) {
                {
                    var dispatcher = resolveDispatcher();
                    return dispatcher.useDebugValue(value, formatterFn);
                }
            }
            var disabledDepth = 0;
            var prevLog;
            var prevInfo;
            var prevWarn;
            var prevError;
            var prevGroup;
            var prevGroupCollapsed;
            var prevGroupEnd;
            function disabledLog() {
            }
            disabledLog.__reactDisabledLog = true;
            function disableLogs() {
                {
                    if (disabledDepth === 0) {
                        prevLog = console.log;
                        prevInfo = console.info;
                        prevWarn = console.warn;
                        prevError = console.error;
                        prevGroup = console.group;
                        prevGroupCollapsed = console.groupCollapsed;
                        prevGroupEnd = console.groupEnd;
                        var props = {
                            configurable: true,
                            enumerable: true,
                            value: disabledLog,
                            writable: true
                        };
                        Object.defineProperties(console, {
                            info: props,
                            log: props,
                            warn: props,
                            error: props,
                            group: props,
                            groupCollapsed: props,
                            groupEnd: props
                        });
                    }
                    disabledDepth++;
                }
            }
            function reenableLogs() {
                {
                    disabledDepth--;
                    if (disabledDepth === 0) {
                        var props = {
                            configurable: true,
                            enumerable: true,
                            writable: true
                        };
                        Object.defineProperties(console, {
                            log: _assign({
                            }, props, {
                                value: prevLog
                            }),
                            info: _assign({
                            }, props, {
                                value: prevInfo
                            }),
                            warn: _assign({
                            }, props, {
                                value: prevWarn
                            }),
                            error: _assign({
                            }, props, {
                                value: prevError
                            }),
                            group: _assign({
                            }, props, {
                                value: prevGroup
                            }),
                            groupCollapsed: _assign({
                            }, props, {
                                value: prevGroupCollapsed
                            }),
                            groupEnd: _assign({
                            }, props, {
                                value: prevGroupEnd
                            })
                        });
                    }
                    if (disabledDepth < 0) {
                        error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
                    }
                }
            }
            var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
            var prefix;
            function describeBuiltInComponentFrame(name, source, ownerFn) {
                {
                    if (prefix === undefined) {
                        try {
                            throw Error();
                        } catch (x) {
                            var match = x.stack.trim().match(/\n( *(at )?)/);
                            prefix = match && match[1] || '';
                        }
                    }
                    return '\n' + prefix + name;
                }
            }
            var reentry = false;
            var componentFrameCache;
            {
                var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
                componentFrameCache = new PossiblyWeakMap();
            }
            function describeNativeComponentFrame(fn, construct) {
                if (!fn || reentry) {
                    return '';
                }
                {
                    var frame = componentFrameCache.get(fn);
                    if (frame !== undefined) {
                        return frame;
                    }
                }
                var control;
                reentry = true;
                var previousPrepareStackTrace = Error.prepareStackTrace;
                Error.prepareStackTrace = undefined;
                var previousDispatcher;
                {
                    previousDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = null;
                    disableLogs();
                }
                try {
                    if (construct) {
                        var Fake = function() {
                            throw Error();
                        };
                        Object.defineProperty(Fake.prototype, 'props', {
                            set: function() {
                                throw Error();
                            }
                        });
                        if (typeof Reflect === 'object' && Reflect.construct) {
                            try {
                                Reflect.construct(Fake, []);
                            } catch (x) {
                                control = x;
                            }
                            Reflect.construct(fn, [], Fake);
                        } else {
                            try {
                                Fake.call();
                            } catch (x) {
                                control = x;
                            }
                            fn.call(Fake.prototype);
                        }
                    } else {
                        try {
                            throw Error();
                        } catch (x) {
                            control = x;
                        }
                        fn();
                    }
                } catch (sample) {
                    if (sample && control && typeof sample.stack === 'string') {
                        var sampleLines = sample.stack.split('\n');
                        var controlLines = control.stack.split('\n');
                        var s = sampleLines.length - 1;
                        var c = controlLines.length - 1;
                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){
                            c--;
                        }
                        for(; s >= 1 && c >= 0; s--, c--){
                            if (sampleLines[s] !== controlLines[c]) {
                                if (s !== 1 || c !== 1) {
                                    do {
                                        s--;
                                        c--;
                                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                                            var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');
                                            {
                                                if (typeof fn === 'function') {
                                                    componentFrameCache.set(fn, _frame);
                                                }
                                            }
                                            return _frame;
                                        }
                                    }while (s >= 1 && c >= 0)
                                }
                                break;
                            }
                        }
                    }
                } finally{
                    reentry = false;
                    {
                        ReactCurrentDispatcher$1.current = previousDispatcher;
                        reenableLogs();
                    }
                    Error.prepareStackTrace = previousPrepareStackTrace;
                }
                var name = fn ? fn.displayName || fn.name : '';
                var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
                {
                    if (typeof fn === 'function') {
                        componentFrameCache.set(fn, syntheticFrame);
                    }
                }
                return syntheticFrame;
            }
            function describeFunctionComponentFrame(fn, source, ownerFn) {
                {
                    return describeNativeComponentFrame(fn, false);
                }
            }
            function shouldConstruct(Component1) {
                var prototype = Component1.prototype;
                return !!(prototype && prototype.isReactComponent);
            }
            function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
                if (type == null) {
                    return '';
                }
                if (typeof type === 'function') {
                    {
                        return describeNativeComponentFrame(type, shouldConstruct(type));
                    }
                }
                if (typeof type === 'string') {
                    return describeBuiltInComponentFrame(type);
                }
                switch(type){
                    case exports1.Suspense:
                        return describeBuiltInComponentFrame('Suspense');
                    case REACT_SUSPENSE_LIST_TYPE:
                        return describeBuiltInComponentFrame('SuspenseList');
                }
                if (typeof type === 'object') {
                    switch(type.$$typeof){
                        case REACT_FORWARD_REF_TYPE:
                            return describeFunctionComponentFrame(type.render);
                        case REACT_MEMO_TYPE:
                            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                        case REACT_BLOCK_TYPE:
                            return describeFunctionComponentFrame(type._render);
                        case REACT_LAZY_TYPE:
                            {
                                var lazyComponent = type;
                                var payload = lazyComponent._payload;
                                var init = lazyComponent._init;
                                try {
                                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                                } catch (x) {
                                }
                            }
                    }
                }
                return '';
            }
            var loggedTypeFailures = {
            };
            var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
            function setCurrentlyValidatingElement(element) {
                {
                    if (element) {
                        var owner = element._owner;
                        var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                        ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
                    } else {
                        ReactDebugCurrentFrame$1.setExtraStackFrame(null);
                    }
                }
            }
            function checkPropTypes(typeSpecs, values, location, componentName, element) {
                {
                    var has = Function.call.bind(Object.prototype.hasOwnProperty);
                    for(var typeSpecName in typeSpecs){
                        if (has(typeSpecs, typeSpecName)) {
                            var error$1 = void 0;
                            try {
                                if (typeof typeSpecs[typeSpecName] !== 'function') {
                                    var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                                    err.name = 'Invariant Violation';
                                    throw err;
                                }
                                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
                            } catch (ex) {
                                error$1 = ex;
                            }
                            if (error$1 && !(error$1 instanceof Error)) {
                                setCurrentlyValidatingElement(element);
                                error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);
                                setCurrentlyValidatingElement(null);
                            }
                            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                                loggedTypeFailures[error$1.message] = true;
                                setCurrentlyValidatingElement(element);
                                error('Failed %s type: %s', location, error$1.message);
                                setCurrentlyValidatingElement(null);
                            }
                        }
                    }
                }
            }
            function setCurrentlyValidatingElement$1(element) {
                {
                    if (element) {
                        var owner = element._owner;
                        var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                        setExtraStackFrame(stack);
                    } else {
                        setExtraStackFrame(null);
                    }
                }
            }
            var propTypesMisspellWarningShown;
            {
                propTypesMisspellWarningShown = false;
            }
            function getDeclarationErrorAddendum() {
                if (ReactCurrentOwner.current) {
                    var name = getComponentName(ReactCurrentOwner.current.type);
                    if (name) {
                        return '\n\nCheck the render method of `' + name + '`.';
                    }
                }
                return '';
            }
            function getSourceInfoErrorAddendum(source) {
                if (source !== undefined) {
                    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
                    var lineNumber = source.lineNumber;
                    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
                }
                return '';
            }
            function getSourceInfoErrorAddendumForProps(elementProps) {
                if (elementProps !== null && elementProps !== undefined) {
                    return getSourceInfoErrorAddendum(elementProps.__source);
                }
                return '';
            }
            var ownerHasKeyUseWarning = {
            };
            function getCurrentComponentErrorInfo(parentType) {
                var info = getDeclarationErrorAddendum();
                if (!info) {
                    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
                    if (parentName) {
                        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
                    }
                }
                return info;
            }
            function validateExplicitKey(element, parentType) {
                if (!element._store || element._store.validated || element.key != null) {
                    return;
                }
                element._store.validated = true;
                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
                    return;
                }
                ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
                var childOwner = '';
                if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
                    childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
                }
                {
                    setCurrentlyValidatingElement$1(element);
                    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
                    setCurrentlyValidatingElement$1(null);
                }
            }
            function validateChildKeys(node, parentType) {
                if (typeof node !== 'object') {
                    return;
                }
                if (Array.isArray(node)) {
                    for(var i = 0; i < node.length; i++){
                        var child = node[i];
                        if (isValidElement(child)) {
                            validateExplicitKey(child, parentType);
                        }
                    }
                } else if (isValidElement(node)) {
                    if (node._store) {
                        node._store.validated = true;
                    }
                } else if (node) {
                    var iteratorFn = getIteratorFn(node);
                    if (typeof iteratorFn === 'function') {
                        if (iteratorFn !== node.entries) {
                            var iterator = iteratorFn.call(node);
                            var step;
                            while(!(step = iterator.next()).done){
                                if (isValidElement(step.value)) {
                                    validateExplicitKey(step.value, parentType);
                                }
                            }
                        }
                    }
                }
            }
            function validatePropTypes(element) {
                {
                    var type = element.type;
                    if (type === null || type === undefined || typeof type === 'string') {
                        return;
                    }
                    var propTypes;
                    if (typeof type === 'function') {
                        propTypes = type.propTypes;
                    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
                        propTypes = type.propTypes;
                    } else {
                        return;
                    }
                    if (propTypes) {
                        var name = getComponentName(type);
                        checkPropTypes(propTypes, element.props, 'prop', name, element);
                    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
                        propTypesMisspellWarningShown = true;
                        var _name = getComponentName(type);
                        error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
                    }
                    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
                        error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
                    }
                }
            }
            function validateFragmentProps(fragment) {
                {
                    var keys = Object.keys(fragment.props);
                    for(var i = 0; i < keys.length; i++){
                        var key = keys[i];
                        if (key !== 'children' && key !== 'key') {
                            setCurrentlyValidatingElement$1(fragment);
                            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);
                            setCurrentlyValidatingElement$1(null);
                            break;
                        }
                    }
                    if (fragment.ref !== null) {
                        setCurrentlyValidatingElement$1(fragment);
                        error('Invalid attribute `ref` supplied to `React.Fragment`.');
                        setCurrentlyValidatingElement$1(null);
                    }
                }
            }
            function createElementWithValidation(type, props, children) {
                var validType = isValidElementType(type);
                if (!validType) {
                    var info = '';
                    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
                        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
                    }
                    var sourceInfo = getSourceInfoErrorAddendumForProps(props);
                    if (sourceInfo) {
                        info += sourceInfo;
                    } else {
                        info += getDeclarationErrorAddendum();
                    }
                    var typeString;
                    if (type === null) {
                        typeString = 'null';
                    } else if (Array.isArray(type)) {
                        typeString = 'array';
                    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
                        typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
                        info = ' Did you accidentally export a JSX literal instead of a component?';
                    } else {
                        typeString = typeof type;
                    }
                    {
                        error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
                    }
                }
                var element = createElement.apply(this, arguments);
                if (element == null) {
                    return element;
                }
                if (validType) {
                    for(var i = 2; i < arguments.length; i++){
                        validateChildKeys(arguments[i], type);
                    }
                }
                if (type === exports1.Fragment) {
                    validateFragmentProps(element);
                } else {
                    validatePropTypes(element);
                }
                return element;
            }
            var didWarnAboutDeprecatedCreateFactory = false;
            function createFactoryWithValidation(type) {
                var validatedFactory = createElementWithValidation.bind(null, type);
                validatedFactory.type = type;
                {
                    if (!didWarnAboutDeprecatedCreateFactory) {
                        didWarnAboutDeprecatedCreateFactory = true;
                        warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
                    }
                    Object.defineProperty(validatedFactory, 'type', {
                        enumerable: false,
                        get: function() {
                            warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
                            Object.defineProperty(this, 'type', {
                                value: type
                            });
                            return type;
                        }
                    });
                }
                return validatedFactory;
            }
            function cloneElementWithValidation(element, props, children) {
                var newElement = cloneElement.apply(this, arguments);
                for(var i = 2; i < arguments.length; i++){
                    validateChildKeys(arguments[i], newElement.type);
                }
                validatePropTypes(newElement);
                return newElement;
            }
            {
                try {
                    var frozenObject = Object.freeze({
                    });
                    new Map([
                        [
                            frozenObject,
                            null
                        ]
                    ]);
                    new Set([
                        frozenObject
                    ]);
                } catch (e) {
                }
            }
            var createElement$1 = createElementWithValidation;
            var cloneElement$1 = cloneElementWithValidation;
            var createFactory = createFactoryWithValidation;
            var Children = {
                map: mapChildren,
                forEach: forEachChildren,
                count: countChildren,
                toArray: toArray,
                only: onlyChild
            };
            exports1.Children = Children;
            exports1.Component = Component;
            exports1.PureComponent = PureComponent;
            exports1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
            exports1.cloneElement = cloneElement$1;
            exports1.createContext = createContext;
            exports1.createElement = createElement$1;
            exports1.createFactory = createFactory;
            exports1.createRef = createRef;
            exports1.forwardRef = forwardRef;
            exports1.isValidElement = isValidElement;
            exports1.lazy = lazy;
            exports1.memo = memo;
            exports1.useCallback = useCallback;
            exports1.useContext = useContext;
            exports1.useDebugValue = useDebugValue;
            exports1.useEffect = useEffect;
            exports1.useImperativeHandle = useImperativeHandle;
            exports1.useLayoutEffect = useLayoutEffect;
            exports1.useMemo = useMemo;
            exports1.useReducer = useReducer;
            exports1.useRef = useRef;
            exports1.useState = useState;
            exports1.version = ReactVersion;
        })();
    }
    return exports1;
}
var exports2 = {
}, _dewExec2 = false;
function dew2() {
    if (_dewExec2) return exports2;
    _dewExec2 = true;
    {
        exports2 = dew1();
    }
    return exports2;
}
const __default = dew2();
var exports3 = {
}, _dewExec3 = false;
function dew3() {
    if (_dewExec3) return exports3;
    _dewExec3 = true;
    {
        (function() {
            'use strict';
            var React = dew2();
            var _assign = dew();
            function formatProdErrorMessage(code) {
                var url = 'https://reactjs.org/docs/error-decoder.html?invariant=' + code;
                for(var i = 1; i < arguments.length; i++){
                    url += '&args[]=' + encodeURIComponent(arguments[i]);
                }
                return "Minified React error #" + code + "; visit " + url + " for the full message or " + 'use the non-minified dev environment for full errors and additional ' + 'helpful warnings.';
            }
            var ReactVersion = '17.0.2';
            var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
            function warn(format) {
                {
                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                        args[_key - 1] = arguments[_key];
                    }
                    printWarning('warn', format, args);
                }
            }
            function error(format) {
                {
                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                        args[_key2 - 1] = arguments[_key2];
                    }
                    printWarning('error', format, args);
                }
            }
            function printWarning(level, format, args) {
                {
                    var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
                    var stack = ReactDebugCurrentFrame2.getStackAddendum();
                    if (stack !== '') {
                        format += '%s';
                        args = args.concat([
                            stack
                        ]);
                    }
                    var argsWithFormat = args.map(function(item) {
                        return '' + item;
                    });
                    argsWithFormat.unshift('Warning: ' + format);
                    Function.prototype.apply.call(console[level], console, argsWithFormat);
                }
            }
            var REACT_ELEMENT_TYPE = 60103;
            var REACT_PORTAL_TYPE = 60106;
            var REACT_FRAGMENT_TYPE = 60107;
            var REACT_STRICT_MODE_TYPE = 60108;
            var REACT_PROFILER_TYPE = 60114;
            var REACT_PROVIDER_TYPE = 60109;
            var REACT_CONTEXT_TYPE = 60110;
            var REACT_FORWARD_REF_TYPE = 60112;
            var REACT_SUSPENSE_TYPE = 60113;
            var REACT_SUSPENSE_LIST_TYPE = 60120;
            var REACT_MEMO_TYPE = 60115;
            var REACT_LAZY_TYPE = 60116;
            var REACT_BLOCK_TYPE = 60121;
            var REACT_SERVER_BLOCK_TYPE = 60122;
            var REACT_FUNDAMENTAL_TYPE = 60117;
            var REACT_SCOPE_TYPE = 60119;
            var REACT_OPAQUE_ID_TYPE = 60128;
            var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
            var REACT_OFFSCREEN_TYPE = 60130;
            var REACT_LEGACY_HIDDEN_TYPE = 60131;
            if (typeof Symbol === 'function' && Symbol.for) {
                var symbolFor = Symbol.for;
                REACT_ELEMENT_TYPE = symbolFor('react.element');
                REACT_PORTAL_TYPE = symbolFor('react.portal');
                REACT_FRAGMENT_TYPE = symbolFor('react.fragment');
                REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
                REACT_PROFILER_TYPE = symbolFor('react.profiler');
                REACT_PROVIDER_TYPE = symbolFor('react.provider');
                REACT_CONTEXT_TYPE = symbolFor('react.context');
                REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
                REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
                REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
                REACT_MEMO_TYPE = symbolFor('react.memo');
                REACT_LAZY_TYPE = symbolFor('react.lazy');
                REACT_BLOCK_TYPE = symbolFor('react.block');
                REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
                REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
                REACT_SCOPE_TYPE = symbolFor('react.scope');
                REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
                REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
                REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
                REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
            }
            function getWrappedName(outerType, innerType, wrapperName) {
                var functionName = innerType.displayName || innerType.name || '';
                return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
            }
            function getContextName(type) {
                return type.displayName || 'Context';
            }
            function getComponentName(type) {
                if (type == null) {
                    return null;
                }
                {
                    if (typeof type.tag === 'number') {
                        error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
                    }
                }
                if (typeof type === 'function') {
                    return type.displayName || type.name || null;
                }
                if (typeof type === 'string') {
                    return type;
                }
                switch(type){
                    case REACT_FRAGMENT_TYPE:
                        return 'Fragment';
                    case REACT_PORTAL_TYPE:
                        return 'Portal';
                    case REACT_PROFILER_TYPE:
                        return 'Profiler';
                    case REACT_STRICT_MODE_TYPE:
                        return 'StrictMode';
                    case REACT_SUSPENSE_TYPE:
                        return 'Suspense';
                    case REACT_SUSPENSE_LIST_TYPE:
                        return 'SuspenseList';
                }
                if (typeof type === 'object') {
                    switch(type.$$typeof){
                        case REACT_CONTEXT_TYPE:
                            var context = type;
                            return getContextName(context) + '.Consumer';
                        case REACT_PROVIDER_TYPE:
                            var provider = type;
                            return getContextName(provider._context) + '.Provider';
                        case REACT_FORWARD_REF_TYPE:
                            return getWrappedName(type, type.render, 'ForwardRef');
                        case REACT_MEMO_TYPE:
                            return getComponentName(type.type);
                        case REACT_BLOCK_TYPE:
                            return getComponentName(type._render);
                        case REACT_LAZY_TYPE:
                            {
                                var lazyComponent = type;
                                var payload = lazyComponent._payload;
                                var init = lazyComponent._init;
                                try {
                                    return getComponentName(init(payload));
                                } catch (x) {
                                    return null;
                                }
                            }
                    }
                }
                return null;
            }
            var enableSuspenseServerRenderer = false;
            var disabledDepth = 0;
            var prevLog;
            var prevInfo;
            var prevWarn;
            var prevError;
            var prevGroup;
            var prevGroupCollapsed;
            var prevGroupEnd;
            function disabledLog() {
            }
            disabledLog.__reactDisabledLog = true;
            function disableLogs() {
                {
                    if (disabledDepth === 0) {
                        prevLog = console.log;
                        prevInfo = console.info;
                        prevWarn = console.warn;
                        prevError = console.error;
                        prevGroup = console.group;
                        prevGroupCollapsed = console.groupCollapsed;
                        prevGroupEnd = console.groupEnd;
                        var props = {
                            configurable: true,
                            enumerable: true,
                            value: disabledLog,
                            writable: true
                        };
                        Object.defineProperties(console, {
                            info: props,
                            log: props,
                            warn: props,
                            error: props,
                            group: props,
                            groupCollapsed: props,
                            groupEnd: props
                        });
                    }
                    disabledDepth++;
                }
            }
            function reenableLogs() {
                {
                    disabledDepth--;
                    if (disabledDepth === 0) {
                        var props = {
                            configurable: true,
                            enumerable: true,
                            writable: true
                        };
                        Object.defineProperties(console, {
                            log: _assign({
                            }, props, {
                                value: prevLog
                            }),
                            info: _assign({
                            }, props, {
                                value: prevInfo
                            }),
                            warn: _assign({
                            }, props, {
                                value: prevWarn
                            }),
                            error: _assign({
                            }, props, {
                                value: prevError
                            }),
                            group: _assign({
                            }, props, {
                                value: prevGroup
                            }),
                            groupCollapsed: _assign({
                            }, props, {
                                value: prevGroupCollapsed
                            }),
                            groupEnd: _assign({
                            }, props, {
                                value: prevGroupEnd
                            })
                        });
                    }
                    if (disabledDepth < 0) {
                        error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
                    }
                }
            }
            var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
            var prefix;
            function describeBuiltInComponentFrame(name, source, ownerFn) {
                {
                    if (prefix === undefined) {
                        try {
                            throw Error();
                        } catch (x) {
                            var match = x.stack.trim().match(/\n( *(at )?)/);
                            prefix = match && match[1] || '';
                        }
                    }
                    return '\n' + prefix + name;
                }
            }
            var reentry = false;
            var componentFrameCache;
            {
                var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
                componentFrameCache = new PossiblyWeakMap();
            }
            function describeNativeComponentFrame(fn, construct) {
                if (!fn || reentry) {
                    return '';
                }
                {
                    var frame = componentFrameCache.get(fn);
                    if (frame !== undefined) {
                        return frame;
                    }
                }
                var control;
                reentry = true;
                var previousPrepareStackTrace = Error.prepareStackTrace;
                Error.prepareStackTrace = undefined;
                var previousDispatcher;
                {
                    previousDispatcher = ReactCurrentDispatcher.current;
                    ReactCurrentDispatcher.current = null;
                    disableLogs();
                }
                try {
                    if (construct) {
                        var Fake = function() {
                            throw Error();
                        };
                        Object.defineProperty(Fake.prototype, 'props', {
                            set: function() {
                                throw Error();
                            }
                        });
                        if (typeof Reflect === 'object' && Reflect.construct) {
                            try {
                                Reflect.construct(Fake, []);
                            } catch (x) {
                                control = x;
                            }
                            Reflect.construct(fn, [], Fake);
                        } else {
                            try {
                                Fake.call();
                            } catch (x) {
                                control = x;
                            }
                            fn.call(Fake.prototype);
                        }
                    } else {
                        try {
                            throw Error();
                        } catch (x) {
                            control = x;
                        }
                        fn();
                    }
                } catch (sample) {
                    if (sample && control && typeof sample.stack === 'string') {
                        var sampleLines = sample.stack.split('\n');
                        var controlLines = control.stack.split('\n');
                        var s = sampleLines.length - 1;
                        var c = controlLines.length - 1;
                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){
                            c--;
                        }
                        for(; s >= 1 && c >= 0; s--, c--){
                            if (sampleLines[s] !== controlLines[c]) {
                                if (s !== 1 || c !== 1) {
                                    do {
                                        s--;
                                        c--;
                                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                                            var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');
                                            {
                                                if (typeof fn === 'function') {
                                                    componentFrameCache.set(fn, _frame);
                                                }
                                            }
                                            return _frame;
                                        }
                                    }while (s >= 1 && c >= 0)
                                }
                                break;
                            }
                        }
                    }
                } finally{
                    reentry = false;
                    {
                        ReactCurrentDispatcher.current = previousDispatcher;
                        reenableLogs();
                    }
                    Error.prepareStackTrace = previousPrepareStackTrace;
                }
                var name = fn ? fn.displayName || fn.name : '';
                var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
                {
                    if (typeof fn === 'function') {
                        componentFrameCache.set(fn, syntheticFrame);
                    }
                }
                return syntheticFrame;
            }
            function describeFunctionComponentFrame(fn, source, ownerFn) {
                {
                    return describeNativeComponentFrame(fn, false);
                }
            }
            function shouldConstruct(Component) {
                var prototype = Component.prototype;
                return !!(prototype && prototype.isReactComponent);
            }
            function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
                if (type == null) {
                    return '';
                }
                if (typeof type === 'function') {
                    {
                        return describeNativeComponentFrame(type, shouldConstruct(type));
                    }
                }
                if (typeof type === 'string') {
                    return describeBuiltInComponentFrame(type);
                }
                switch(type){
                    case REACT_SUSPENSE_TYPE:
                        return describeBuiltInComponentFrame('Suspense');
                    case REACT_SUSPENSE_LIST_TYPE:
                        return describeBuiltInComponentFrame('SuspenseList');
                }
                if (typeof type === 'object') {
                    switch(type.$$typeof){
                        case REACT_FORWARD_REF_TYPE:
                            return describeFunctionComponentFrame(type.render);
                        case REACT_MEMO_TYPE:
                            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                        case REACT_BLOCK_TYPE:
                            return describeFunctionComponentFrame(type._render);
                        case REACT_LAZY_TYPE:
                            {
                                var lazyComponent = type;
                                var payload = lazyComponent._payload;
                                var init = lazyComponent._init;
                                try {
                                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                                } catch (x) {
                                }
                            }
                    }
                }
                return '';
            }
            var loggedTypeFailures = {
            };
            var ReactDebugCurrentFrame3 = ReactSharedInternals.ReactDebugCurrentFrame;
            function setCurrentlyValidatingElement(element) {
                {
                    if (element) {
                        var owner = element._owner;
                        var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                        ReactDebugCurrentFrame3.setExtraStackFrame(stack);
                    } else {
                        ReactDebugCurrentFrame3.setExtraStackFrame(null);
                    }
                }
            }
            function checkPropTypes(typeSpecs, values, location, componentName, element) {
                {
                    var has = Function.call.bind(Object.prototype.hasOwnProperty);
                    for(var typeSpecName in typeSpecs){
                        if (has(typeSpecs, typeSpecName)) {
                            var error$1 = void 0;
                            try {
                                if (typeof typeSpecs[typeSpecName] !== 'function') {
                                    var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                                    err.name = 'Invariant Violation';
                                    throw err;
                                }
                                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
                            } catch (ex) {
                                error$1 = ex;
                            }
                            if (error$1 && !(error$1 instanceof Error)) {
                                setCurrentlyValidatingElement(element);
                                error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);
                                setCurrentlyValidatingElement(null);
                            }
                            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                                loggedTypeFailures[error$1.message] = true;
                                setCurrentlyValidatingElement(element);
                                error('Failed %s type: %s', location, error$1.message);
                                setCurrentlyValidatingElement(null);
                            }
                        }
                    }
                }
            }
            var didWarnAboutInvalidateContextType;
            {
                didWarnAboutInvalidateContextType = new Set();
            }
            var emptyObject = {
            };
            {
                Object.freeze(emptyObject);
            }
            function maskContext(type, context) {
                var contextTypes = type.contextTypes;
                if (!contextTypes) {
                    return emptyObject;
                }
                var maskedContext = {
                };
                for(var contextName in contextTypes){
                    maskedContext[contextName] = context[contextName];
                }
                return maskedContext;
            }
            function checkContextTypes(typeSpecs, values, location) {
                {
                    checkPropTypes(typeSpecs, values, location, 'Component');
                }
            }
            function validateContextBounds(context, threadID) {
                for(var i = context._threadCount | 0; i <= threadID; i++){
                    context[i] = context._currentValue2;
                    context._threadCount = i + 1;
                }
            }
            function processContext(type, context, threadID, isClass) {
                if (isClass) {
                    var contextType = type.contextType;
                    {
                        if ('contextType' in type) {
                            var isValid = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined;
                            if (!isValid && !didWarnAboutInvalidateContextType.has(type)) {
                                didWarnAboutInvalidateContextType.add(type);
                                var addendum = '';
                                if (contextType === undefined) {
                                    addendum = ' However, it is set to undefined. ' + 'This can be caused by a typo or by mixing up named and default imports. ' + 'This can also happen due to a circular dependency, so ' + 'try moving the createContext() call to a separate file.';
                                } else if (typeof contextType !== 'object') {
                                    addendum = ' However, it is set to a ' + typeof contextType + '.';
                                } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                                    addendum = ' Did you accidentally pass the Context.Provider instead?';
                                } else if (contextType._context !== undefined) {
                                    addendum = ' Did you accidentally pass the Context.Consumer instead?';
                                } else {
                                    addendum = ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.';
                                }
                                error('%s defines an invalid contextType. ' + 'contextType should point to the Context object returned by React.createContext().%s', getComponentName(type) || 'Component', addendum);
                            }
                        }
                    }
                    if (typeof contextType === 'object' && contextType !== null) {
                        validateContextBounds(contextType, threadID);
                        return contextType[threadID];
                    }
                    {
                        var maskedContext = maskContext(type, context);
                        {
                            if (type.contextTypes) {
                                checkContextTypes(type.contextTypes, maskedContext, 'context');
                            }
                        }
                        return maskedContext;
                    }
                } else {
                    {
                        var _maskedContext = maskContext(type, context);
                        {
                            if (type.contextTypes) {
                                checkContextTypes(type.contextTypes, _maskedContext, 'context');
                            }
                        }
                        return _maskedContext;
                    }
                }
            }
            var nextAvailableThreadIDs = new Uint16Array(16);
            for(var i = 0; i < 15; i++){
                nextAvailableThreadIDs[i] = i + 1;
            }
            nextAvailableThreadIDs[15] = 0;
            function growThreadCountAndReturnNextAvailable() {
                var oldArray = nextAvailableThreadIDs;
                var oldSize = oldArray.length;
                var newSize = oldSize * 2;
                if (!(newSize <= 65536)) {
                    {
                        throw Error("Maximum number of concurrent React renderers exceeded. This can happen if you are not properly destroying the Readable provided by React. Ensure that you call .destroy() on it if you no longer want to read from it, and did not read to the end. If you use .pipe() this should be automatic.");
                    }
                }
                var newArray = new Uint16Array(newSize);
                newArray.set(oldArray);
                nextAvailableThreadIDs = newArray;
                nextAvailableThreadIDs[0] = oldSize + 1;
                for(var _i = oldSize; _i < newSize - 1; _i++){
                    nextAvailableThreadIDs[_i] = _i + 1;
                }
                nextAvailableThreadIDs[newSize - 1] = 0;
                return oldSize;
            }
            function allocThreadID() {
                var nextID = nextAvailableThreadIDs[0];
                if (nextID === 0) {
                    return growThreadCountAndReturnNextAvailable();
                }
                nextAvailableThreadIDs[0] = nextAvailableThreadIDs[nextID];
                return nextID;
            }
            function freeThreadID(id) {
                nextAvailableThreadIDs[id] = nextAvailableThreadIDs[0];
                nextAvailableThreadIDs[0] = id;
            }
            var RESERVED = 0;
            var STRING = 1;
            var BOOLEANISH_STRING = 2;
            var BOOLEAN = 3;
            var OVERLOADED_BOOLEAN = 4;
            var NUMERIC = 5;
            var POSITIVE_NUMERIC = 6;
            var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
            var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
            var ROOT_ATTRIBUTE_NAME = 'data-reactroot';
            var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');
            var hasOwnProperty = Object.prototype.hasOwnProperty;
            var illegalAttributeNameCache = {
            };
            var validatedAttributeNameCache = {
            };
            function isAttributeNameSafe(attributeName) {
                if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
                    return true;
                }
                if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
                    return false;
                }
                if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
                    validatedAttributeNameCache[attributeName] = true;
                    return true;
                }
                illegalAttributeNameCache[attributeName] = true;
                {
                    error('Invalid attribute name: `%s`', attributeName);
                }
                return false;
            }
            function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
                if (propertyInfo !== null) {
                    return propertyInfo.type === RESERVED;
                }
                if (isCustomComponentTag) {
                    return false;
                }
                if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {
                    return true;
                }
                return false;
            }
            function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
                if (propertyInfo !== null && propertyInfo.type === RESERVED) {
                    return false;
                }
                switch(typeof value){
                    case 'function':
                    case 'symbol':
                        return true;
                    case 'boolean':
                        {
                            if (isCustomComponentTag) {
                                return false;
                            }
                            if (propertyInfo !== null) {
                                return !propertyInfo.acceptsBooleans;
                            } else {
                                var prefix1 = name.toLowerCase().slice(0, 5);
                                return prefix1 !== 'data-' && prefix1 !== 'aria-';
                            }
                        }
                    default:
                        return false;
                }
            }
            function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
                if (value === null || typeof value === 'undefined') {
                    return true;
                }
                if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
                    return true;
                }
                if (isCustomComponentTag) {
                    return false;
                }
                if (propertyInfo !== null) {
                    switch(propertyInfo.type){
                        case BOOLEAN:
                            return !value;
                        case OVERLOADED_BOOLEAN:
                            return value === false;
                        case NUMERIC:
                            return isNaN(value);
                        case POSITIVE_NUMERIC:
                            return isNaN(value) || value < 1;
                    }
                }
                return false;
            }
            function getPropertyInfo(name) {
                return properties.hasOwnProperty(name) ? properties[name] : null;
            }
            function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL, removeEmptyString) {
                this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
                this.attributeName = attributeName;
                this.attributeNamespace = attributeNamespace;
                this.mustUseProperty = mustUseProperty;
                this.propertyName = name;
                this.type = type;
                this.sanitizeURL = sanitizeURL;
                this.removeEmptyString = removeEmptyString;
            }
            var properties = {
            };
            var reservedProps = [
                'children',
                'dangerouslySetInnerHTML',
                'defaultValue',
                'defaultChecked',
                'innerHTML',
                'suppressContentEditableWarning',
                'suppressHydrationWarning',
                'style'
            ];
            reservedProps.forEach(function(name) {
                properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null, false, false);
            });
            [
                [
                    'acceptCharset',
                    'accept-charset'
                ],
                [
                    'className',
                    'class'
                ],
                [
                    'htmlFor',
                    'for'
                ],
                [
                    'httpEquiv',
                    'http-equiv'
                ]
            ].forEach(function(_ref) {
                var name = _ref[0], attributeName = _ref[1];
                properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
            });
            [
                'contentEditable',
                'draggable',
                'spellCheck',
                'value'
            ].forEach(function(name) {
                properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null, false, false);
            });
            [
                'autoReverse',
                'externalResourcesRequired',
                'focusable',
                'preserveAlpha'
            ].forEach(function(name) {
                properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null, false, false);
            });
            [
                'allowFullScreen',
                'async',
                'autoFocus',
                'autoPlay',
                'controls',
                'default',
                'defer',
                'disabled',
                'disablePictureInPicture',
                'disableRemotePlayback',
                'formNoValidate',
                'hidden',
                'loop',
                'noModule',
                'noValidate',
                'open',
                'playsInline',
                'readOnly',
                'required',
                'reversed',
                'scoped',
                'seamless',
                'itemScope'
            ].forEach(function(name) {
                properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null, false, false);
            });
            [
                'checked',
                'multiple',
                'muted',
                'selected'
            ].forEach(function(name) {
                properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name, null, false, false);
            });
            [
                'capture',
                'download'
            ].forEach(function(name) {
                properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name, null, false, false);
            });
            [
                'cols',
                'rows',
                'size',
                'span'
            ].forEach(function(name) {
                properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name, null, false, false);
            });
            [
                'rowSpan',
                'start'
            ].forEach(function(name) {
                properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null, false, false);
            });
            var CAMELIZE = /[\-\:]([a-z])/g;
            var capitalize = function(token) {
                return token[1].toUpperCase();
            };
            [
                'accent-height',
                'alignment-baseline',
                'arabic-form',
                'baseline-shift',
                'cap-height',
                'clip-path',
                'clip-rule',
                'color-interpolation',
                'color-interpolation-filters',
                'color-profile',
                'color-rendering',
                'dominant-baseline',
                'enable-background',
                'fill-opacity',
                'fill-rule',
                'flood-color',
                'flood-opacity',
                'font-family',
                'font-size',
                'font-size-adjust',
                'font-stretch',
                'font-style',
                'font-variant',
                'font-weight',
                'glyph-name',
                'glyph-orientation-horizontal',
                'glyph-orientation-vertical',
                'horiz-adv-x',
                'horiz-origin-x',
                'image-rendering',
                'letter-spacing',
                'lighting-color',
                'marker-end',
                'marker-mid',
                'marker-start',
                'overline-position',
                'overline-thickness',
                'paint-order',
                'panose-1',
                'pointer-events',
                'rendering-intent',
                'shape-rendering',
                'stop-color',
                'stop-opacity',
                'strikethrough-position',
                'strikethrough-thickness',
                'stroke-dasharray',
                'stroke-dashoffset',
                'stroke-linecap',
                'stroke-linejoin',
                'stroke-miterlimit',
                'stroke-opacity',
                'stroke-width',
                'text-anchor',
                'text-decoration',
                'text-rendering',
                'underline-position',
                'underline-thickness',
                'unicode-bidi',
                'unicode-range',
                'units-per-em',
                'v-alphabetic',
                'v-hanging',
                'v-ideographic',
                'v-mathematical',
                'vector-effect',
                'vert-adv-y',
                'vert-origin-x',
                'vert-origin-y',
                'word-spacing',
                'writing-mode',
                'xmlns:xlink',
                'x-height'
            ].forEach(function(attributeName) {
                var name = attributeName.replace(CAMELIZE, capitalize);
                properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
            });
            [
                'xlink:actuate',
                'xlink:arcrole',
                'xlink:role',
                'xlink:show',
                'xlink:title',
                'xlink:type'
            ].forEach(function(attributeName) {
                var name = attributeName.replace(CAMELIZE, capitalize);
                properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, 'http://www.w3.org/1999/xlink', false, false);
            });
            [
                'xml:base',
                'xml:lang',
                'xml:space'
            ].forEach(function(attributeName) {
                var name = attributeName.replace(CAMELIZE, capitalize);
                properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, 'http://www.w3.org/XML/1998/namespace', false, false);
            });
            [
                'tabIndex',
                'crossOrigin'
            ].forEach(function(attributeName) {
                properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);
            });
            var xlinkHref = 'xlinkHref';
            properties[xlinkHref] = new PropertyInfoRecord('xlinkHref', STRING, false, 'xlink:href', 'http://www.w3.org/1999/xlink', true, false);
            [
                'src',
                'href',
                'action',
                'formAction'
            ].forEach(function(attributeName) {
                properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);
            });
            var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
            var didWarn = false;
            function sanitizeURL(url) {
                {
                    if (!didWarn && isJavaScriptProtocol.test(url)) {
                        didWarn = true;
                        error('A future version of React will block javascript: URLs as a security precaution. ' + 'Use event handlers instead if you can. If you need to generate unsafe HTML try ' + 'using dangerouslySetInnerHTML instead. React was passed %s.', JSON.stringify(url));
                    }
                }
            }
            var matchHtmlRegExp = /["'&<>]/;
            function escapeHtml(string) {
                var str = '' + string;
                var match = matchHtmlRegExp.exec(str);
                if (!match) {
                    return str;
                }
                var escape;
                var html = '';
                var index;
                var lastIndex = 0;
                for(index = match.index; index < str.length; index++){
                    switch(str.charCodeAt(index)){
                        case 34:
                            escape = '&quot;';
                            break;
                        case 38:
                            escape = '&amp;';
                            break;
                        case 39:
                            escape = '&#x27;';
                            break;
                        case 60:
                            escape = '&lt;';
                            break;
                        case 62:
                            escape = '&gt;';
                            break;
                        default: continue;
                    }
                    if (lastIndex !== index) {
                        html += str.substring(lastIndex, index);
                    }
                    lastIndex = index + 1;
                    html += escape;
                }
                return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
            }
            function escapeTextForBrowser(text) {
                if (typeof text === 'boolean' || typeof text === 'number') {
                    return '' + text;
                }
                return escapeHtml(text);
            }
            function quoteAttributeValueForBrowser(value) {
                return '"' + escapeTextForBrowser(value) + '"';
            }
            function createMarkupForRoot() {
                return ROOT_ATTRIBUTE_NAME + '=""';
            }
            function createMarkupForProperty(name, value) {
                var propertyInfo = getPropertyInfo(name);
                if (name !== 'style' && shouldIgnoreAttribute(name, propertyInfo, false)) {
                    return '';
                }
                if (shouldRemoveAttribute(name, value, propertyInfo, false)) {
                    return '';
                }
                if (propertyInfo !== null) {
                    var attributeName = propertyInfo.attributeName;
                    var type = propertyInfo.type;
                    if (type === BOOLEAN || type === OVERLOADED_BOOLEAN && value === true) {
                        return attributeName + '=""';
                    } else {
                        if (propertyInfo.sanitizeURL) {
                            value = '' + value;
                            sanitizeURL(value);
                        }
                        return attributeName + '=' + quoteAttributeValueForBrowser(value);
                    }
                } else if (isAttributeNameSafe(name)) {
                    return name + '=' + quoteAttributeValueForBrowser(value);
                }
                return '';
            }
            function createMarkupForCustomAttribute(name, value) {
                if (!isAttributeNameSafe(name) || value == null) {
                    return '';
                }
                return name + '=' + quoteAttributeValueForBrowser(value);
            }
            function is(x, y) {
                return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
            }
            var objectIs = typeof Object.is === 'function' ? Object.is : is;
            var currentlyRenderingComponent = null;
            var firstWorkInProgressHook = null;
            var workInProgressHook = null;
            var isReRender = false;
            var didScheduleRenderPhaseUpdate = false;
            var renderPhaseUpdates = null;
            var numberOfReRenders = 0;
            var RE_RENDER_LIMIT = 25;
            var isInHookUserCodeInDev = false;
            var currentHookNameInDev;
            function resolveCurrentlyRenderingComponent() {
                if (!(currentlyRenderingComponent !== null)) {
                    {
                        throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
                    }
                }
                {
                    if (isInHookUserCodeInDev) {
                        error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' + 'You can only call Hooks at the top level of your React function. ' + 'For more information, see ' + 'https://reactjs.org/link/rules-of-hooks');
                    }
                }
                return currentlyRenderingComponent;
            }
            function areHookInputsEqual(nextDeps, prevDeps) {
                if (prevDeps === null) {
                    {
                        error('%s received a final argument during this render, but not during ' + 'the previous render. Even though the final argument is optional, ' + 'its type cannot change between renders.', currentHookNameInDev);
                    }
                    return false;
                }
                {
                    if (nextDeps.length !== prevDeps.length) {
                        error('The final argument passed to %s changed size between renders. The ' + 'order and size of this array must remain constant.\n\n' + 'Previous: %s\n' + 'Incoming: %s', currentHookNameInDev, "[" + nextDeps.join(', ') + "]", "[" + prevDeps.join(', ') + "]");
                    }
                }
                for(var i1 = 0; i1 < prevDeps.length && i1 < nextDeps.length; i1++){
                    if (objectIs(nextDeps[i1], prevDeps[i1])) {
                        continue;
                    }
                    return false;
                }
                return true;
            }
            function createHook() {
                if (numberOfReRenders > 0) {
                    {
                        {
                            throw Error("Rendered more hooks than during the previous render");
                        }
                    }
                }
                return {
                    memoizedState: null,
                    queue: null,
                    next: null
                };
            }
            function createWorkInProgressHook() {
                if (workInProgressHook === null) {
                    if (firstWorkInProgressHook === null) {
                        isReRender = false;
                        firstWorkInProgressHook = workInProgressHook = createHook();
                    } else {
                        isReRender = true;
                        workInProgressHook = firstWorkInProgressHook;
                    }
                } else {
                    if (workInProgressHook.next === null) {
                        isReRender = false;
                        workInProgressHook = workInProgressHook.next = createHook();
                    } else {
                        isReRender = true;
                        workInProgressHook = workInProgressHook.next;
                    }
                }
                return workInProgressHook;
            }
            function prepareToUseHooks(componentIdentity) {
                currentlyRenderingComponent = componentIdentity;
                {
                    isInHookUserCodeInDev = false;
                }
            }
            function finishHooks(Component, props, children, refOrContext) {
                while(didScheduleRenderPhaseUpdate){
                    didScheduleRenderPhaseUpdate = false;
                    numberOfReRenders += 1;
                    workInProgressHook = null;
                    children = Component(props, refOrContext);
                }
                resetHooksState();
                return children;
            }
            function resetHooksState() {
                {
                    isInHookUserCodeInDev = false;
                }
                currentlyRenderingComponent = null;
                didScheduleRenderPhaseUpdate = false;
                firstWorkInProgressHook = null;
                numberOfReRenders = 0;
                renderPhaseUpdates = null;
                workInProgressHook = null;
            }
            function readContext(context, observedBits) {
                var threadID = currentPartialRenderer.threadID;
                validateContextBounds(context, threadID);
                {
                    if (isInHookUserCodeInDev) {
                        error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');
                    }
                }
                return context[threadID];
            }
            function useContext(context, observedBits) {
                {
                    currentHookNameInDev = 'useContext';
                }
                resolveCurrentlyRenderingComponent();
                var threadID = currentPartialRenderer.threadID;
                validateContextBounds(context, threadID);
                return context[threadID];
            }
            function basicStateReducer(state, action) {
                return typeof action === 'function' ? action(state) : action;
            }
            function useState(initialState) {
                {
                    currentHookNameInDev = 'useState';
                }
                return useReducer(basicStateReducer, initialState);
            }
            function useReducer(reducer, initialArg, init) {
                {
                    if (reducer !== basicStateReducer) {
                        currentHookNameInDev = 'useReducer';
                    }
                }
                currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
                workInProgressHook = createWorkInProgressHook();
                if (isReRender) {
                    var queue = workInProgressHook.queue;
                    var dispatch = queue.dispatch;
                    if (renderPhaseUpdates !== null) {
                        var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
                        if (firstRenderPhaseUpdate !== undefined) {
                            renderPhaseUpdates.delete(queue);
                            var newState = workInProgressHook.memoizedState;
                            var update = firstRenderPhaseUpdate;
                            do {
                                var action = update.action;
                                {
                                    isInHookUserCodeInDev = true;
                                }
                                newState = reducer(newState, action);
                                {
                                    isInHookUserCodeInDev = false;
                                }
                                update = update.next;
                            }while (update !== null)
                            workInProgressHook.memoizedState = newState;
                            return [
                                newState,
                                dispatch
                            ];
                        }
                    }
                    return [
                        workInProgressHook.memoizedState,
                        dispatch
                    ];
                } else {
                    {
                        isInHookUserCodeInDev = true;
                    }
                    var initialState;
                    if (reducer === basicStateReducer) {
                        initialState = typeof initialArg === 'function' ? initialArg() : initialArg;
                    } else {
                        initialState = init !== undefined ? init(initialArg) : initialArg;
                    }
                    {
                        isInHookUserCodeInDev = false;
                    }
                    workInProgressHook.memoizedState = initialState;
                    var _queue = workInProgressHook.queue = {
                        last: null,
                        dispatch: null
                    };
                    var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
                    return [
                        workInProgressHook.memoizedState,
                        _dispatch
                    ];
                }
            }
            function useMemo(nextCreate, deps) {
                currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
                workInProgressHook = createWorkInProgressHook();
                var nextDeps = deps === undefined ? null : deps;
                if (workInProgressHook !== null) {
                    var prevState = workInProgressHook.memoizedState;
                    if (prevState !== null) {
                        if (nextDeps !== null) {
                            var prevDeps = prevState[1];
                            if (areHookInputsEqual(nextDeps, prevDeps)) {
                                return prevState[0];
                            }
                        }
                    }
                }
                {
                    isInHookUserCodeInDev = true;
                }
                var nextValue = nextCreate();
                {
                    isInHookUserCodeInDev = false;
                }
                workInProgressHook.memoizedState = [
                    nextValue,
                    nextDeps
                ];
                return nextValue;
            }
            function useRef(initialValue) {
                currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
                workInProgressHook = createWorkInProgressHook();
                var previousRef = workInProgressHook.memoizedState;
                if (previousRef === null) {
                    var ref = {
                        current: initialValue
                    };
                    {
                        Object.seal(ref);
                    }
                    workInProgressHook.memoizedState = ref;
                    return ref;
                } else {
                    return previousRef;
                }
            }
            function useLayoutEffect(create, inputs) {
                {
                    currentHookNameInDev = 'useLayoutEffect';
                    error('useLayoutEffect does nothing on the server, because its effect cannot ' + "be encoded into the server renderer's output format. This will lead " + 'to a mismatch between the initial, non-hydrated UI and the intended ' + 'UI. To avoid this, useLayoutEffect should only be used in ' + 'components that render exclusively on the client. ' + 'See https://reactjs.org/link/uselayouteffect-ssr for common fixes.');
                }
            }
            function dispatchAction(componentIdentity, queue, action) {
                if (!(numberOfReRenders < RE_RENDER_LIMIT)) {
                    {
                        throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
                    }
                }
                if (componentIdentity === currentlyRenderingComponent) {
                    didScheduleRenderPhaseUpdate = true;
                    var update = {
                        action: action,
                        next: null
                    };
                    if (renderPhaseUpdates === null) {
                        renderPhaseUpdates = new Map();
                    }
                    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
                    if (firstRenderPhaseUpdate === undefined) {
                        renderPhaseUpdates.set(queue, update);
                    } else {
                        var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
                        while(lastRenderPhaseUpdate.next !== null){
                            lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
                        }
                        lastRenderPhaseUpdate.next = update;
                    }
                }
            }
            function useCallback(callback, deps) {
                return useMemo(function() {
                    return callback;
                }, deps);
            }
            function useMutableSource(source, getSnapshot, subscribe) {
                resolveCurrentlyRenderingComponent();
                return getSnapshot(source._source);
            }
            function useDeferredValue(value) {
                resolveCurrentlyRenderingComponent();
                return value;
            }
            function useTransition() {
                resolveCurrentlyRenderingComponent();
                var startTransition = function(callback) {
                    callback();
                };
                return [
                    startTransition,
                    false
                ];
            }
            function useOpaqueIdentifier() {
                return (currentPartialRenderer.identifierPrefix || '') + 'R:' + (currentPartialRenderer.uniqueID++).toString(36);
            }
            function noop() {
            }
            var currentPartialRenderer = null;
            function setCurrentPartialRenderer(renderer) {
                currentPartialRenderer = renderer;
            }
            var Dispatcher = {
                readContext: readContext,
                useContext: useContext,
                useMemo: useMemo,
                useReducer: useReducer,
                useRef: useRef,
                useState: useState,
                useLayoutEffect: useLayoutEffect,
                useCallback: useCallback,
                useImperativeHandle: noop,
                useEffect: noop,
                useDebugValue: noop,
                useDeferredValue: useDeferredValue,
                useTransition: useTransition,
                useOpaqueIdentifier: useOpaqueIdentifier,
                useMutableSource: useMutableSource
            };
            var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
            var MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
            var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
            var Namespaces = {
                html: HTML_NAMESPACE,
                mathml: MATH_NAMESPACE,
                svg: SVG_NAMESPACE
            };
            function getIntrinsicNamespace(type) {
                switch(type){
                    case 'svg':
                        return SVG_NAMESPACE;
                    case 'math':
                        return MATH_NAMESPACE;
                    default:
                        return HTML_NAMESPACE;
                }
            }
            function getChildNamespace(parentNamespace, type) {
                if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
                    return getIntrinsicNamespace(type);
                }
                if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {
                    return HTML_NAMESPACE;
                }
                return parentNamespace;
            }
            var hasReadOnlyValue = {
                button: true,
                checkbox: true,
                image: true,
                hidden: true,
                radio: true,
                reset: true,
                submit: true
            };
            function checkControlledValueProps(tagName, props) {
                {
                    if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
                        error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
                    }
                    if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
                        error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
                    }
                }
            }
            var omittedCloseTags = {
                area: true,
                base: true,
                br: true,
                col: true,
                embed: true,
                hr: true,
                img: true,
                input: true,
                keygen: true,
                link: true,
                meta: true,
                param: true,
                source: true,
                track: true,
                wbr: true
            };
            var voidElementTags = _assign({
                menuitem: true
            }, omittedCloseTags);
            var HTML = '__html';
            function assertValidProps(tag, props) {
                if (!props) {
                    return;
                }
                if (voidElementTags[tag]) {
                    if (!(props.children == null && props.dangerouslySetInnerHTML == null)) {
                        {
                            throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                        }
                    }
                }
                if (props.dangerouslySetInnerHTML != null) {
                    if (!(props.children == null)) {
                        {
                            throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
                        }
                    }
                    if (!(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML)) {
                        {
                            throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
                        }
                    }
                }
                {
                    if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
                        error('A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.');
                    }
                }
                if (!(props.style == null || typeof props.style === 'object')) {
                    {
                        throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
                    }
                }
            }
            var isUnitlessNumber = {
                animationIterationCount: true,
                borderImageOutset: true,
                borderImageSlice: true,
                borderImageWidth: true,
                boxFlex: true,
                boxFlexGroup: true,
                boxOrdinalGroup: true,
                columnCount: true,
                columns: true,
                flex: true,
                flexGrow: true,
                flexPositive: true,
                flexShrink: true,
                flexNegative: true,
                flexOrder: true,
                gridArea: true,
                gridRow: true,
                gridRowEnd: true,
                gridRowSpan: true,
                gridRowStart: true,
                gridColumn: true,
                gridColumnEnd: true,
                gridColumnSpan: true,
                gridColumnStart: true,
                fontWeight: true,
                lineClamp: true,
                lineHeight: true,
                opacity: true,
                order: true,
                orphans: true,
                tabSize: true,
                widows: true,
                zIndex: true,
                zoom: true,
                fillOpacity: true,
                floodOpacity: true,
                stopOpacity: true,
                strokeDasharray: true,
                strokeDashoffset: true,
                strokeMiterlimit: true,
                strokeOpacity: true,
                strokeWidth: true
            };
            function prefixKey(prefix2, key) {
                return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
            }
            var prefixes = [
                'Webkit',
                'ms',
                'Moz',
                'O'
            ];
            Object.keys(isUnitlessNumber).forEach(function(prop) {
                prefixes.forEach(function(prefix2) {
                    isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
                });
            });
            function dangerousStyleValue(name, value, isCustomProperty) {
                var isEmpty = value == null || typeof value === 'boolean' || value === '';
                if (isEmpty) {
                    return '';
                }
                if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
                    return value + 'px';
                }
                return ('' + value).trim();
            }
            var uppercasePattern = /([A-Z])/g;
            var msPattern = /^ms-/;
            function hyphenateStyleName(name) {
                return name.replace(uppercasePattern, '-$1').toLowerCase().replace(msPattern, '-ms-');
            }
            function isCustomComponent(tagName, props) {
                if (tagName.indexOf('-') === -1) {
                    return typeof props.is === 'string';
                }
                switch(tagName){
                    case 'annotation-xml':
                    case 'color-profile':
                    case 'font-face':
                    case 'font-face-src':
                    case 'font-face-uri':
                    case 'font-face-format':
                    case 'font-face-name':
                    case 'missing-glyph':
                        return false;
                    default:
                        return true;
                }
            }
            var warnValidStyle = function() {
            };
            {
                var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
                var msPattern$1 = /^-ms-/;
                var hyphenPattern = /-(.)/g;
                var badStyleValueWithSemicolonPattern = /;\s*$/;
                var warnedStyleNames = {
                };
                var warnedStyleValues = {
                };
                var warnedForNaNValue = false;
                var warnedForInfinityValue = false;
                var camelize = function(string) {
                    return string.replace(hyphenPattern, function(_, character) {
                        return character.toUpperCase();
                    });
                };
                var warnHyphenatedStyleName = function(name) {
                    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                        return;
                    }
                    warnedStyleNames[name] = true;
                    error('Unsupported style property %s. Did you mean %s?', name, camelize(name.replace(msPattern$1, 'ms-')));
                };
                var warnBadVendoredStyleName = function(name) {
                    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                        return;
                    }
                    warnedStyleNames[name] = true;
                    error('Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1));
                };
                var warnStyleValueWithSemicolon = function(name, value) {
                    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
                        return;
                    }
                    warnedStyleValues[value] = true;
                    error("Style property values shouldn't contain a semicolon. " + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, ''));
                };
                var warnStyleValueIsNaN = function(name, value) {
                    if (warnedForNaNValue) {
                        return;
                    }
                    warnedForNaNValue = true;
                    error('`NaN` is an invalid value for the `%s` css style property.', name);
                };
                var warnStyleValueIsInfinity = function(name, value) {
                    if (warnedForInfinityValue) {
                        return;
                    }
                    warnedForInfinityValue = true;
                    error('`Infinity` is an invalid value for the `%s` css style property.', name);
                };
                warnValidStyle = function(name, value) {
                    if (name.indexOf('-') > -1) {
                        warnHyphenatedStyleName(name);
                    } else if (badVendoredStyleNamePattern.test(name)) {
                        warnBadVendoredStyleName(name);
                    } else if (badStyleValueWithSemicolonPattern.test(value)) {
                        warnStyleValueWithSemicolon(name, value);
                    }
                    if (typeof value === 'number') {
                        if (isNaN(value)) {
                            warnStyleValueIsNaN(name, value);
                        } else if (!isFinite(value)) {
                            warnStyleValueIsInfinity(name, value);
                        }
                    }
                };
            }
            var warnValidStyle$1 = warnValidStyle;
            var ariaProperties = {
                'aria-current': 0,
                'aria-details': 0,
                'aria-disabled': 0,
                'aria-hidden': 0,
                'aria-invalid': 0,
                'aria-keyshortcuts': 0,
                'aria-label': 0,
                'aria-roledescription': 0,
                'aria-autocomplete': 0,
                'aria-checked': 0,
                'aria-expanded': 0,
                'aria-haspopup': 0,
                'aria-level': 0,
                'aria-modal': 0,
                'aria-multiline': 0,
                'aria-multiselectable': 0,
                'aria-orientation': 0,
                'aria-placeholder': 0,
                'aria-pressed': 0,
                'aria-readonly': 0,
                'aria-required': 0,
                'aria-selected': 0,
                'aria-sort': 0,
                'aria-valuemax': 0,
                'aria-valuemin': 0,
                'aria-valuenow': 0,
                'aria-valuetext': 0,
                'aria-atomic': 0,
                'aria-busy': 0,
                'aria-live': 0,
                'aria-relevant': 0,
                'aria-dropeffect': 0,
                'aria-grabbed': 0,
                'aria-activedescendant': 0,
                'aria-colcount': 0,
                'aria-colindex': 0,
                'aria-colspan': 0,
                'aria-controls': 0,
                'aria-describedby': 0,
                'aria-errormessage': 0,
                'aria-flowto': 0,
                'aria-labelledby': 0,
                'aria-owns': 0,
                'aria-posinset': 0,
                'aria-rowcount': 0,
                'aria-rowindex': 0,
                'aria-rowspan': 0,
                'aria-setsize': 0
            };
            var warnedProperties = {
            };
            var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
            var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');
            var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
            function validateProperty(tagName, name) {
                {
                    if (hasOwnProperty$1.call(warnedProperties, name) && warnedProperties[name]) {
                        return true;
                    }
                    if (rARIACamel.test(name)) {
                        var ariaName = 'aria-' + name.slice(4).toLowerCase();
                        var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
                        if (correctName == null) {
                            error('Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.', name);
                            warnedProperties[name] = true;
                            return true;
                        }
                        if (name !== correctName) {
                            error('Invalid ARIA attribute `%s`. Did you mean `%s`?', name, correctName);
                            warnedProperties[name] = true;
                            return true;
                        }
                    }
                    if (rARIA.test(name)) {
                        var lowerCasedName = name.toLowerCase();
                        var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
                        if (standardName == null) {
                            warnedProperties[name] = true;
                            return false;
                        }
                        if (name !== standardName) {
                            error('Unknown ARIA attribute `%s`. Did you mean `%s`?', name, standardName);
                            warnedProperties[name] = true;
                            return true;
                        }
                    }
                }
                return true;
            }
            function warnInvalidARIAProps(type, props) {
                {
                    var invalidProps = [];
                    for(var key in props){
                        var isValid = validateProperty(type, key);
                        if (!isValid) {
                            invalidProps.push(key);
                        }
                    }
                    var unknownPropString = invalidProps.map(function(prop) {
                        return '`' + prop + '`';
                    }).join(', ');
                    if (invalidProps.length === 1) {
                        error('Invalid aria prop %s on <%s> tag. ' + 'For details, see https://reactjs.org/link/invalid-aria-props', unknownPropString, type);
                    } else if (invalidProps.length > 1) {
                        error('Invalid aria props %s on <%s> tag. ' + 'For details, see https://reactjs.org/link/invalid-aria-props', unknownPropString, type);
                    }
                }
            }
            function validateProperties(type, props) {
                if (isCustomComponent(type, props)) {
                    return;
                }
                warnInvalidARIAProps(type, props);
            }
            var didWarnValueNull = false;
            function validateProperties$1(type, props) {
                {
                    if (type !== 'input' && type !== 'textarea' && type !== 'select') {
                        return;
                    }
                    if (props != null && props.value === null && !didWarnValueNull) {
                        didWarnValueNull = true;
                        if (type === 'select' && props.multiple) {
                            error('`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.', type);
                        } else {
                            error('`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.', type);
                        }
                    }
                }
            }
            var possibleStandardNames = {
                accept: 'accept',
                acceptcharset: 'acceptCharset',
                'accept-charset': 'acceptCharset',
                accesskey: 'accessKey',
                action: 'action',
                allowfullscreen: 'allowFullScreen',
                alt: 'alt',
                as: 'as',
                async: 'async',
                autocapitalize: 'autoCapitalize',
                autocomplete: 'autoComplete',
                autocorrect: 'autoCorrect',
                autofocus: 'autoFocus',
                autoplay: 'autoPlay',
                autosave: 'autoSave',
                capture: 'capture',
                cellpadding: 'cellPadding',
                cellspacing: 'cellSpacing',
                challenge: 'challenge',
                charset: 'charSet',
                checked: 'checked',
                children: 'children',
                cite: 'cite',
                class: 'className',
                classid: 'classID',
                classname: 'className',
                cols: 'cols',
                colspan: 'colSpan',
                content: 'content',
                contenteditable: 'contentEditable',
                contextmenu: 'contextMenu',
                controls: 'controls',
                controlslist: 'controlsList',
                coords: 'coords',
                crossorigin: 'crossOrigin',
                dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
                data: 'data',
                datetime: 'dateTime',
                default: 'default',
                defaultchecked: 'defaultChecked',
                defaultvalue: 'defaultValue',
                defer: 'defer',
                dir: 'dir',
                disabled: 'disabled',
                disablepictureinpicture: 'disablePictureInPicture',
                disableremoteplayback: 'disableRemotePlayback',
                download: 'download',
                draggable: 'draggable',
                enctype: 'encType',
                enterkeyhint: 'enterKeyHint',
                for: 'htmlFor',
                form: 'form',
                formmethod: 'formMethod',
                formaction: 'formAction',
                formenctype: 'formEncType',
                formnovalidate: 'formNoValidate',
                formtarget: 'formTarget',
                frameborder: 'frameBorder',
                headers: 'headers',
                height: 'height',
                hidden: 'hidden',
                high: 'high',
                href: 'href',
                hreflang: 'hrefLang',
                htmlfor: 'htmlFor',
                httpequiv: 'httpEquiv',
                'http-equiv': 'httpEquiv',
                icon: 'icon',
                id: 'id',
                innerhtml: 'innerHTML',
                inputmode: 'inputMode',
                integrity: 'integrity',
                is: 'is',
                itemid: 'itemID',
                itemprop: 'itemProp',
                itemref: 'itemRef',
                itemscope: 'itemScope',
                itemtype: 'itemType',
                keyparams: 'keyParams',
                keytype: 'keyType',
                kind: 'kind',
                label: 'label',
                lang: 'lang',
                list: 'list',
                loop: 'loop',
                low: 'low',
                manifest: 'manifest',
                marginwidth: 'marginWidth',
                marginheight: 'marginHeight',
                max: 'max',
                maxlength: 'maxLength',
                media: 'media',
                mediagroup: 'mediaGroup',
                method: 'method',
                min: 'min',
                minlength: 'minLength',
                multiple: 'multiple',
                muted: 'muted',
                name: 'name',
                nomodule: 'noModule',
                nonce: 'nonce',
                novalidate: 'noValidate',
                open: 'open',
                optimum: 'optimum',
                pattern: 'pattern',
                placeholder: 'placeholder',
                playsinline: 'playsInline',
                poster: 'poster',
                preload: 'preload',
                profile: 'profile',
                radiogroup: 'radioGroup',
                readonly: 'readOnly',
                referrerpolicy: 'referrerPolicy',
                rel: 'rel',
                required: 'required',
                reversed: 'reversed',
                role: 'role',
                rows: 'rows',
                rowspan: 'rowSpan',
                sandbox: 'sandbox',
                scope: 'scope',
                scoped: 'scoped',
                scrolling: 'scrolling',
                seamless: 'seamless',
                selected: 'selected',
                shape: 'shape',
                size: 'size',
                sizes: 'sizes',
                span: 'span',
                spellcheck: 'spellCheck',
                src: 'src',
                srcdoc: 'srcDoc',
                srclang: 'srcLang',
                srcset: 'srcSet',
                start: 'start',
                step: 'step',
                style: 'style',
                summary: 'summary',
                tabindex: 'tabIndex',
                target: 'target',
                title: 'title',
                type: 'type',
                usemap: 'useMap',
                value: 'value',
                width: 'width',
                wmode: 'wmode',
                wrap: 'wrap',
                about: 'about',
                accentheight: 'accentHeight',
                'accent-height': 'accentHeight',
                accumulate: 'accumulate',
                additive: 'additive',
                alignmentbaseline: 'alignmentBaseline',
                'alignment-baseline': 'alignmentBaseline',
                allowreorder: 'allowReorder',
                alphabetic: 'alphabetic',
                amplitude: 'amplitude',
                arabicform: 'arabicForm',
                'arabic-form': 'arabicForm',
                ascent: 'ascent',
                attributename: 'attributeName',
                attributetype: 'attributeType',
                autoreverse: 'autoReverse',
                azimuth: 'azimuth',
                basefrequency: 'baseFrequency',
                baselineshift: 'baselineShift',
                'baseline-shift': 'baselineShift',
                baseprofile: 'baseProfile',
                bbox: 'bbox',
                begin: 'begin',
                bias: 'bias',
                by: 'by',
                calcmode: 'calcMode',
                capheight: 'capHeight',
                'cap-height': 'capHeight',
                clip: 'clip',
                clippath: 'clipPath',
                'clip-path': 'clipPath',
                clippathunits: 'clipPathUnits',
                cliprule: 'clipRule',
                'clip-rule': 'clipRule',
                color: 'color',
                colorinterpolation: 'colorInterpolation',
                'color-interpolation': 'colorInterpolation',
                colorinterpolationfilters: 'colorInterpolationFilters',
                'color-interpolation-filters': 'colorInterpolationFilters',
                colorprofile: 'colorProfile',
                'color-profile': 'colorProfile',
                colorrendering: 'colorRendering',
                'color-rendering': 'colorRendering',
                contentscripttype: 'contentScriptType',
                contentstyletype: 'contentStyleType',
                cursor: 'cursor',
                cx: 'cx',
                cy: 'cy',
                d: 'd',
                datatype: 'datatype',
                decelerate: 'decelerate',
                descent: 'descent',
                diffuseconstant: 'diffuseConstant',
                direction: 'direction',
                display: 'display',
                divisor: 'divisor',
                dominantbaseline: 'dominantBaseline',
                'dominant-baseline': 'dominantBaseline',
                dur: 'dur',
                dx: 'dx',
                dy: 'dy',
                edgemode: 'edgeMode',
                elevation: 'elevation',
                enablebackground: 'enableBackground',
                'enable-background': 'enableBackground',
                end: 'end',
                exponent: 'exponent',
                externalresourcesrequired: 'externalResourcesRequired',
                fill: 'fill',
                fillopacity: 'fillOpacity',
                'fill-opacity': 'fillOpacity',
                fillrule: 'fillRule',
                'fill-rule': 'fillRule',
                filter: 'filter',
                filterres: 'filterRes',
                filterunits: 'filterUnits',
                floodopacity: 'floodOpacity',
                'flood-opacity': 'floodOpacity',
                floodcolor: 'floodColor',
                'flood-color': 'floodColor',
                focusable: 'focusable',
                fontfamily: 'fontFamily',
                'font-family': 'fontFamily',
                fontsize: 'fontSize',
                'font-size': 'fontSize',
                fontsizeadjust: 'fontSizeAdjust',
                'font-size-adjust': 'fontSizeAdjust',
                fontstretch: 'fontStretch',
                'font-stretch': 'fontStretch',
                fontstyle: 'fontStyle',
                'font-style': 'fontStyle',
                fontvariant: 'fontVariant',
                'font-variant': 'fontVariant',
                fontweight: 'fontWeight',
                'font-weight': 'fontWeight',
                format: 'format',
                from: 'from',
                fx: 'fx',
                fy: 'fy',
                g1: 'g1',
                g2: 'g2',
                glyphname: 'glyphName',
                'glyph-name': 'glyphName',
                glyphorientationhorizontal: 'glyphOrientationHorizontal',
                'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
                glyphorientationvertical: 'glyphOrientationVertical',
                'glyph-orientation-vertical': 'glyphOrientationVertical',
                glyphref: 'glyphRef',
                gradienttransform: 'gradientTransform',
                gradientunits: 'gradientUnits',
                hanging: 'hanging',
                horizadvx: 'horizAdvX',
                'horiz-adv-x': 'horizAdvX',
                horizoriginx: 'horizOriginX',
                'horiz-origin-x': 'horizOriginX',
                ideographic: 'ideographic',
                imagerendering: 'imageRendering',
                'image-rendering': 'imageRendering',
                in2: 'in2',
                in: 'in',
                inlist: 'inlist',
                intercept: 'intercept',
                k1: 'k1',
                k2: 'k2',
                k3: 'k3',
                k4: 'k4',
                k: 'k',
                kernelmatrix: 'kernelMatrix',
                kernelunitlength: 'kernelUnitLength',
                kerning: 'kerning',
                keypoints: 'keyPoints',
                keysplines: 'keySplines',
                keytimes: 'keyTimes',
                lengthadjust: 'lengthAdjust',
                letterspacing: 'letterSpacing',
                'letter-spacing': 'letterSpacing',
                lightingcolor: 'lightingColor',
                'lighting-color': 'lightingColor',
                limitingconeangle: 'limitingConeAngle',
                local: 'local',
                markerend: 'markerEnd',
                'marker-end': 'markerEnd',
                markerheight: 'markerHeight',
                markermid: 'markerMid',
                'marker-mid': 'markerMid',
                markerstart: 'markerStart',
                'marker-start': 'markerStart',
                markerunits: 'markerUnits',
                markerwidth: 'markerWidth',
                mask: 'mask',
                maskcontentunits: 'maskContentUnits',
                maskunits: 'maskUnits',
                mathematical: 'mathematical',
                mode: 'mode',
                numoctaves: 'numOctaves',
                offset: 'offset',
                opacity: 'opacity',
                operator: 'operator',
                order: 'order',
                orient: 'orient',
                orientation: 'orientation',
                origin: 'origin',
                overflow: 'overflow',
                overlineposition: 'overlinePosition',
                'overline-position': 'overlinePosition',
                overlinethickness: 'overlineThickness',
                'overline-thickness': 'overlineThickness',
                paintorder: 'paintOrder',
                'paint-order': 'paintOrder',
                panose1: 'panose1',
                'panose-1': 'panose1',
                pathlength: 'pathLength',
                patterncontentunits: 'patternContentUnits',
                patterntransform: 'patternTransform',
                patternunits: 'patternUnits',
                pointerevents: 'pointerEvents',
                'pointer-events': 'pointerEvents',
                points: 'points',
                pointsatx: 'pointsAtX',
                pointsaty: 'pointsAtY',
                pointsatz: 'pointsAtZ',
                prefix: 'prefix',
                preservealpha: 'preserveAlpha',
                preserveaspectratio: 'preserveAspectRatio',
                primitiveunits: 'primitiveUnits',
                property: 'property',
                r: 'r',
                radius: 'radius',
                refx: 'refX',
                refy: 'refY',
                renderingintent: 'renderingIntent',
                'rendering-intent': 'renderingIntent',
                repeatcount: 'repeatCount',
                repeatdur: 'repeatDur',
                requiredextensions: 'requiredExtensions',
                requiredfeatures: 'requiredFeatures',
                resource: 'resource',
                restart: 'restart',
                result: 'result',
                results: 'results',
                rotate: 'rotate',
                rx: 'rx',
                ry: 'ry',
                scale: 'scale',
                security: 'security',
                seed: 'seed',
                shaperendering: 'shapeRendering',
                'shape-rendering': 'shapeRendering',
                slope: 'slope',
                spacing: 'spacing',
                specularconstant: 'specularConstant',
                specularexponent: 'specularExponent',
                speed: 'speed',
                spreadmethod: 'spreadMethod',
                startoffset: 'startOffset',
                stddeviation: 'stdDeviation',
                stemh: 'stemh',
                stemv: 'stemv',
                stitchtiles: 'stitchTiles',
                stopcolor: 'stopColor',
                'stop-color': 'stopColor',
                stopopacity: 'stopOpacity',
                'stop-opacity': 'stopOpacity',
                strikethroughposition: 'strikethroughPosition',
                'strikethrough-position': 'strikethroughPosition',
                strikethroughthickness: 'strikethroughThickness',
                'strikethrough-thickness': 'strikethroughThickness',
                string: 'string',
                stroke: 'stroke',
                strokedasharray: 'strokeDasharray',
                'stroke-dasharray': 'strokeDasharray',
                strokedashoffset: 'strokeDashoffset',
                'stroke-dashoffset': 'strokeDashoffset',
                strokelinecap: 'strokeLinecap',
                'stroke-linecap': 'strokeLinecap',
                strokelinejoin: 'strokeLinejoin',
                'stroke-linejoin': 'strokeLinejoin',
                strokemiterlimit: 'strokeMiterlimit',
                'stroke-miterlimit': 'strokeMiterlimit',
                strokewidth: 'strokeWidth',
                'stroke-width': 'strokeWidth',
                strokeopacity: 'strokeOpacity',
                'stroke-opacity': 'strokeOpacity',
                suppresscontenteditablewarning: 'suppressContentEditableWarning',
                suppresshydrationwarning: 'suppressHydrationWarning',
                surfacescale: 'surfaceScale',
                systemlanguage: 'systemLanguage',
                tablevalues: 'tableValues',
                targetx: 'targetX',
                targety: 'targetY',
                textanchor: 'textAnchor',
                'text-anchor': 'textAnchor',
                textdecoration: 'textDecoration',
                'text-decoration': 'textDecoration',
                textlength: 'textLength',
                textrendering: 'textRendering',
                'text-rendering': 'textRendering',
                to: 'to',
                transform: 'transform',
                typeof: 'typeof',
                u1: 'u1',
                u2: 'u2',
                underlineposition: 'underlinePosition',
                'underline-position': 'underlinePosition',
                underlinethickness: 'underlineThickness',
                'underline-thickness': 'underlineThickness',
                unicode: 'unicode',
                unicodebidi: 'unicodeBidi',
                'unicode-bidi': 'unicodeBidi',
                unicoderange: 'unicodeRange',
                'unicode-range': 'unicodeRange',
                unitsperem: 'unitsPerEm',
                'units-per-em': 'unitsPerEm',
                unselectable: 'unselectable',
                valphabetic: 'vAlphabetic',
                'v-alphabetic': 'vAlphabetic',
                values: 'values',
                vectoreffect: 'vectorEffect',
                'vector-effect': 'vectorEffect',
                version: 'version',
                vertadvy: 'vertAdvY',
                'vert-adv-y': 'vertAdvY',
                vertoriginx: 'vertOriginX',
                'vert-origin-x': 'vertOriginX',
                vertoriginy: 'vertOriginY',
                'vert-origin-y': 'vertOriginY',
                vhanging: 'vHanging',
                'v-hanging': 'vHanging',
                videographic: 'vIdeographic',
                'v-ideographic': 'vIdeographic',
                viewbox: 'viewBox',
                viewtarget: 'viewTarget',
                visibility: 'visibility',
                vmathematical: 'vMathematical',
                'v-mathematical': 'vMathematical',
                vocab: 'vocab',
                widths: 'widths',
                wordspacing: 'wordSpacing',
                'word-spacing': 'wordSpacing',
                writingmode: 'writingMode',
                'writing-mode': 'writingMode',
                x1: 'x1',
                x2: 'x2',
                x: 'x',
                xchannelselector: 'xChannelSelector',
                xheight: 'xHeight',
                'x-height': 'xHeight',
                xlinkactuate: 'xlinkActuate',
                'xlink:actuate': 'xlinkActuate',
                xlinkarcrole: 'xlinkArcrole',
                'xlink:arcrole': 'xlinkArcrole',
                xlinkhref: 'xlinkHref',
                'xlink:href': 'xlinkHref',
                xlinkrole: 'xlinkRole',
                'xlink:role': 'xlinkRole',
                xlinkshow: 'xlinkShow',
                'xlink:show': 'xlinkShow',
                xlinktitle: 'xlinkTitle',
                'xlink:title': 'xlinkTitle',
                xlinktype: 'xlinkType',
                'xlink:type': 'xlinkType',
                xmlbase: 'xmlBase',
                'xml:base': 'xmlBase',
                xmllang: 'xmlLang',
                'xml:lang': 'xmlLang',
                xmlns: 'xmlns',
                'xml:space': 'xmlSpace',
                xmlnsxlink: 'xmlnsXlink',
                'xmlns:xlink': 'xmlnsXlink',
                xmlspace: 'xmlSpace',
                y1: 'y1',
                y2: 'y2',
                y: 'y',
                ychannelselector: 'yChannelSelector',
                z: 'z',
                zoomandpan: 'zoomAndPan'
            };
            var validateProperty$1 = function() {
            };
            {
                var warnedProperties$1 = {
                };
                var _hasOwnProperty = Object.prototype.hasOwnProperty;
                var EVENT_NAME_REGEX = /^on./;
                var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
                var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
                var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');
                validateProperty$1 = function(tagName, name, value, eventRegistry) {
                    if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
                        return true;
                    }
                    var lowerCasedName = name.toLowerCase();
                    if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {
                        error('React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');
                        warnedProperties$1[name] = true;
                        return true;
                    }
                    if (eventRegistry != null) {
                        var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
                        if (registrationNameDependencies.hasOwnProperty(name)) {
                            return true;
                        }
                        var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
                        if (registrationName != null) {
                            error('Invalid event handler property `%s`. Did you mean `%s`?', name, registrationName);
                            warnedProperties$1[name] = true;
                            return true;
                        }
                        if (EVENT_NAME_REGEX.test(name)) {
                            error('Unknown event handler property `%s`. It will be ignored.', name);
                            warnedProperties$1[name] = true;
                            return true;
                        }
                    } else if (EVENT_NAME_REGEX.test(name)) {
                        if (INVALID_EVENT_NAME_REGEX.test(name)) {
                            error('Invalid event handler property `%s`. ' + 'React events use the camelCase naming convention, for example `onClick`.', name);
                        }
                        warnedProperties$1[name] = true;
                        return true;
                    }
                    if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
                        return true;
                    }
                    if (lowerCasedName === 'innerhtml') {
                        error('Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');
                        warnedProperties$1[name] = true;
                        return true;
                    }
                    if (lowerCasedName === 'aria') {
                        error('The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');
                        warnedProperties$1[name] = true;
                        return true;
                    }
                    if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {
                        error('Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.', typeof value);
                        warnedProperties$1[name] = true;
                        return true;
                    }
                    if (typeof value === 'number' && isNaN(value)) {
                        error('Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.', name);
                        warnedProperties$1[name] = true;
                        return true;
                    }
                    var propertyInfo = getPropertyInfo(name);
                    var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
                    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                        var standardName = possibleStandardNames[lowerCasedName];
                        if (standardName !== name) {
                            error('Invalid DOM property `%s`. Did you mean `%s`?', name, standardName);
                            warnedProperties$1[name] = true;
                            return true;
                        }
                    } else if (!isReserved && name !== lowerCasedName) {
                        error('React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.', name, lowerCasedName);
                        warnedProperties$1[name] = true;
                        return true;
                    }
                    if (typeof value === 'boolean' && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
                        if (value) {
                            error('Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.', value, name, name, value, name);
                        } else {
                            error('Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
                        }
                        warnedProperties$1[name] = true;
                        return true;
                    }
                    if (isReserved) {
                        return true;
                    }
                    if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
                        warnedProperties$1[name] = true;
                        return false;
                    }
                    if ((value === 'false' || value === 'true') && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
                        error('Received the string `%s` for the boolean attribute `%s`. ' + '%s ' + 'Did you mean %s={%s}?', value, name, value === 'false' ? 'The browser will interpret it as a truthy value.' : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
                        warnedProperties$1[name] = true;
                        return true;
                    }
                    return true;
                };
            }
            var warnUnknownProperties = function(type, props, eventRegistry) {
                {
                    var unknownProps = [];
                    for(var key in props){
                        var isValid = validateProperty$1(type, key, props[key], eventRegistry);
                        if (!isValid) {
                            unknownProps.push(key);
                        }
                    }
                    var unknownPropString = unknownProps.map(function(prop) {
                        return '`' + prop + '`';
                    }).join(', ');
                    if (unknownProps.length === 1) {
                        error('Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://reactjs.org/link/attribute-behavior ', unknownPropString, type);
                    } else if (unknownProps.length > 1) {
                        error('Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://reactjs.org/link/attribute-behavior ', unknownPropString, type);
                    }
                }
            };
            function validateProperties$2(type, props, eventRegistry) {
                if (isCustomComponent(type, props)) {
                    return;
                }
                warnUnknownProperties(type, props, eventRegistry);
            }
            var toArray = React.Children.toArray;
            var currentDebugStacks = [];
            var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
            var ReactDebugCurrentFrame$1;
            var prevGetCurrentStackImpl = null;
            var getCurrentServerStackImpl = function() {
                return '';
            };
            var describeStackFrame = function(element) {
                return '';
            };
            var validatePropertiesInDevelopment = function(type, props) {
            };
            var pushCurrentDebugStack = function(stack) {
            };
            var pushElementToDebugStack = function(element) {
            };
            var popCurrentDebugStack = function() {
            };
            var hasWarnedAboutUsingContextAsConsumer = false;
            {
                ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
                validatePropertiesInDevelopment = function(type, props) {
                    validateProperties(type, props);
                    validateProperties$1(type, props);
                    validateProperties$2(type, props, null);
                };
                describeStackFrame = function(element) {
                    return describeUnknownElementTypeFrameInDEV(element.type, element._source, null);
                };
                pushCurrentDebugStack = function(stack) {
                    currentDebugStacks.push(stack);
                    if (currentDebugStacks.length === 1) {
                        prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
                        ReactDebugCurrentFrame$1.getCurrentStack = getCurrentServerStackImpl;
                    }
                };
                pushElementToDebugStack = function(element) {
                    var stack = currentDebugStacks[currentDebugStacks.length - 1];
                    var frame = stack[stack.length - 1];
                    frame.debugElementStack.push(element);
                };
                popCurrentDebugStack = function() {
                    currentDebugStacks.pop();
                    if (currentDebugStacks.length === 0) {
                        ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
                        prevGetCurrentStackImpl = null;
                    }
                };
                getCurrentServerStackImpl = function() {
                    if (currentDebugStacks.length === 0) {
                        return '';
                    }
                    var frames = currentDebugStacks[currentDebugStacks.length - 1];
                    var stack = '';
                    for(var i1 = frames.length - 1; i1 >= 0; i1--){
                        var frame = frames[i1];
                        var debugElementStack = frame.debugElementStack;
                        for(var ii = debugElementStack.length - 1; ii >= 0; ii--){
                            stack += describeStackFrame(debugElementStack[ii]);
                        }
                    }
                    return stack;
                };
            }
            var didWarnDefaultInputValue = false;
            var didWarnDefaultChecked = false;
            var didWarnDefaultSelectValue = false;
            var didWarnDefaultTextareaValue = false;
            var didWarnInvalidOptionChildren = false;
            var didWarnAboutNoopUpdateForComponent = {
            };
            var didWarnAboutBadClass = {
            };
            var didWarnAboutModulePatternComponent = {
            };
            var didWarnAboutDeprecatedWillMount = {
            };
            var didWarnAboutUndefinedDerivedState = {
            };
            var didWarnAboutUninitializedState = {
            };
            var valuePropNames = [
                'value',
                'defaultValue'
            ];
            var newlineEatingTags = {
                listing: true,
                pre: true,
                textarea: true
            };
            var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
            var validatedTagCache = {
            };
            function validateDangerousTag(tag) {
                if (!validatedTagCache.hasOwnProperty(tag)) {
                    if (!VALID_TAG_REGEX.test(tag)) {
                        {
                            throw Error("Invalid tag: " + tag);
                        }
                    }
                    validatedTagCache[tag] = true;
                }
            }
            var styleNameCache = {
            };
            var processStyleName = function(styleName) {
                if (styleNameCache.hasOwnProperty(styleName)) {
                    return styleNameCache[styleName];
                }
                var result = hyphenateStyleName(styleName);
                styleNameCache[styleName] = result;
                return result;
            };
            function createMarkupForStyles(styles) {
                var serialized = '';
                var delimiter = '';
                for(var styleName in styles){
                    if (!styles.hasOwnProperty(styleName)) {
                        continue;
                    }
                    var isCustomProperty = styleName.indexOf('--') === 0;
                    var styleValue = styles[styleName];
                    {
                        if (!isCustomProperty) {
                            warnValidStyle$1(styleName, styleValue);
                        }
                    }
                    if (styleValue != null) {
                        serialized += delimiter + (isCustomProperty ? styleName : processStyleName(styleName)) + ':';
                        serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
                        delimiter = ';';
                    }
                }
                return serialized || null;
            }
            function warnNoop(publicInstance, callerName) {
                {
                    var _constructor = publicInstance.constructor;
                    var componentName = _constructor && getComponentName(_constructor) || 'ReactClass';
                    var warningKey = componentName + '.' + callerName;
                    if (didWarnAboutNoopUpdateForComponent[warningKey]) {
                        return;
                    }
                    error('%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op.\n\nPlease check the code for the %s component.', callerName, callerName, componentName);
                    didWarnAboutNoopUpdateForComponent[warningKey] = true;
                }
            }
            function shouldConstruct$1(Component) {
                return Component.prototype && Component.prototype.isReactComponent;
            }
            function getNonChildrenInnerMarkup(props) {
                var innerHTML = props.dangerouslySetInnerHTML;
                if (innerHTML != null) {
                    if (innerHTML.__html != null) {
                        return innerHTML.__html;
                    }
                } else {
                    var content = props.children;
                    if (typeof content === 'string' || typeof content === 'number') {
                        return escapeTextForBrowser(content);
                    }
                }
                return null;
            }
            function flattenTopLevelChildren(children) {
                if (!React.isValidElement(children)) {
                    return toArray(children);
                }
                var element = children;
                if (element.type !== REACT_FRAGMENT_TYPE) {
                    return [
                        element
                    ];
                }
                var fragmentChildren = element.props.children;
                if (!React.isValidElement(fragmentChildren)) {
                    return toArray(fragmentChildren);
                }
                var fragmentChildElement = fragmentChildren;
                return [
                    fragmentChildElement
                ];
            }
            function flattenOptionChildren(children) {
                if (children === undefined || children === null) {
                    return children;
                }
                var content = '';
                React.Children.forEach(children, function(child) {
                    if (child == null) {
                        return;
                    }
                    content += child;
                    {
                        if (!didWarnInvalidOptionChildren && typeof child !== 'string' && typeof child !== 'number') {
                            didWarnInvalidOptionChildren = true;
                            error('Only strings and numbers are supported as <option> children.');
                        }
                    }
                });
                return content;
            }
            var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
            var STYLE = 'style';
            var RESERVED_PROPS = {
                children: null,
                dangerouslySetInnerHTML: null,
                suppressContentEditableWarning: null,
                suppressHydrationWarning: null
            };
            function createOpenTagMarkup(tagVerbatim, tagLowercase, props, namespace, makeStaticMarkup, isRootElement) {
                var ret = '<' + tagVerbatim;
                var isCustomComponent$1 = isCustomComponent(tagLowercase, props);
                for(var propKey in props){
                    if (!hasOwnProperty$2.call(props, propKey)) {
                        continue;
                    }
                    var propValue = props[propKey];
                    if (propValue == null) {
                        continue;
                    }
                    if (propKey === STYLE) {
                        propValue = createMarkupForStyles(propValue);
                    }
                    var markup = null;
                    if (isCustomComponent$1) {
                        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
                            markup = createMarkupForCustomAttribute(propKey, propValue);
                        }
                    } else {
                        markup = createMarkupForProperty(propKey, propValue);
                    }
                    if (markup) {
                        ret += ' ' + markup;
                    }
                }
                if (makeStaticMarkup) {
                    return ret;
                }
                if (isRootElement) {
                    ret += ' ' + createMarkupForRoot();
                }
                return ret;
            }
            function validateRenderResult(child, type) {
                if (child === undefined) {
                    {
                        {
                            throw Error((getComponentName(type) || 'Component') + "(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.");
                        }
                    }
                }
            }
            function resolve(child, context, threadID) {
                while(React.isValidElement(child)){
                    var element = child;
                    var Component = element.type;
                    {
                        pushElementToDebugStack(element);
                    }
                    if (typeof Component !== 'function') {
                        break;
                    }
                    processChild(element, Component);
                }
                function processChild(element, Component) {
                    var isClass = shouldConstruct$1(Component);
                    var publicContext = processContext(Component, context, threadID, isClass);
                    var queue = [];
                    var replace = false;
                    var updater = {
                        isMounted: function(publicInstance) {
                            return false;
                        },
                        enqueueForceUpdate: function(publicInstance) {
                            if (queue === null) {
                                warnNoop(publicInstance, 'forceUpdate');
                                return null;
                            }
                        },
                        enqueueReplaceState: function(publicInstance, completeState) {
                            replace = true;
                            queue = [
                                completeState
                            ];
                        },
                        enqueueSetState: function(publicInstance, currentPartialState) {
                            if (queue === null) {
                                warnNoop(publicInstance, 'setState');
                                return null;
                            }
                            queue.push(currentPartialState);
                        }
                    };
                    var inst;
                    if (isClass) {
                        inst = new Component(element.props, publicContext, updater);
                        if (typeof Component.getDerivedStateFromProps === 'function') {
                            {
                                if (inst.state === null || inst.state === undefined) {
                                    var componentName = getComponentName(Component) || 'Unknown';
                                    if (!didWarnAboutUninitializedState[componentName]) {
                                        error('`%s` uses `getDerivedStateFromProps` but its initial state is ' + '%s. This is not recommended. Instead, define the initial state by ' + 'assigning an object to `this.state` in the constructor of `%s`. ' + 'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.', componentName, inst.state === null ? 'null' : 'undefined', componentName);
                                        didWarnAboutUninitializedState[componentName] = true;
                                    }
                                }
                            }
                            var partialState = Component.getDerivedStateFromProps.call(null, element.props, inst.state);
                            {
                                if (partialState === undefined) {
                                    var _componentName = getComponentName(Component) || 'Unknown';
                                    if (!didWarnAboutUndefinedDerivedState[_componentName]) {
                                        error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', _componentName);
                                        didWarnAboutUndefinedDerivedState[_componentName] = true;
                                    }
                                }
                            }
                            if (partialState != null) {
                                inst.state = _assign({
                                }, inst.state, partialState);
                            }
                        }
                    } else {
                        {
                            if (Component.prototype && typeof Component.prototype.render === 'function') {
                                var _componentName2 = getComponentName(Component) || 'Unknown';
                                if (!didWarnAboutBadClass[_componentName2]) {
                                    error("The <%s /> component appears to have a render method, but doesn't extend React.Component. " + 'This is likely to cause errors. Change %s to extend React.Component instead.', _componentName2, _componentName2);
                                    didWarnAboutBadClass[_componentName2] = true;
                                }
                            }
                        }
                        var componentIdentity = {
                        };
                        prepareToUseHooks(componentIdentity);
                        inst = Component(element.props, publicContext, updater);
                        inst = finishHooks(Component, element.props, inst, publicContext);
                        {
                            if (inst != null && inst.render != null) {
                                var _componentName3 = getComponentName(Component) || 'Unknown';
                                if (!didWarnAboutModulePatternComponent[_componentName3]) {
                                    error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + "If you can't use a class try assigning the prototype on the function as a workaround. " + "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " + 'cannot be called with `new` by React.', _componentName3, _componentName3, _componentName3);
                                    didWarnAboutModulePatternComponent[_componentName3] = true;
                                }
                            }
                        }
                        if (inst == null || inst.render == null) {
                            child = inst;
                            validateRenderResult(child, Component);
                            return;
                        }
                    }
                    inst.props = element.props;
                    inst.context = publicContext;
                    inst.updater = updater;
                    var initialState = inst.state;
                    if (initialState === undefined) {
                        inst.state = initialState = null;
                    }
                    if (typeof inst.UNSAFE_componentWillMount === 'function' || typeof inst.componentWillMount === 'function') {
                        if (typeof inst.componentWillMount === 'function') {
                            {
                                if (inst.componentWillMount.__suppressDeprecationWarning !== true) {
                                    var _componentName4 = getComponentName(Component) || 'Unknown';
                                    if (!didWarnAboutDeprecatedWillMount[_componentName4]) {
                                        warn('componentWillMount has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move code from componentWillMount to componentDidMount (preferred in most cases) ' + 'or the constructor.\n' + '\nPlease update the following components: %s', _componentName4);
                                        didWarnAboutDeprecatedWillMount[_componentName4] = true;
                                    }
                                }
                            }
                            if (typeof Component.getDerivedStateFromProps !== 'function') {
                                inst.componentWillMount();
                            }
                        }
                        if (typeof inst.UNSAFE_componentWillMount === 'function' && typeof Component.getDerivedStateFromProps !== 'function') {
                            inst.UNSAFE_componentWillMount();
                        }
                        if (queue.length) {
                            var oldQueue = queue;
                            var oldReplace = replace;
                            queue = null;
                            replace = false;
                            if (oldReplace && oldQueue.length === 1) {
                                inst.state = oldQueue[0];
                            } else {
                                var nextState = oldReplace ? oldQueue[0] : inst.state;
                                var dontMutate = true;
                                for(var i1 = oldReplace ? 1 : 0; i1 < oldQueue.length; i1++){
                                    var partial = oldQueue[i1];
                                    var _partialState = typeof partial === 'function' ? partial.call(inst, nextState, element.props, publicContext) : partial;
                                    if (_partialState != null) {
                                        if (dontMutate) {
                                            dontMutate = false;
                                            nextState = _assign({
                                            }, nextState, _partialState);
                                        } else {
                                            _assign(nextState, _partialState);
                                        }
                                    }
                                }
                                inst.state = nextState;
                            }
                        } else {
                            queue = null;
                        }
                    }
                    child = inst.render();
                    {
                        if (child === undefined && inst.render._isMockFunction) {
                            child = null;
                        }
                    }
                    validateRenderResult(child, Component);
                    var childContext;
                    {
                        if (typeof inst.getChildContext === 'function') {
                            var _childContextTypes = Component.childContextTypes;
                            if (typeof _childContextTypes === 'object') {
                                childContext = inst.getChildContext();
                                for(var contextKey in childContext){
                                    if (!(contextKey in _childContextTypes)) {
                                        {
                                            throw Error((getComponentName(Component) || 'Unknown') + ".getChildContext(): key \"" + contextKey + "\" is not defined in childContextTypes.");
                                        }
                                    }
                                }
                            } else {
                                {
                                    error('%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', getComponentName(Component) || 'Unknown');
                                }
                            }
                        }
                        if (childContext) {
                            context = _assign({
                            }, context, childContext);
                        }
                    }
                }
                return {
                    child: child,
                    context: context
                };
            }
            var ReactDOMServerRenderer = function() {
                function ReactDOMServerRenderer(children, makeStaticMarkup, options) {
                    var flatChildren = flattenTopLevelChildren(children);
                    var topFrame = {
                        type: null,
                        domNamespace: Namespaces.html,
                        children: flatChildren,
                        childIndex: 0,
                        context: emptyObject,
                        footer: ''
                    };
                    {
                        topFrame.debugElementStack = [];
                    }
                    this.threadID = allocThreadID();
                    this.stack = [
                        topFrame
                    ];
                    this.exhausted = false;
                    this.currentSelectValue = null;
                    this.previousWasTextNode = false;
                    this.makeStaticMarkup = makeStaticMarkup;
                    this.suspenseDepth = 0;
                    this.contextIndex = -1;
                    this.contextStack = [];
                    this.contextValueStack = [];
                    this.uniqueID = 0;
                    this.identifierPrefix = options && options.identifierPrefix || '';
                    {
                        this.contextProviderStack = [];
                    }
                }
                var _proto = ReactDOMServerRenderer.prototype;
                _proto.destroy = function destroy() {
                    if (!this.exhausted) {
                        this.exhausted = true;
                        this.clearProviders();
                        freeThreadID(this.threadID);
                    }
                };
                _proto.pushProvider = function pushProvider(provider) {
                    var index = ++this.contextIndex;
                    var context = provider.type._context;
                    var threadID = this.threadID;
                    validateContextBounds(context, threadID);
                    var previousValue = context[threadID];
                    this.contextStack[index] = context;
                    this.contextValueStack[index] = previousValue;
                    {
                        this.contextProviderStack[index] = provider;
                    }
                    context[threadID] = provider.props.value;
                };
                _proto.popProvider = function popProvider(provider) {
                    var index = this.contextIndex;
                    {
                        if (index < 0 || provider !== this.contextProviderStack[index]) {
                            error('Unexpected pop.');
                        }
                    }
                    var context = this.contextStack[index];
                    var previousValue = this.contextValueStack[index];
                    this.contextStack[index] = null;
                    this.contextValueStack[index] = null;
                    {
                        this.contextProviderStack[index] = null;
                    }
                    this.contextIndex--;
                    context[this.threadID] = previousValue;
                };
                _proto.clearProviders = function clearProviders() {
                    for(var index = this.contextIndex; index >= 0; index--){
                        var context = this.contextStack[index];
                        var previousValue = this.contextValueStack[index];
                        context[this.threadID] = previousValue;
                    }
                };
                _proto.read = function read(bytes) {
                    if (this.exhausted) {
                        return null;
                    }
                    var prevPartialRenderer = currentPartialRenderer;
                    setCurrentPartialRenderer(this);
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = Dispatcher;
                    try {
                        var out = [
                            ''
                        ];
                        var suspended = false;
                        while(out[0].length < bytes){
                            if (this.stack.length === 0) {
                                this.exhausted = true;
                                freeThreadID(this.threadID);
                                break;
                            }
                            var frame = this.stack[this.stack.length - 1];
                            if (suspended || frame.childIndex >= frame.children.length) {
                                var footer = frame.footer;
                                if (footer !== '') {
                                    this.previousWasTextNode = false;
                                }
                                this.stack.pop();
                                if (frame.type === 'select') {
                                    this.currentSelectValue = null;
                                } else if (frame.type != null && frame.type.type != null && frame.type.type.$$typeof === REACT_PROVIDER_TYPE) {
                                    var provider = frame.type;
                                    this.popProvider(provider);
                                } else if (frame.type === REACT_SUSPENSE_TYPE) {
                                    this.suspenseDepth--;
                                    var buffered = out.pop();
                                    if (suspended) {
                                        suspended = false;
                                        var fallbackFrame = frame.fallbackFrame;
                                        if (!fallbackFrame) {
                                            {
                                                throw Error(true ? "ReactDOMServer did not find an internal fallback frame for Suspense. This is a bug in React. Please file an issue." : formatProdErrorMessage(303));
                                            }
                                        }
                                        this.stack.push(fallbackFrame);
                                        out[this.suspenseDepth] += '<!--$!-->';
                                        continue;
                                    } else {
                                        out[this.suspenseDepth] += buffered;
                                    }
                                }
                                out[this.suspenseDepth] += footer;
                                continue;
                            }
                            var child = frame.children[frame.childIndex++];
                            var outBuffer = '';
                            if (true) {
                                pushCurrentDebugStack(this.stack);
                                frame.debugElementStack.length = 0;
                            }
                            try {
                                outBuffer += this.render(child, frame.context, frame.domNamespace);
                            } catch (err) {
                                if (err != null && typeof err.then === 'function') {
                                    if (enableSuspenseServerRenderer) {
                                        if (!(this.suspenseDepth > 0)) {
                                            {
                                                throw Error(true ? "A React component suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." : formatProdErrorMessage(342));
                                            }
                                        }
                                        suspended = true;
                                    } else {
                                        if (!false) {
                                            {
                                                throw Error(true ? "ReactDOMServer does not yet support Suspense." : formatProdErrorMessage(294));
                                            }
                                        }
                                    }
                                } else {
                                    throw err;
                                }
                            } finally{
                                if (true) {
                                    popCurrentDebugStack();
                                }
                            }
                            if (out.length <= this.suspenseDepth) {
                                out.push('');
                            }
                            out[this.suspenseDepth] += outBuffer;
                        }
                        return out[0];
                    } finally{
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                        setCurrentPartialRenderer(prevPartialRenderer);
                        resetHooksState();
                    }
                };
                _proto.render = function render(child, context, parentNamespace) {
                    if (typeof child === 'string' || typeof child === 'number') {
                        var text = '' + child;
                        if (text === '') {
                            return '';
                        }
                        if (this.makeStaticMarkup) {
                            return escapeTextForBrowser(text);
                        }
                        if (this.previousWasTextNode) {
                            return '<!-- -->' + escapeTextForBrowser(text);
                        }
                        this.previousWasTextNode = true;
                        return escapeTextForBrowser(text);
                    } else {
                        var nextChild;
                        var _resolve = resolve(child, context, this.threadID);
                        nextChild = _resolve.child;
                        context = _resolve.context;
                        if (nextChild === null || nextChild === false) {
                            return '';
                        } else if (!React.isValidElement(nextChild)) {
                            if (nextChild != null && nextChild.$$typeof != null) {
                                var $$typeof = nextChild.$$typeof;
                                if (!($$typeof !== REACT_PORTAL_TYPE)) {
                                    {
                                        throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
                                    }
                                }
                                {
                                    {
                                        throw Error("Unknown element-like object type: " + $$typeof.toString() + ". This is likely a bug in React. Please file an issue.");
                                    }
                                }
                            }
                            var nextChildren = toArray(nextChild);
                            var frame = {
                                type: null,
                                domNamespace: parentNamespace,
                                children: nextChildren,
                                childIndex: 0,
                                context: context,
                                footer: ''
                            };
                            {
                                frame.debugElementStack = [];
                            }
                            this.stack.push(frame);
                            return '';
                        }
                        var nextElement = nextChild;
                        var elementType = nextElement.type;
                        if (typeof elementType === 'string') {
                            return this.renderDOM(nextElement, context, parentNamespace);
                        }
                        switch(elementType){
                            case REACT_LEGACY_HIDDEN_TYPE:
                            case REACT_DEBUG_TRACING_MODE_TYPE:
                            case REACT_STRICT_MODE_TYPE:
                            case REACT_PROFILER_TYPE:
                            case REACT_SUSPENSE_LIST_TYPE:
                            case REACT_FRAGMENT_TYPE:
                                {
                                    var _nextChildren = toArray(nextChild.props.children);
                                    var _frame = {
                                        type: null,
                                        domNamespace: parentNamespace,
                                        children: _nextChildren,
                                        childIndex: 0,
                                        context: context,
                                        footer: ''
                                    };
                                    {
                                        _frame.debugElementStack = [];
                                    }
                                    this.stack.push(_frame);
                                    return '';
                                }
                            case REACT_SUSPENSE_TYPE:
                                {
                                    {
                                        {
                                            {
                                                throw Error("ReactDOMServer does not yet support Suspense.");
                                            }
                                        }
                                    }
                                }
                            case REACT_SCOPE_TYPE:
                                {
                                    {
                                        {
                                            throw Error("ReactDOMServer does not yet support scope components.");
                                        }
                                    }
                                }
                        }
                        if (typeof elementType === 'object' && elementType !== null) {
                            switch(elementType.$$typeof){
                                case REACT_FORWARD_REF_TYPE:
                                    {
                                        var element = nextChild;
                                        var _nextChildren5;
                                        var componentIdentity = {
                                        };
                                        prepareToUseHooks(componentIdentity);
                                        _nextChildren5 = elementType.render(element.props, element.ref);
                                        _nextChildren5 = finishHooks(elementType.render, element.props, _nextChildren5, element.ref);
                                        _nextChildren5 = toArray(_nextChildren5);
                                        var _frame5 = {
                                            type: null,
                                            domNamespace: parentNamespace,
                                            children: _nextChildren5,
                                            childIndex: 0,
                                            context: context,
                                            footer: ''
                                        };
                                        {
                                            _frame5.debugElementStack = [];
                                        }
                                        this.stack.push(_frame5);
                                        return '';
                                    }
                                case REACT_MEMO_TYPE:
                                    {
                                        var _element = nextChild;
                                        var _nextChildren6 = [
                                            React.createElement(elementType.type, _assign({
                                                ref: _element.ref
                                            }, _element.props))
                                        ];
                                        var _frame6 = {
                                            type: null,
                                            domNamespace: parentNamespace,
                                            children: _nextChildren6,
                                            childIndex: 0,
                                            context: context,
                                            footer: ''
                                        };
                                        {
                                            _frame6.debugElementStack = [];
                                        }
                                        this.stack.push(_frame6);
                                        return '';
                                    }
                                case REACT_PROVIDER_TYPE:
                                    {
                                        var provider = nextChild;
                                        var nextProps = provider.props;
                                        var _nextChildren7 = toArray(nextProps.children);
                                        var _frame7 = {
                                            type: provider,
                                            domNamespace: parentNamespace,
                                            children: _nextChildren7,
                                            childIndex: 0,
                                            context: context,
                                            footer: ''
                                        };
                                        {
                                            _frame7.debugElementStack = [];
                                        }
                                        this.pushProvider(provider);
                                        this.stack.push(_frame7);
                                        return '';
                                    }
                                case REACT_CONTEXT_TYPE:
                                    {
                                        var reactContext = nextChild.type;
                                        {
                                            if (reactContext._context === undefined) {
                                                if (reactContext !== reactContext.Consumer) {
                                                    if (!hasWarnedAboutUsingContextAsConsumer) {
                                                        hasWarnedAboutUsingContextAsConsumer = true;
                                                        error('Rendering <Context> directly is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
                                                    }
                                                }
                                            } else {
                                                reactContext = reactContext._context;
                                            }
                                        }
                                        var _nextProps = nextChild.props;
                                        var threadID = this.threadID;
                                        validateContextBounds(reactContext, threadID);
                                        var nextValue = reactContext[threadID];
                                        var _nextChildren8 = toArray(_nextProps.children(nextValue));
                                        var _frame8 = {
                                            type: nextChild,
                                            domNamespace: parentNamespace,
                                            children: _nextChildren8,
                                            childIndex: 0,
                                            context: context,
                                            footer: ''
                                        };
                                        {
                                            _frame8.debugElementStack = [];
                                        }
                                        this.stack.push(_frame8);
                                        return '';
                                    }
                                case REACT_FUNDAMENTAL_TYPE:
                                    {
                                        {
                                            {
                                                throw Error("ReactDOMServer does not yet support the fundamental API.");
                                            }
                                        }
                                    }
                                case REACT_LAZY_TYPE:
                                    {
                                        var _element2 = nextChild;
                                        var lazyComponent = nextChild.type;
                                        var payload = lazyComponent._payload;
                                        var init = lazyComponent._init;
                                        var result = init(payload);
                                        var _nextChildren10 = [
                                            React.createElement(result, _assign({
                                                ref: _element2.ref
                                            }, _element2.props))
                                        ];
                                        var _frame10 = {
                                            type: null,
                                            domNamespace: parentNamespace,
                                            children: _nextChildren10,
                                            childIndex: 0,
                                            context: context,
                                            footer: ''
                                        };
                                        {
                                            _frame10.debugElementStack = [];
                                        }
                                        this.stack.push(_frame10);
                                        return '';
                                    }
                            }
                        }
                        var info = '';
                        {
                            var owner = nextElement._owner;
                            if (elementType === undefined || typeof elementType === 'object' && elementType !== null && Object.keys(elementType).length === 0) {
                                info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and " + 'named imports.';
                            }
                            var ownerName = owner ? getComponentName(owner) : null;
                            if (ownerName) {
                                info += '\n\nCheck the render method of `' + ownerName + '`.';
                            }
                        }
                        {
                            {
                                throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (elementType == null ? elementType : typeof elementType) + "." + info);
                            }
                        }
                    }
                };
                _proto.renderDOM = function renderDOM(element, context, parentNamespace) {
                    var tag = element.type.toLowerCase();
                    var namespace = parentNamespace;
                    if (parentNamespace === Namespaces.html) {
                        namespace = getIntrinsicNamespace(tag);
                    }
                    {
                        if (namespace === Namespaces.html) {
                            if (tag !== element.type) {
                                error('<%s /> is using incorrect casing. ' + 'Use PascalCase for React components, ' + 'or lowercase for HTML elements.', element.type);
                            }
                        }
                    }
                    validateDangerousTag(tag);
                    var props = element.props;
                    if (tag === 'input') {
                        {
                            checkControlledValueProps('input', props);
                            if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnDefaultChecked) {
                                error('%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components', 'A component', props.type);
                                didWarnDefaultChecked = true;
                            }
                            if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultInputValue) {
                                error('%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components', 'A component', props.type);
                                didWarnDefaultInputValue = true;
                            }
                        }
                        props = _assign({
                            type: undefined
                        }, props, {
                            defaultChecked: undefined,
                            defaultValue: undefined,
                            value: props.value != null ? props.value : props.defaultValue,
                            checked: props.checked != null ? props.checked : props.defaultChecked
                        });
                    } else if (tag === 'textarea') {
                        {
                            checkControlledValueProps('textarea', props);
                            if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultTextareaValue) {
                                error('Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components');
                                didWarnDefaultTextareaValue = true;
                            }
                        }
                        var initialValue = props.value;
                        if (initialValue == null) {
                            var defaultValue = props.defaultValue;
                            var textareaChildren = props.children;
                            if (textareaChildren != null) {
                                {
                                    error('Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');
                                }
                                if (!(defaultValue == null)) {
                                    {
                                        throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                                    }
                                }
                                if (Array.isArray(textareaChildren)) {
                                    if (!(textareaChildren.length <= 1)) {
                                        {
                                            throw Error("<textarea> can only have at most one child.");
                                        }
                                    }
                                    textareaChildren = textareaChildren[0];
                                }
                                defaultValue = '' + textareaChildren;
                            }
                            if (defaultValue == null) {
                                defaultValue = '';
                            }
                            initialValue = defaultValue;
                        }
                        props = _assign({
                        }, props, {
                            value: undefined,
                            children: '' + initialValue
                        });
                    } else if (tag === 'select') {
                        {
                            checkControlledValueProps('select', props);
                            for(var i2 = 0; i2 < valuePropNames.length; i2++){
                                var propName = valuePropNames[i2];
                                if (props[propName] == null) {
                                    continue;
                                }
                                var isArray = Array.isArray(props[propName]);
                                if (props.multiple && !isArray) {
                                    error('The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.', propName);
                                } else if (!props.multiple && isArray) {
                                    error('The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.', propName);
                                }
                            }
                            if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultSelectValue) {
                                error('Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components');
                                didWarnDefaultSelectValue = true;
                            }
                        }
                        this.currentSelectValue = props.value != null ? props.value : props.defaultValue;
                        props = _assign({
                        }, props, {
                            value: undefined
                        });
                    } else if (tag === 'option') {
                        var selected = null;
                        var selectValue = this.currentSelectValue;
                        var optionChildren = flattenOptionChildren(props.children);
                        if (selectValue != null) {
                            var value;
                            if (props.value != null) {
                                value = props.value + '';
                            } else {
                                value = optionChildren;
                            }
                            selected = false;
                            if (Array.isArray(selectValue)) {
                                for(var j = 0; j < selectValue.length; j++){
                                    if ('' + selectValue[j] === value) {
                                        selected = true;
                                        break;
                                    }
                                }
                            } else {
                                selected = '' + selectValue === value;
                            }
                            props = _assign({
                                selected: undefined,
                                children: undefined
                            }, props, {
                                selected: selected,
                                children: optionChildren
                            });
                        }
                    }
                    {
                        validatePropertiesInDevelopment(tag, props);
                    }
                    assertValidProps(tag, props);
                    var out = createOpenTagMarkup(element.type, tag, props, namespace, this.makeStaticMarkup, this.stack.length === 1);
                    var footer = '';
                    if (omittedCloseTags.hasOwnProperty(tag)) {
                        out += '/>';
                    } else {
                        out += '>';
                        footer = '</' + element.type + '>';
                    }
                    var children;
                    var innerMarkup = getNonChildrenInnerMarkup(props);
                    if (innerMarkup != null) {
                        children = [];
                        if (newlineEatingTags.hasOwnProperty(tag) && innerMarkup.charAt(0) === '\n') {
                            out += '\n';
                        }
                        out += innerMarkup;
                    } else {
                        children = toArray(props.children);
                    }
                    var frame = {
                        domNamespace: getChildNamespace(parentNamespace, element.type),
                        type: tag,
                        children: children,
                        childIndex: 0,
                        context: context,
                        footer: footer
                    };
                    {
                        frame.debugElementStack = [];
                    }
                    this.stack.push(frame);
                    this.previousWasTextNode = false;
                    return out;
                };
                return ReactDOMServerRenderer;
            }();
            function renderToString(element, options) {
                var renderer = new ReactDOMServerRenderer(element, false, options);
                try {
                    var markup = renderer.read(Infinity);
                    return markup;
                } finally{
                    renderer.destroy();
                }
            }
            function renderToStaticMarkup(element, options) {
                var renderer = new ReactDOMServerRenderer(element, true, options);
                try {
                    var markup = renderer.read(Infinity);
                    return markup;
                } finally{
                    renderer.destroy();
                }
            }
            function renderToNodeStream() {
                {
                    {
                        throw Error("ReactDOMServer.renderToNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToString() instead.");
                    }
                }
            }
            function renderToStaticNodeStream() {
                {
                    {
                        throw Error("ReactDOMServer.renderToStaticNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToStaticMarkup() instead.");
                    }
                }
            }
            exports3.renderToNodeStream = renderToNodeStream;
            exports3.renderToStaticMarkup = renderToStaticMarkup;
            exports3.renderToStaticNodeStream = renderToStaticNodeStream;
            exports3.renderToString = renderToString;
            exports3.version = ReactVersion;
        })();
    }
    return exports3;
}
var exports4 = {
}, _dewExec4 = false;
function dew4() {
    if (_dewExec4) return exports4;
    _dewExec4 = true;
    {
        exports4 = dew3();
    }
    return exports4;
}
const __default1 = dew4();
function concat(origin, b) {
    const output = new Uint8Array(origin.length + b.length);
    output.set(origin, 0);
    output.set(b, origin.length);
    return output;
}
function copyBytes(src, dst, off = 0) {
    off = Math.max(0, Math.min(off, dst.byteLength));
    const dstBytesAvailable = dst.byteLength - off;
    if (src.byteLength > dstBytesAvailable) {
        src = src.subarray(0, dstBytesAvailable);
    }
    dst.set(src, off);
    return src.byteLength;
}
class DenoStdInternalError extends Error {
    constructor(message1){
        super(message1);
        this.name = "DenoStdInternalError";
    }
}
function assert(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError(msg);
    }
}
const DEFAULT_BUF_SIZE = 4096;
const MIN_BUF_SIZE = 16;
const CR = "\r".charCodeAt(0);
const LF = "\n".charCodeAt(0);
class BufferFullError extends Error {
    name = "BufferFullError";
    constructor(partial){
        super("Buffer full");
        this.partial = partial;
    }
}
class PartialReadError extends Deno.errors.UnexpectedEof {
    name = "PartialReadError";
    constructor(){
        super("Encountered UnexpectedEof, data only partially read");
    }
}
class BufReader {
    r = 0;
    w = 0;
    eof = false;
    static create(r, size = 4096) {
        return r instanceof BufReader ? r : new BufReader(r, size);
    }
    constructor(rd1, size1 = 4096){
        if (size1 < 16) {
            size1 = MIN_BUF_SIZE;
        }
        this._reset(new Uint8Array(size1), rd1);
    }
    size() {
        return this.buf.byteLength;
    }
    buffered() {
        return this.w - this.r;
    }
    async _fill() {
        if (this.r > 0) {
            this.buf.copyWithin(0, this.r, this.w);
            this.w -= this.r;
            this.r = 0;
        }
        if (this.w >= this.buf.byteLength) {
            throw Error("bufio: tried to fill full buffer");
        }
        for(let i3 = 100; i3 > 0; i3--){
            const rr = await this.rd.read(this.buf.subarray(this.w));
            if (rr === null) {
                this.eof = true;
                return;
            }
            assert(rr >= 0, "negative read");
            this.w += rr;
            if (rr > 0) {
                return;
            }
        }
        throw new Error(`No progress after ${100} read() calls`);
    }
    reset(r) {
        this._reset(this.buf, r);
    }
    _reset(buf, rd) {
        this.buf = buf;
        this.rd = rd;
        this.eof = false;
    }
    async read(p) {
        let rr = p.byteLength;
        if (p.byteLength === 0) return rr;
        if (this.r === this.w) {
            if (p.byteLength >= this.buf.byteLength) {
                const rr1 = await this.rd.read(p);
                const nread = rr1 ?? 0;
                assert(nread >= 0, "negative read");
                return rr1;
            }
            this.r = 0;
            this.w = 0;
            rr = await this.rd.read(this.buf);
            if (rr === 0 || rr === null) return rr;
            assert(rr >= 0, "negative read");
            this.w += rr;
        }
        const copied = copyBytes(this.buf.subarray(this.r, this.w), p, 0);
        this.r += copied;
        return copied;
    }
    async readFull(p) {
        let bytesRead = 0;
        while(bytesRead < p.length){
            try {
                const rr = await this.read(p.subarray(bytesRead));
                if (rr === null) {
                    if (bytesRead === 0) {
                        return null;
                    } else {
                        throw new PartialReadError();
                    }
                }
                bytesRead += rr;
            } catch (err) {
                err.partial = p.subarray(0, bytesRead);
                throw err;
            }
        }
        return p;
    }
    async readByte() {
        while(this.r === this.w){
            if (this.eof) return null;
            await this._fill();
        }
        const c = this.buf[this.r];
        this.r++;
        return c;
    }
    async readString(delim) {
        if (delim.length !== 1) {
            throw new Error("Delimiter should be a single character");
        }
        const buffer = await this.readSlice(delim.charCodeAt(0));
        if (buffer === null) return null;
        return new TextDecoder().decode(buffer);
    }
    async readLine() {
        let line;
        try {
            line = await this.readSlice(LF);
        } catch (err) {
            let { partial: partial1  } = err;
            assert(partial1 instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
            if (!(err instanceof BufferFullError)) {
                throw err;
            }
            if (!this.eof && partial1.byteLength > 0 && partial1[partial1.byteLength - 1] === CR) {
                assert(this.r > 0, "bufio: tried to rewind past start of buffer");
                this.r--;
                partial1 = partial1.subarray(0, partial1.byteLength - 1);
            }
            return {
                line: partial1,
                more: !this.eof
            };
        }
        if (line === null) {
            return null;
        }
        if (line.byteLength === 0) {
            return {
                line,
                more: false
            };
        }
        if (line[line.byteLength - 1] == LF) {
            let drop = 1;
            if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {
                drop = 2;
            }
            line = line.subarray(0, line.byteLength - drop);
        }
        return {
            line,
            more: false
        };
    }
    async readSlice(delim) {
        let s = 0;
        let slice;
        while(true){
            let i3 = this.buf.subarray(this.r + s, this.w).indexOf(delim);
            if (i3 >= 0) {
                i3 += s;
                slice = this.buf.subarray(this.r, this.r + i3 + 1);
                this.r += i3 + 1;
                break;
            }
            if (this.eof) {
                if (this.r === this.w) {
                    return null;
                }
                slice = this.buf.subarray(this.r, this.w);
                this.r = this.w;
                break;
            }
            if (this.buffered() >= this.buf.byteLength) {
                this.r = this.w;
                const oldbuf = this.buf;
                const newbuf = this.buf.slice(0);
                this.buf = newbuf;
                throw new BufferFullError(oldbuf);
            }
            s = this.w - this.r;
            try {
                await this._fill();
            } catch (err) {
                err.partial = slice;
                throw err;
            }
        }
        return slice;
    }
    async peek(n) {
        if (n < 0) {
            throw Error("negative count");
        }
        let avail = this.w - this.r;
        while(avail < n && avail < this.buf.byteLength && !this.eof){
            try {
                await this._fill();
            } catch (err) {
                err.partial = this.buf.subarray(this.r, this.w);
                throw err;
            }
            avail = this.w - this.r;
        }
        if (avail === 0 && this.eof) {
            return null;
        } else if (avail < n && this.eof) {
            return this.buf.subarray(this.r, this.r + avail);
        } else if (avail < n) {
            throw new BufferFullError(this.buf.subarray(this.r, this.w));
        }
        return this.buf.subarray(this.r, this.r + n);
    }
}
class AbstractBufBase {
    usedBufferBytes = 0;
    err = null;
    size() {
        return this.buf.byteLength;
    }
    available() {
        return this.buf.byteLength - this.usedBufferBytes;
    }
    buffered() {
        return this.usedBufferBytes;
    }
}
class BufWriter extends AbstractBufBase {
    static create(writer, size = 4096) {
        return writer instanceof BufWriter ? writer : new BufWriter(writer, size);
    }
    constructor(writer1, size2 = 4096){
        super();
        this.writer = writer1;
        if (size2 <= 0) {
            size2 = DEFAULT_BUF_SIZE;
        }
        this.buf = new Uint8Array(size2);
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.writer = w;
    }
    async flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            await Deno.writeAll(this.writer, this.buf.subarray(0, this.usedBufferBytes));
        } catch (e) {
            this.err = e;
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    async write(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = await this.writer.write(data);
                } catch (e) {
                    this.err = e;
                    throw e;
                }
            } else {
                numBytesWritten = copyBytes(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                await this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copyBytes(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
class BufWriterSync extends AbstractBufBase {
    static create(writer, size = 4096) {
        return writer instanceof BufWriterSync ? writer : new BufWriterSync(writer, size);
    }
    constructor(writer2, size3 = 4096){
        super();
        this.writer = writer2;
        if (size3 <= 0) {
            size3 = DEFAULT_BUF_SIZE;
        }
        this.buf = new Uint8Array(size3);
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.writer = w;
    }
    flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            Deno.writeAllSync(this.writer, this.buf.subarray(0, this.usedBufferBytes));
        } catch (e) {
            this.err = e;
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    writeSync(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = this.writer.writeSync(data);
                } catch (e) {
                    this.err = e;
                    throw e;
                }
            } else {
                numBytesWritten = copyBytes(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copyBytes(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
const encoder = new TextEncoder();
function encode(input) {
    return encoder.encode(input);
}
const decoder = new TextDecoder();
function decode(input) {
    return decoder.decode(input);
}
const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/g;
function str(buf) {
    if (buf == null) {
        return "";
    } else {
        return decode(buf);
    }
}
function charCode(s) {
    return s.charCodeAt(0);
}
class TextProtoReader {
    constructor(r1){
        this.r = r1;
    }
    async readLine() {
        const s = await this.readLineSlice();
        if (s === null) return null;
        return str(s);
    }
    async readMIMEHeader() {
        const m = new Headers();
        let line;
        let buf = await this.r.peek(1);
        if (buf === null) {
            return null;
        } else if (buf[0] == charCode(" ") || buf[0] == charCode("\t")) {
            line = await this.readLineSlice();
        }
        buf = await this.r.peek(1);
        if (buf === null) {
            throw new Deno.errors.UnexpectedEof();
        } else if (buf[0] == charCode(" ") || buf[0] == charCode("\t")) {
            throw new Deno.errors.InvalidData(`malformed MIME header initial line: ${str(line)}`);
        }
        while(true){
            const kv = await this.readLineSlice();
            if (kv === null) throw new Deno.errors.UnexpectedEof();
            if (kv.byteLength === 0) return m;
            let i3 = kv.indexOf(charCode(":"));
            if (i3 < 0) {
                throw new Deno.errors.InvalidData(`malformed MIME header line: ${str(kv)}`);
            }
            const key = str(kv.subarray(0, i3));
            if (key == "") {
                continue;
            }
            i3++;
            while(i3 < kv.byteLength && (kv[i3] == charCode(" ") || kv[i3] == charCode("\t"))){
                i3++;
            }
            const value = str(kv.subarray(i3)).replace(invalidHeaderCharRegex, encodeURI);
            try {
                m.append(key, value);
            } catch  {
            }
        }
    }
    async readLineSlice() {
        let line;
        while(true){
            const r1 = await this.r.readLine();
            if (r1 === null) return null;
            const { line: l , more  } = r1;
            if (!line && !more) {
                if (this.skipSpace(l) === 0) {
                    return new Uint8Array(0);
                }
                return l;
            }
            line = line ? concat(line, l) : l;
            if (!more) {
                break;
            }
        }
        return line;
    }
    skipSpace(l) {
        let n = 0;
        for(let i3 = 0; i3 < l.length; i3++){
            if (l[i3] === charCode(" ") || l[i3] === charCode("\t")) {
                continue;
            }
            n++;
        }
        return n;
    }
}
var Status;
(function(Status1) {
    Status1[Status1["Continue"] = 100] = "Continue";
    Status1[Status1["SwitchingProtocols"] = 101] = "SwitchingProtocols";
    Status1[Status1["Processing"] = 102] = "Processing";
    Status1[Status1["EarlyHints"] = 103] = "EarlyHints";
    Status1[Status1["OK"] = 200] = "OK";
    Status1[Status1["Created"] = 201] = "Created";
    Status1[Status1["Accepted"] = 202] = "Accepted";
    Status1[Status1["NonAuthoritativeInfo"] = 203] = "NonAuthoritativeInfo";
    Status1[Status1["NoContent"] = 204] = "NoContent";
    Status1[Status1["ResetContent"] = 205] = "ResetContent";
    Status1[Status1["PartialContent"] = 206] = "PartialContent";
    Status1[Status1["MultiStatus"] = 207] = "MultiStatus";
    Status1[Status1["AlreadyReported"] = 208] = "AlreadyReported";
    Status1[Status1["IMUsed"] = 226] = "IMUsed";
    Status1[Status1["MultipleChoices"] = 300] = "MultipleChoices";
    Status1[Status1["MovedPermanently"] = 301] = "MovedPermanently";
    Status1[Status1["Found"] = 302] = "Found";
    Status1[Status1["SeeOther"] = 303] = "SeeOther";
    Status1[Status1["NotModified"] = 304] = "NotModified";
    Status1[Status1["UseProxy"] = 305] = "UseProxy";
    Status1[Status1["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    Status1[Status1["PermanentRedirect"] = 308] = "PermanentRedirect";
    Status1[Status1["BadRequest"] = 400] = "BadRequest";
    Status1[Status1["Unauthorized"] = 401] = "Unauthorized";
    Status1[Status1["PaymentRequired"] = 402] = "PaymentRequired";
    Status1[Status1["Forbidden"] = 403] = "Forbidden";
    Status1[Status1["NotFound"] = 404] = "NotFound";
    Status1[Status1["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    Status1[Status1["NotAcceptable"] = 406] = "NotAcceptable";
    Status1[Status1["ProxyAuthRequired"] = 407] = "ProxyAuthRequired";
    Status1[Status1["RequestTimeout"] = 408] = "RequestTimeout";
    Status1[Status1["Conflict"] = 409] = "Conflict";
    Status1[Status1["Gone"] = 410] = "Gone";
    Status1[Status1["LengthRequired"] = 411] = "LengthRequired";
    Status1[Status1["PreconditionFailed"] = 412] = "PreconditionFailed";
    Status1[Status1["RequestEntityTooLarge"] = 413] = "RequestEntityTooLarge";
    Status1[Status1["RequestURITooLong"] = 414] = "RequestURITooLong";
    Status1[Status1["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
    Status1[Status1["RequestedRangeNotSatisfiable"] = 416] = "RequestedRangeNotSatisfiable";
    Status1[Status1["ExpectationFailed"] = 417] = "ExpectationFailed";
    Status1[Status1["Teapot"] = 418] = "Teapot";
    Status1[Status1["MisdirectedRequest"] = 421] = "MisdirectedRequest";
    Status1[Status1["UnprocessableEntity"] = 422] = "UnprocessableEntity";
    Status1[Status1["Locked"] = 423] = "Locked";
    Status1[Status1["FailedDependency"] = 424] = "FailedDependency";
    Status1[Status1["TooEarly"] = 425] = "TooEarly";
    Status1[Status1["UpgradeRequired"] = 426] = "UpgradeRequired";
    Status1[Status1["PreconditionRequired"] = 428] = "PreconditionRequired";
    Status1[Status1["TooManyRequests"] = 429] = "TooManyRequests";
    Status1[Status1["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
    Status1[Status1["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
    Status1[Status1["InternalServerError"] = 500] = "InternalServerError";
    Status1[Status1["NotImplemented"] = 501] = "NotImplemented";
    Status1[Status1["BadGateway"] = 502] = "BadGateway";
    Status1[Status1["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    Status1[Status1["GatewayTimeout"] = 504] = "GatewayTimeout";
    Status1[Status1["HTTPVersionNotSupported"] = 505] = "HTTPVersionNotSupported";
    Status1[Status1["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
    Status1[Status1["InsufficientStorage"] = 507] = "InsufficientStorage";
    Status1[Status1["LoopDetected"] = 508] = "LoopDetected";
    Status1[Status1["NotExtended"] = 510] = "NotExtended";
    Status1[Status1["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";
})(Status || (Status = {
}));
const STATUS_TEXT = new Map([
    [
        Status.Continue,
        "Continue"
    ],
    [
        Status.SwitchingProtocols,
        "Switching Protocols"
    ],
    [
        Status.Processing,
        "Processing"
    ],
    [
        Status.EarlyHints,
        "Early Hints"
    ],
    [
        Status.OK,
        "OK"
    ],
    [
        Status.Created,
        "Created"
    ],
    [
        Status.Accepted,
        "Accepted"
    ],
    [
        Status.NonAuthoritativeInfo,
        "Non-Authoritative Information"
    ],
    [
        Status.NoContent,
        "No Content"
    ],
    [
        Status.ResetContent,
        "Reset Content"
    ],
    [
        Status.PartialContent,
        "Partial Content"
    ],
    [
        Status.MultiStatus,
        "Multi-Status"
    ],
    [
        Status.AlreadyReported,
        "Already Reported"
    ],
    [
        Status.IMUsed,
        "IM Used"
    ],
    [
        Status.MultipleChoices,
        "Multiple Choices"
    ],
    [
        Status.MovedPermanently,
        "Moved Permanently"
    ],
    [
        Status.Found,
        "Found"
    ],
    [
        Status.SeeOther,
        "See Other"
    ],
    [
        Status.NotModified,
        "Not Modified"
    ],
    [
        Status.UseProxy,
        "Use Proxy"
    ],
    [
        Status.TemporaryRedirect,
        "Temporary Redirect"
    ],
    [
        Status.PermanentRedirect,
        "Permanent Redirect"
    ],
    [
        Status.BadRequest,
        "Bad Request"
    ],
    [
        Status.Unauthorized,
        "Unauthorized"
    ],
    [
        Status.PaymentRequired,
        "Payment Required"
    ],
    [
        Status.Forbidden,
        "Forbidden"
    ],
    [
        Status.NotFound,
        "Not Found"
    ],
    [
        Status.MethodNotAllowed,
        "Method Not Allowed"
    ],
    [
        Status.NotAcceptable,
        "Not Acceptable"
    ],
    [
        Status.ProxyAuthRequired,
        "Proxy Authentication Required"
    ],
    [
        Status.RequestTimeout,
        "Request Timeout"
    ],
    [
        Status.Conflict,
        "Conflict"
    ],
    [
        Status.Gone,
        "Gone"
    ],
    [
        Status.LengthRequired,
        "Length Required"
    ],
    [
        Status.PreconditionFailed,
        "Precondition Failed"
    ],
    [
        Status.RequestEntityTooLarge,
        "Request Entity Too Large"
    ],
    [
        Status.RequestURITooLong,
        "Request URI Too Long"
    ],
    [
        Status.UnsupportedMediaType,
        "Unsupported Media Type"
    ],
    [
        Status.RequestedRangeNotSatisfiable,
        "Requested Range Not Satisfiable"
    ],
    [
        Status.ExpectationFailed,
        "Expectation Failed"
    ],
    [
        Status.Teapot,
        "I'm a teapot"
    ],
    [
        Status.MisdirectedRequest,
        "Misdirected Request"
    ],
    [
        Status.UnprocessableEntity,
        "Unprocessable Entity"
    ],
    [
        Status.Locked,
        "Locked"
    ],
    [
        Status.FailedDependency,
        "Failed Dependency"
    ],
    [
        Status.TooEarly,
        "Too Early"
    ],
    [
        Status.UpgradeRequired,
        "Upgrade Required"
    ],
    [
        Status.PreconditionRequired,
        "Precondition Required"
    ],
    [
        Status.TooManyRequests,
        "Too Many Requests"
    ],
    [
        Status.RequestHeaderFieldsTooLarge,
        "Request Header Fields Too Large"
    ],
    [
        Status.UnavailableForLegalReasons,
        "Unavailable For Legal Reasons"
    ],
    [
        Status.InternalServerError,
        "Internal Server Error"
    ],
    [
        Status.NotImplemented,
        "Not Implemented"
    ],
    [
        Status.BadGateway,
        "Bad Gateway"
    ],
    [
        Status.ServiceUnavailable,
        "Service Unavailable"
    ],
    [
        Status.GatewayTimeout,
        "Gateway Timeout"
    ],
    [
        Status.HTTPVersionNotSupported,
        "HTTP Version Not Supported"
    ],
    [
        Status.VariantAlsoNegotiates,
        "Variant Also Negotiates"
    ],
    [
        Status.InsufficientStorage,
        "Insufficient Storage"
    ],
    [
        Status.LoopDetected,
        "Loop Detected"
    ],
    [
        Status.NotExtended,
        "Not Extended"
    ],
    [
        Status.NetworkAuthenticationRequired,
        "Network Authentication Required"
    ], 
]);
function deferred() {
    let methods;
    const promise = new Promise((resolve, reject)=>{
        methods = {
            resolve,
            reject
        };
    });
    return Object.assign(promise, methods);
}
class MuxAsyncIterator {
    iteratorCount = 0;
    yields = [];
    throws = [];
    signal = deferred();
    add(iterator) {
        ++this.iteratorCount;
        this.callIteratorNext(iterator);
    }
    async callIteratorNext(iterator) {
        try {
            const { value , done  } = await iterator.next();
            if (done) {
                --this.iteratorCount;
            } else {
                this.yields.push({
                    iterator,
                    value
                });
            }
        } catch (e) {
            this.throws.push(e);
        }
        this.signal.resolve();
    }
    async *iterate() {
        while(this.iteratorCount > 0){
            await this.signal;
            for(let i3 = 0; i3 < this.yields.length; i3++){
                const { iterator , value  } = this.yields[i3];
                yield value;
                this.callIteratorNext(iterator);
            }
            if (this.throws.length) {
                for (const e of this.throws){
                    throw e;
                }
                this.throws.length = 0;
            }
            this.yields.length = 0;
            this.signal = deferred();
        }
    }
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
}
function emptyReader() {
    return {
        read (_) {
            return Promise.resolve(null);
        }
    };
}
function bodyReader(contentLength, r1) {
    let totalRead = 0;
    let finished = false;
    async function read(buf) {
        if (finished) return null;
        let result;
        const remaining = contentLength - totalRead;
        if (remaining >= buf.byteLength) {
            result = await r1.read(buf);
        } else {
            const readBuf = buf.subarray(0, remaining);
            result = await r1.read(readBuf);
        }
        if (result !== null) {
            totalRead += result;
        }
        finished = totalRead === contentLength;
        return result;
    }
    return {
        read
    };
}
function chunkedBodyReader(h, r1) {
    const tp = new TextProtoReader(r1);
    let finished = false;
    const chunks = [];
    async function read(buf) {
        if (finished) return null;
        const [chunk] = chunks;
        if (chunk) {
            const chunkRemaining = chunk.data.byteLength - chunk.offset;
            const readLength = Math.min(chunkRemaining, buf.byteLength);
            for(let i3 = 0; i3 < readLength; i3++){
                buf[i3] = chunk.data[chunk.offset + i3];
            }
            chunk.offset += readLength;
            if (chunk.offset === chunk.data.byteLength) {
                chunks.shift();
                if (await tp.readLine() === null) {
                    throw new Deno.errors.UnexpectedEof();
                }
            }
            return readLength;
        }
        const line = await tp.readLine();
        if (line === null) throw new Deno.errors.UnexpectedEof();
        const [chunkSizeString] = line.split(";");
        const chunkSize = parseInt(chunkSizeString, 16);
        if (Number.isNaN(chunkSize) || chunkSize < 0) {
            throw new Error("Invalid chunk size");
        }
        if (chunkSize > 0) {
            if (chunkSize > buf.byteLength) {
                let eof = await r1.readFull(buf);
                if (eof === null) {
                    throw new Deno.errors.UnexpectedEof();
                }
                const restChunk = new Uint8Array(chunkSize - buf.byteLength);
                eof = await r1.readFull(restChunk);
                if (eof === null) {
                    throw new Deno.errors.UnexpectedEof();
                } else {
                    chunks.push({
                        offset: 0,
                        data: restChunk
                    });
                }
                return buf.byteLength;
            } else {
                const bufToFill = buf.subarray(0, chunkSize);
                const eof = await r1.readFull(bufToFill);
                if (eof === null) {
                    throw new Deno.errors.UnexpectedEof();
                }
                if (await tp.readLine() === null) {
                    throw new Deno.errors.UnexpectedEof();
                }
                return chunkSize;
            }
        } else {
            assert(chunkSize === 0);
            if (await r1.readLine() === null) {
                throw new Deno.errors.UnexpectedEof();
            }
            await readTrailers1(h, r1);
            finished = true;
            return null;
        }
    }
    return {
        read
    };
}
function isProhibidedForTrailer(key) {
    const s = new Set([
        "transfer-encoding",
        "content-length",
        "trailer"
    ]);
    return s.has(key.toLowerCase());
}
async function readTrailers1(headers, r1) {
    const trailers = parseTrailer1(headers.get("trailer"));
    if (trailers == null) return;
    const trailerNames = [
        ...trailers.keys()
    ];
    const tp = new TextProtoReader(r1);
    const result = await tp.readMIMEHeader();
    if (result == null) {
        throw new Deno.errors.InvalidData("Missing trailer header.");
    }
    const undeclared = [
        ...result.keys()
    ].filter((k)=>!trailerNames.includes(k)
    );
    if (undeclared.length > 0) {
        throw new Deno.errors.InvalidData(`Undeclared trailers: ${Deno.inspect(undeclared)}.`);
    }
    for (const [k, v] of result){
        headers.append(k, v);
    }
    const missingTrailers = trailerNames.filter((k1)=>!result.has(k1)
    );
    if (missingTrailers.length > 0) {
        throw new Deno.errors.InvalidData(`Missing trailers: ${Deno.inspect(missingTrailers)}.`);
    }
    headers.delete("trailer");
}
function parseTrailer1(field) {
    if (field == null) {
        return undefined;
    }
    const trailerNames = field.split(",").map((v)=>v.trim().toLowerCase()
    );
    if (trailerNames.length === 0) {
        throw new Deno.errors.InvalidData("Empty trailer header.");
    }
    const prohibited = trailerNames.filter((k)=>isProhibidedForTrailer(k)
    );
    if (prohibited.length > 0) {
        throw new Deno.errors.InvalidData(`Prohibited trailer names: ${Deno.inspect(prohibited)}.`);
    }
    return new Headers(trailerNames.map((key)=>[
            key,
            ""
        ]
    ));
}
async function writeChunkedBody(w, r1) {
    const writer3 = BufWriter.create(w);
    for await (const chunk of Deno.iter(r1)){
        if (chunk.byteLength <= 0) continue;
        const start = encoder.encode(`${chunk.byteLength.toString(16)}\r\n`);
        const end = encoder.encode("\r\n");
        await writer3.write(start);
        await writer3.write(chunk);
        await writer3.write(end);
    }
    const endChunk = encoder.encode("0\r\n\r\n");
    await writer3.write(endChunk);
}
async function writeTrailers(w, headers, trailers) {
    const trailer = headers.get("trailer");
    if (trailer === null) {
        throw new TypeError("Missing trailer header.");
    }
    const transferEncoding = headers.get("transfer-encoding");
    if (transferEncoding === null || !transferEncoding.match(/^chunked/)) {
        throw new TypeError(`Trailers are only allowed for "transfer-encoding: chunked", got "transfer-encoding: ${transferEncoding}".`);
    }
    const writer3 = BufWriter.create(w);
    const trailerNames = trailer.split(",").map((s)=>s.trim().toLowerCase()
    );
    const prohibitedTrailers = trailerNames.filter((k)=>isProhibidedForTrailer(k)
    );
    if (prohibitedTrailers.length > 0) {
        throw new TypeError(`Prohibited trailer names: ${Deno.inspect(prohibitedTrailers)}.`);
    }
    const undeclared = [
        ...trailers.keys()
    ].filter((k)=>!trailerNames.includes(k)
    );
    if (undeclared.length > 0) {
        throw new TypeError(`Undeclared trailers: ${Deno.inspect(undeclared)}.`);
    }
    for (const [key, value] of trailers){
        await writer3.write(encoder.encode(`${key}: ${value}\r\n`));
    }
    await writer3.write(encoder.encode("\r\n"));
    await writer3.flush();
}
async function writeResponse(w, r1) {
    const protoMajor = 1;
    const protoMinor = 1;
    const statusCode = r1.status || 200;
    const statusText = STATUS_TEXT.get(statusCode);
    const writer3 = BufWriter.create(w);
    if (!statusText) {
        throw new Deno.errors.InvalidData("Bad status code");
    }
    if (!r1.body) {
        r1.body = new Uint8Array();
    }
    if (typeof r1.body === "string") {
        r1.body = encoder.encode(r1.body);
    }
    let out = `HTTP/${1}.${1} ${statusCode} ${statusText}\r\n`;
    const headers = r1.headers ?? new Headers();
    if (r1.body && !headers.get("content-length")) {
        if (r1.body instanceof Uint8Array) {
            out += `content-length: ${r1.body.byteLength}\r\n`;
        } else if (!headers.get("transfer-encoding")) {
            out += "transfer-encoding: chunked\r\n";
        }
    }
    for (const [key, value] of headers){
        out += `${key}: ${value}\r\n`;
    }
    out += `\r\n`;
    const header = encoder.encode(out);
    const n = await writer3.write(header);
    assert(n === header.byteLength);
    if (r1.body instanceof Uint8Array) {
        const n1 = await writer3.write(r1.body);
        assert(n1 === r1.body.byteLength);
    } else if (headers.has("content-length")) {
        const contentLength = headers.get("content-length");
        assert(contentLength != null);
        const bodyLength = parseInt(contentLength);
        const n1 = await Deno.copy(r1.body, writer3);
        assert(n1 === bodyLength);
    } else {
        await writeChunkedBody(writer3, r1.body);
    }
    if (r1.trailers) {
        const t = await r1.trailers();
        await writeTrailers(writer3, headers, t);
    }
    await writer3.flush();
}
class ServerRequest {
    done = deferred();
    _contentLength = undefined;
    get contentLength() {
        if (this._contentLength === undefined) {
            const cl = this.headers.get("content-length");
            if (cl) {
                this._contentLength = parseInt(cl);
                if (Number.isNaN(this._contentLength)) {
                    this._contentLength = null;
                }
            } else {
                this._contentLength = null;
            }
        }
        return this._contentLength;
    }
    _body = null;
    get body() {
        if (!this._body) {
            if (this.contentLength != null) {
                this._body = bodyReader(this.contentLength, this.r);
            } else {
                const transferEncoding = this.headers.get("transfer-encoding");
                if (transferEncoding != null) {
                    const parts = transferEncoding.split(",").map((e)=>e.trim().toLowerCase()
                    );
                    assert(parts.includes("chunked"), 'transfer-encoding must include "chunked" if content-length is not set');
                    this._body = chunkedBodyReader(this.headers, this.r);
                } else {
                    this._body = emptyReader();
                }
            }
        }
        return this._body;
    }
    async respond(r) {
        let err;
        try {
            await writeResponse(this.w, r);
        } catch (e) {
            try {
                this.conn.close();
            } catch  {
            }
            err = e;
        }
        this.done.resolve(err);
        if (err) {
            throw err;
        }
    }
    finalized = false;
    async finalize() {
        if (this.finalized) return;
        const body = this.body;
        const buf = new Uint8Array(1024);
        while(await body.read(buf) !== null){
        }
        this.finalized = true;
    }
}
function parseHTTPVersion(vers) {
    switch(vers){
        case "HTTP/1.1":
            return [
                1,
                1
            ];
        case "HTTP/1.0":
            return [
                1,
                0
            ];
        default:
            {
                const Big = 1000000;
                if (!vers.startsWith("HTTP/")) {
                    break;
                }
                const dot = vers.indexOf(".");
                if (dot < 0) {
                    break;
                }
                const majorStr = vers.substring(vers.indexOf("/") + 1, dot);
                const major = Number(majorStr);
                if (!Number.isInteger(major) || major < 0 || major > 1000000) {
                    break;
                }
                const minorStr = vers.substring(dot + 1);
                const minor = Number(minorStr);
                if (!Number.isInteger(minor) || minor < 0 || minor > 1000000) {
                    break;
                }
                return [
                    major,
                    minor
                ];
            }
    }
    throw new Error(`malformed HTTP version ${vers}`);
}
async function readRequest(conn, bufr) {
    const tp = new TextProtoReader(bufr);
    const firstLine = await tp.readLine();
    if (firstLine === null) return null;
    const headers = await tp.readMIMEHeader();
    if (headers === null) throw new Deno.errors.UnexpectedEof();
    const req = new ServerRequest();
    req.conn = conn;
    req.r = bufr;
    [req.method, req.url, req.proto] = firstLine.split(" ", 3);
    [req.protoMinor, req.protoMajor] = parseHTTPVersion(req.proto);
    req.headers = headers;
    fixLength1(req);
    return req;
}
class Server {
    closing = false;
    connections = [];
    constructor(listener){
        this.listener = listener;
    }
    close() {
        this.closing = true;
        this.listener.close();
        for (const conn of this.connections){
            try {
                conn.close();
            } catch (e) {
                if (!(e instanceof Deno.errors.BadResource)) {
                    throw e;
                }
            }
        }
    }
    async *iterateHttpRequests(conn) {
        const reader = new BufReader(conn);
        const writer3 = new BufWriter(conn);
        while(!this.closing){
            let request;
            try {
                request = await readRequest(conn, reader);
            } catch (error) {
                if (error instanceof Deno.errors.InvalidData || error instanceof Deno.errors.UnexpectedEof) {
                    await writeResponse(writer3, {
                        status: 400,
                        body: encode(`${error.message}\r\n\r\n`)
                    });
                }
                break;
            }
            if (request === null) {
                break;
            }
            request.w = writer3;
            yield request;
            const responseError = await request.done;
            if (responseError) {
                this.untrackConnection(request.conn);
                return;
            }
            await request.finalize();
        }
        this.untrackConnection(conn);
        try {
            conn.close();
        } catch (e) {
        }
    }
    trackConnection(conn) {
        this.connections.push(conn);
    }
    untrackConnection(conn) {
        const index = this.connections.indexOf(conn);
        if (index !== -1) {
            this.connections.splice(index, 1);
        }
    }
    async *acceptConnAndIterateHttpRequests(mux) {
        if (this.closing) return;
        let conn;
        try {
            conn = await this.listener.accept();
        } catch (error) {
            if (error instanceof Deno.errors.BadResource || error instanceof Deno.errors.InvalidData || error instanceof Deno.errors.UnexpectedEof) {
                return mux.add(this.acceptConnAndIterateHttpRequests(mux));
            }
            throw error;
        }
        this.trackConnection(conn);
        mux.add(this.acceptConnAndIterateHttpRequests(mux));
        yield* this.iterateHttpRequests(conn);
    }
    [Symbol.asyncIterator]() {
        const mux = new MuxAsyncIterator();
        mux.add(this.acceptConnAndIterateHttpRequests(mux));
        return mux.iterate();
    }
}
function _parseAddrFromStr(addr) {
    let url;
    try {
        const host = addr.startsWith(":") ? `0.0.0.0${addr}` : addr;
        url = new URL(`http://${host}`);
    } catch  {
        throw new TypeError("Invalid address.");
    }
    if (url.username || url.password || url.pathname != "/" || url.search || url.hash) {
        throw new TypeError("Invalid address.");
    }
    return {
        hostname: url.hostname,
        port: url.port === "" ? 80 : Number(url.port)
    };
}
function serve(addr) {
    if (typeof addr === "string") {
        addr = _parseAddrFromStr(addr);
    }
    const listener1 = Deno.listen(addr);
    return new Server(listener1);
}
function serveTLS(options) {
    const tlsOptions = {
        ...options,
        transport: "tcp"
    };
    const listener1 = Deno.listenTls(tlsOptions);
    return new Server(listener1);
}
function fixLength1(req) {
    const contentLength = req.headers.get("Content-Length");
    if (contentLength) {
        const arrClen = contentLength.split(",");
        if (arrClen.length > 1) {
            const distinct = [
                ...new Set(arrClen.map((e)=>e.trim()
                ))
            ];
            if (distinct.length > 1) {
                throw Error("cannot contain multiple Content-Length headers");
            } else {
                req.headers.set("Content-Length", distinct[0]);
            }
        }
        const c = req.headers.get("Content-Length");
        if (req.method === "HEAD" && c && c !== "0") {
            throw Error("http: method cannot contain a Content-Length");
        }
        if (c && req.headers.has("transfer-encoding")) {
            throw new Error("http: Transfer-Encoding and Content-Length cannot be send together");
        }
    }
}
class Tokenizer {
    constructor(rules = []){
        this.rules = rules;
    }
    addRule(test, fn) {
        this.rules.push({
            test,
            fn
        });
        return this;
    }
    tokenize(string, receiver = (token)=>token
    ) {
        function* generator(rules1) {
            let index = 0;
            for (const rule of rules1){
                const result = rule.test(string);
                if (result) {
                    const { value , length  } = result;
                    index += length;
                    string = string.slice(length);
                    const token = {
                        ...rule.fn(value),
                        index
                    };
                    yield receiver(token);
                    yield* generator(rules1);
                }
            }
        }
        const tokenGenerator = generator(this.rules);
        const tokens = [];
        for (const token of tokenGenerator){
            tokens.push(token);
        }
        if (string.length) {
            throw new Error(`parser error: string not fully parsed! ${string.slice(0, 25)}`);
        }
        return tokens;
    }
}
function digits(value, count = 2) {
    return String(value).padStart(count, "0");
}
function createLiteralTestFunction(value) {
    return (string)=>{
        return string.startsWith(value) ? {
            value,
            length: value.length
        } : undefined;
    };
}
function createMatchTestFunction(match) {
    return (string)=>{
        const result = match.exec(string);
        if (result) return {
            value: result,
            length: result[0].length
        };
    };
}
const defaultRules = [
    {
        test: createLiteralTestFunction("yyyy"),
        fn: ()=>({
                type: "year",
                value: "numeric"
            })
    },
    {
        test: createLiteralTestFunction("yy"),
        fn: ()=>({
                type: "year",
                value: "2-digit"
            })
    },
    {
        test: createLiteralTestFunction("MM"),
        fn: ()=>({
                type: "month",
                value: "2-digit"
            })
    },
    {
        test: createLiteralTestFunction("M"),
        fn: ()=>({
                type: "month",
                value: "numeric"
            })
    },
    {
        test: createLiteralTestFunction("dd"),
        fn: ()=>({
                type: "day",
                value: "2-digit"
            })
    },
    {
        test: createLiteralTestFunction("d"),
        fn: ()=>({
                type: "day",
                value: "numeric"
            })
    },
    {
        test: createLiteralTestFunction("HH"),
        fn: ()=>({
                type: "hour",
                value: "2-digit"
            })
    },
    {
        test: createLiteralTestFunction("H"),
        fn: ()=>({
                type: "hour",
                value: "numeric"
            })
    },
    {
        test: createLiteralTestFunction("hh"),
        fn: ()=>({
                type: "hour",
                value: "2-digit",
                hour12: true
            })
    },
    {
        test: createLiteralTestFunction("h"),
        fn: ()=>({
                type: "hour",
                value: "numeric",
                hour12: true
            })
    },
    {
        test: createLiteralTestFunction("mm"),
        fn: ()=>({
                type: "minute",
                value: "2-digit"
            })
    },
    {
        test: createLiteralTestFunction("m"),
        fn: ()=>({
                type: "minute",
                value: "numeric"
            })
    },
    {
        test: createLiteralTestFunction("ss"),
        fn: ()=>({
                type: "second",
                value: "2-digit"
            })
    },
    {
        test: createLiteralTestFunction("s"),
        fn: ()=>({
                type: "second",
                value: "numeric"
            })
    },
    {
        test: createLiteralTestFunction("SSS"),
        fn: ()=>({
                type: "fractionalSecond",
                value: 3
            })
    },
    {
        test: createLiteralTestFunction("SS"),
        fn: ()=>({
                type: "fractionalSecond",
                value: 2
            })
    },
    {
        test: createLiteralTestFunction("S"),
        fn: ()=>({
                type: "fractionalSecond",
                value: 1
            })
    },
    {
        test: createLiteralTestFunction("a"),
        fn: (value)=>({
                type: "dayPeriod",
                value: value
            })
    },
    {
        test: createMatchTestFunction(/^(')(?<value>\\.|[^\']*)\1/),
        fn: (match)=>({
                type: "literal",
                value: match.groups.value
            })
    },
    {
        test: createMatchTestFunction(/^.+?\s*/),
        fn: (match)=>({
                type: "literal",
                value: match[0]
            })
    }, 
];
class DateTimeFormatter {
    #format;
    constructor(formatString, rules1 = defaultRules){
        const tokenizer = new Tokenizer(rules1);
        this.#format = tokenizer.tokenize(formatString, ({ type , value , hour12  })=>{
            const result = {
                type,
                value
            };
            if (hour12) result.hour12 = hour12;
            return result;
        });
    }
    format(date, options = {
    }) {
        let string = "";
        const utc = options.timeZone === "UTC";
        for (const token of this.#format){
            const type = token.type;
            switch(type){
                case "year":
                    {
                        const value = utc ? date.getUTCFullYear() : date.getFullYear();
                        switch(token.value){
                            case "numeric":
                                {
                                    string += value;
                                    break;
                                }
                            case "2-digit":
                                {
                                    string += digits(value, 2).slice(-2);
                                    break;
                                }
                            default:
                                throw Error(`FormatterError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "month":
                    {
                        const value = (utc ? date.getUTCMonth() : date.getMonth()) + 1;
                        switch(token.value){
                            case "numeric":
                                {
                                    string += value;
                                    break;
                                }
                            case "2-digit":
                                {
                                    string += digits(value, 2);
                                    break;
                                }
                            default:
                                throw Error(`FormatterError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "day":
                    {
                        const value = utc ? date.getUTCDate() : date.getDate();
                        switch(token.value){
                            case "numeric":
                                {
                                    string += value;
                                    break;
                                }
                            case "2-digit":
                                {
                                    string += digits(value, 2);
                                    break;
                                }
                            default:
                                throw Error(`FormatterError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "hour":
                    {
                        let value = utc ? date.getUTCHours() : date.getHours();
                        value -= token.hour12 && date.getHours() > 12 ? 12 : 0;
                        switch(token.value){
                            case "numeric":
                                {
                                    string += value;
                                    break;
                                }
                            case "2-digit":
                                {
                                    string += digits(value, 2);
                                    break;
                                }
                            default:
                                throw Error(`FormatterError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "minute":
                    {
                        const value = utc ? date.getUTCMinutes() : date.getMinutes();
                        switch(token.value){
                            case "numeric":
                                {
                                    string += value;
                                    break;
                                }
                            case "2-digit":
                                {
                                    string += digits(value, 2);
                                    break;
                                }
                            default:
                                throw Error(`FormatterError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "second":
                    {
                        const value = utc ? date.getUTCSeconds() : date.getSeconds();
                        switch(token.value){
                            case "numeric":
                                {
                                    string += value;
                                    break;
                                }
                            case "2-digit":
                                {
                                    string += digits(value, 2);
                                    break;
                                }
                            default:
                                throw Error(`FormatterError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "fractionalSecond":
                    {
                        const value = utc ? date.getUTCMilliseconds() : date.getMilliseconds();
                        string += digits(value, Number(token.value));
                        break;
                    }
                case "timeZoneName":
                    {
                    }
                case "dayPeriod":
                    {
                        string += token.value ? date.getHours() >= 12 ? "PM" : "AM" : "";
                        break;
                    }
                case "literal":
                    {
                        string += token.value;
                        break;
                    }
                default:
                    throw Error(`FormatterError: { ${token.type} ${token.value} }`);
            }
        }
        return string;
    }
    parseToParts(string) {
        const parts = [];
        for (const token of this.#format){
            const type = token.type;
            let value = "";
            switch(token.type){
                case "year":
                    {
                        switch(token.value){
                            case "numeric":
                                {
                                    value = /^\d{1,4}/.exec(string)?.[0];
                                    break;
                                }
                            case "2-digit":
                                {
                                    value = /^\d{1,2}/.exec(string)?.[0];
                                    break;
                                }
                        }
                        break;
                    }
                case "month":
                    {
                        switch(token.value){
                            case "numeric":
                                {
                                    value = /^\d{1,2}/.exec(string)?.[0];
                                    break;
                                }
                            case "2-digit":
                                {
                                    value = /^\d{2}/.exec(string)?.[0];
                                    break;
                                }
                            case "narrow":
                                {
                                    value = /^[a-zA-Z]+/.exec(string)?.[0];
                                    break;
                                }
                            case "short":
                                {
                                    value = /^[a-zA-Z]+/.exec(string)?.[0];
                                    break;
                                }
                            case "long":
                                {
                                    value = /^[a-zA-Z]+/.exec(string)?.[0];
                                    break;
                                }
                            default:
                                throw Error(`ParserError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "day":
                    {
                        switch(token.value){
                            case "numeric":
                                {
                                    value = /^\d{1,2}/.exec(string)?.[0];
                                    break;
                                }
                            case "2-digit":
                                {
                                    value = /^\d{2}/.exec(string)?.[0];
                                    break;
                                }
                            default:
                                throw Error(`ParserError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "hour":
                    {
                        switch(token.value){
                            case "numeric":
                                {
                                    value = /^\d{1,2}/.exec(string)?.[0];
                                    if (token.hour12 && parseInt(value) > 12) {
                                        console.error(`Trying to parse hour greater than 12. Use 'H' instead of 'h'.`);
                                    }
                                    break;
                                }
                            case "2-digit":
                                {
                                    value = /^\d{2}/.exec(string)?.[0];
                                    if (token.hour12 && parseInt(value) > 12) {
                                        console.error(`Trying to parse hour greater than 12. Use 'HH' instead of 'hh'.`);
                                    }
                                    break;
                                }
                            default:
                                throw Error(`ParserError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "minute":
                    {
                        switch(token.value){
                            case "numeric":
                                {
                                    value = /^\d{1,2}/.exec(string)?.[0];
                                    break;
                                }
                            case "2-digit":
                                {
                                    value = /^\d{2}/.exec(string)?.[0];
                                    break;
                                }
                            default:
                                throw Error(`ParserError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "second":
                    {
                        switch(token.value){
                            case "numeric":
                                {
                                    value = /^\d{1,2}/.exec(string)?.[0];
                                    break;
                                }
                            case "2-digit":
                                {
                                    value = /^\d{2}/.exec(string)?.[0];
                                    break;
                                }
                            default:
                                throw Error(`ParserError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "fractionalSecond":
                    {
                        value = new RegExp(`^\\d{${token.value}}`).exec(string)?.[0];
                        break;
                    }
                case "timeZoneName":
                    {
                        value = token.value;
                        break;
                    }
                case "dayPeriod":
                    {
                        value = /^(A|P)M/.exec(string)?.[0];
                        break;
                    }
                case "literal":
                    {
                        if (!string.startsWith(token.value)) {
                            throw Error(`Literal "${token.value}" not found "${string.slice(0, 25)}"`);
                        }
                        value = token.value;
                        break;
                    }
                default:
                    throw Error(`${token.type} ${token.value}`);
            }
            if (!value) {
                throw Error(`value not valid for token { ${type} ${value} } ${string.slice(0, 25)}`);
            }
            parts.push({
                type,
                value
            });
            string = string.slice(value.length);
        }
        if (string.length) {
            throw Error(`datetime string was not fully parsed! ${string.slice(0, 25)}`);
        }
        return parts;
    }
    partsToDate(parts) {
        const date = new Date();
        const utc = parts.find((part)=>part.type === "timeZoneName" && part.value === "UTC"
        );
        utc ? date.setUTCHours(0, 0, 0, 0) : date.setHours(0, 0, 0, 0);
        for (const part of parts){
            switch(part.type){
                case "year":
                    {
                        const value = Number(part.value.padStart(4, "20"));
                        utc ? date.setUTCFullYear(value) : date.setFullYear(value);
                        break;
                    }
                case "month":
                    {
                        const value = Number(part.value) - 1;
                        utc ? date.setUTCMonth(value) : date.setMonth(value);
                        break;
                    }
                case "day":
                    {
                        const value = Number(part.value);
                        utc ? date.setUTCDate(value) : date.setDate(value);
                        break;
                    }
                case "hour":
                    {
                        let value = Number(part.value);
                        const dayPeriod = parts.find((part1)=>part1.type === "dayPeriod"
                        );
                        if (dayPeriod?.value === "PM") value += 12;
                        utc ? date.setUTCHours(value) : date.setHours(value);
                        break;
                    }
                case "minute":
                    {
                        const value = Number(part.value);
                        utc ? date.setUTCMinutes(value) : date.setMinutes(value);
                        break;
                    }
                case "second":
                    {
                        const value = Number(part.value);
                        utc ? date.setUTCSeconds(value) : date.setSeconds(value);
                        break;
                    }
                case "fractionalSecond":
                    {
                        const value = Number(part.value);
                        utc ? date.setUTCMilliseconds(value) : date.setMilliseconds(value);
                        break;
                    }
            }
        }
        return date;
    }
    parse(string) {
        const parts = this.parseToParts(string);
        return this.partsToDate(parts);
    }
}
var Day;
(function(Day1) {
    Day1[Day1["Sun"] = 0] = "Sun";
    Day1[Day1["Mon"] = 1] = "Mon";
    Day1[Day1["Tue"] = 2] = "Tue";
    Day1[Day1["Wed"] = 3] = "Wed";
    Day1[Day1["Thu"] = 4] = "Thu";
    Day1[Day1["Fri"] = 5] = "Fri";
    Day1[Day1["Sat"] = 6] = "Sat";
})(Day || (Day = {
}));
function toIMF(date) {
    function dtPad(v, lPad = 2) {
        return v.padStart(lPad, "0");
    }
    const d = dtPad(date.getUTCDate().toString());
    const h = dtPad(date.getUTCHours().toString());
    const min = dtPad(date.getUTCMinutes().toString());
    const s = dtPad(date.getUTCSeconds().toString());
    const y = date.getUTCFullYear();
    const days = [
        "Sun",
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat"
    ];
    const months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec", 
    ];
    return `${days[date.getUTCDay()]}, ${d} ${months[date.getUTCMonth()]} ${y} ${h}:${min}:${s} GMT`;
}
function toString(cookie) {
    if (!cookie.name) {
        return "";
    }
    const out = [];
    out.push(`${cookie.name}=${cookie.value}`);
    if (cookie.name.startsWith("__Secure")) {
        cookie.secure = true;
    }
    if (cookie.name.startsWith("__Host")) {
        cookie.path = "/";
        cookie.secure = true;
        delete cookie.domain;
    }
    if (cookie.secure) {
        out.push("Secure");
    }
    if (cookie.httpOnly) {
        out.push("HttpOnly");
    }
    if (typeof cookie.maxAge === "number" && Number.isInteger(cookie.maxAge)) {
        assert(cookie.maxAge > 0, "Max-Age must be an integer superior to 0");
        out.push(`Max-Age=${cookie.maxAge}`);
    }
    if (cookie.domain) {
        out.push(`Domain=${cookie.domain}`);
    }
    if (cookie.sameSite) {
        out.push(`SameSite=${cookie.sameSite}`);
    }
    if (cookie.path) {
        out.push(`Path=${cookie.path}`);
    }
    if (cookie.expires) {
        const dateString = toIMF(cookie.expires);
        out.push(`Expires=${dateString}`);
    }
    if (cookie.unparsed) {
        out.push(cookie.unparsed.join("; "));
    }
    return out.join("; ");
}
function setCookie(res, cookie) {
    if (!res.headers) {
        res.headers = new Headers();
    }
    const v = toString(cookie);
    if (v) {
        res.headers.append("Set-Cookie", v);
    }
}
const CHAR_FORWARD_SLASH = 47;
let NATIVE_OS = "linux";
const navigator = globalThis.navigator;
if (globalThis.Deno != null) {
    NATIVE_OS = Deno.build.os;
} else if (navigator?.appVersion?.includes?.("Win") ?? false) {
    NATIVE_OS = "windows";
}
const isWindows = NATIVE_OS == "windows";
function assertPath(path) {
    if (typeof path !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
    }
}
function isPosixPathSeparator(code) {
    return code === 47;
}
function isPathSeparator(code) {
    return isPosixPathSeparator(code) || code === 92;
}
function isWindowsDeviceRoot(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString(path, allowAboveRoot, separator, isPathSeparator1) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i3 = 0, len = path.length; i3 <= len; ++i3){
        if (i3 < len) code = path.charCodeAt(i3);
        else if (isPathSeparator1(code)) break;
        else code = CHAR_FORWARD_SLASH;
        if (isPathSeparator1(code)) {
            if (lastSlash === i3 - 1 || dots === 1) {
            } else if (lastSlash !== i3 - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i3;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i3;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i3);
                else res = path.slice(lastSlash + 1, i3);
                lastSegmentLength = i3 - lastSlash - 1;
            }
            lastSlash = i3;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format(sep, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
const sep = "\\";
const delimiter = ";";
function resolve(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i3 = pathSegments.length - 1; i3 >= -1; i3--){
        let path;
        if (i3 >= 0) {
            path = pathSegments[i3];
        } else if (!resolvedDevice) {
            if (globalThis.Deno == null) {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path = Deno.cwd();
        } else {
            if (globalThis.Deno == null) {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno.env.get(`=${resolvedDevice}`) || Deno.cwd();
            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path = `${resolvedDevice}\\`;
            }
        }
        assertPath(path);
        const len = path.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator(code)) {
                isAbsolute = true;
                if (isPathSeparator(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator(path.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot(code)) {
                if (path.charCodeAt(1) === 58) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator(code)) {
            rootEnd = 1;
            isAbsolute = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize12(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            isAbsolute = true;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) {
                        isAbsolute = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute) tail = ".";
    if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return false;
    const code = path.charCodeAt(0);
    if (isPathSeparator(code)) {
        return true;
    } else if (isWindowsDeviceRoot(code)) {
        if (len > 2 && path.charCodeAt(1) === 58) {
            if (isPathSeparator(path.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i3 = 0; i3 < pathsCount; ++i3){
        const path = paths[i3];
        assertPath(path);
        if (path.length > 0) {
            if (joined === undefined) joined = firstPart = path;
            else joined += `\\${path}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert(firstPart != null);
    if (isPathSeparator(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize12(joined);
}
function relative(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    const fromOrig = resolve(from);
    const toOrig = resolve(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i3 = 0;
    for(; i3 <= length; ++i3){
        if (i3 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i3) === 92) {
                    return toOrig.slice(toStart + i3 + 1);
                } else if (i3 === 2) {
                    return toOrig.slice(toStart + i3);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i3) === 92) {
                    lastCommonSep = i3;
                } else if (i3 === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i3);
        const toCode = to.charCodeAt(toStart + i3);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i3;
    }
    if (i3 !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i3 = fromStart + lastCommonSep + 1; i3 <= fromEnd; ++i3){
        if (i3 === fromEnd || from.charCodeAt(i3) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath(path) {
    if (typeof path !== "string") return path;
    if (path.length === 0) return "";
    const resolvedPath = resolve(path);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path;
}
function dirname(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return path;
    }
    for(let i3 = len - 1; i3 >= offset; --i3){
        if (isPathSeparator(path.charCodeAt(i3))) {
            if (!matchedSlash) {
                end = i3;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path.slice(0, end);
}
function basename(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i3;
    if (path.length >= 2) {
        const drive = path.charCodeAt(0);
        if (isWindowsDeviceRoot(drive)) {
            if (path.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i3 = path.length - 1; i3 >= start; --i3){
            const code = path.charCodeAt(i3);
            if (isPathSeparator(code)) {
                if (!matchedSlash) {
                    start = i3 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i3 + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if ((--extIdx) === -1) {
                            end = i3;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i3 = path.length - 1; i3 >= start; --i3){
            if (isPathSeparator(path.charCodeAt(i3))) {
                if (!matchedSlash) {
                    start = i3 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i3 + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname(path) {
    assertPath(path);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot(path.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i3 = path.length - 1; i3 >= start; --i3){
        const code = path.charCodeAt(i3);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i3 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i3 + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i3;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format("\\", pathObject);
}
function parse14(path) {
    assertPath(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path;
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        ret.root = ret.dir = path;
        return ret;
    }
    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i3 = path.length - 1;
    let preDotState = 0;
    for(; i3 >= rootEnd; --i3){
        code = path.charCodeAt(i3);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i3 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i3 + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i3;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path.slice(startPart, end);
        }
    } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path = decodeURIComponent(url.pathname.replace(/^\/*([A-Za-z]:)(\/|$)/, "$1/").replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
    if (url.hostname != "") {
        path = `\\\\${url.hostname}${path}`;
    }
    return path;
}
const mod = function() {
    return {
        sep: sep,
        delimiter: delimiter,
        resolve: resolve,
        normalize: normalize12,
        isAbsolute: isAbsolute,
        join: join,
        relative: relative,
        toNamespacedPath: toNamespacedPath,
        dirname: dirname,
        basename: basename,
        extname: extname,
        format: format,
        parse: parse14,
        fromFileUrl: fromFileUrl
    };
}();
const sep1 = "/";
const delimiter1 = ":";
function resolve1(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i3 = pathSegments.length - 1; i3 >= -1 && !resolvedAbsolute; i3--){
        let path;
        if (i3 >= 0) path = pathSegments[i3];
        else {
            if (globalThis.Deno == null) {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno.cwd();
        }
        assertPath(path);
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    }
    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize1(path) {
    assertPath(path);
    if (path.length === 0) return ".";
    const isAbsolute1 = path.charCodeAt(0) === 47;
    const trailingSeparator = path.charCodeAt(path.length - 1) === 47;
    path = normalizeString(path, !isAbsolute1, "/", isPosixPathSeparator);
    if (path.length === 0 && !isAbsolute1) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute1) return `/${path}`;
    return path;
}
function isAbsolute1(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47;
}
function join1(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i3 = 0, len = paths.length; i3 < len; ++i3){
        const path = paths[i3];
        assertPath(path);
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `/${path}`;
        }
    }
    if (!joined) return ".";
    return normalize1(joined);
}
function relative1(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    from = resolve1(from);
    to = resolve1(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i3 = 0;
    for(; i3 <= length; ++i3){
        if (i3 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i3) === 47) {
                    return to.slice(toStart + i3 + 1);
                } else if (i3 === 0) {
                    return to.slice(toStart + i3);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i3) === 47) {
                    lastCommonSep = i3;
                } else if (i3 === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i3);
        const toCode = to.charCodeAt(toStart + i3);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i3;
    }
    let out = "";
    for(i3 = fromStart + lastCommonSep + 1; i3 <= fromEnd; ++i3){
        if (i3 === fromEnd || from.charCodeAt(i3) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath1(path) {
    return path;
}
function dirname1(path) {
    assertPath(path);
    if (path.length === 0) return ".";
    const hasRoot = path.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i3 = path.length - 1; i3 >= 1; --i3){
        if (path.charCodeAt(i3) === 47) {
            if (!matchedSlash) {
                end = i3;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path.slice(0, end);
}
function basename1(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i3;
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i3 = path.length - 1; i3 >= 0; --i3){
            const code = path.charCodeAt(i3);
            if (code === 47) {
                if (!matchedSlash) {
                    start = i3 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i3 + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if ((--extIdx) === -1) {
                            end = i3;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i3 = path.length - 1; i3 >= 0; --i3){
            if (path.charCodeAt(i3) === 47) {
                if (!matchedSlash) {
                    start = i3 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i3 + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname1(path) {
    assertPath(path);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i3 = path.length - 1; i3 >= 0; --i3){
        const code = path.charCodeAt(i3);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i3 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i3 + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i3;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format1(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format("/", pathObject);
}
function parse1(path) {
    assertPath(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path.length === 0) return ret;
    const isAbsolute2 = path.charCodeAt(0) === 47;
    let start;
    if (isAbsolute2) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i3 = path.length - 1;
    let preDotState = 0;
    for(; i3 >= start; --i3){
        const code = path.charCodeAt(i3);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i3 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i3 + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i3;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute2) {
                ret.base = ret.name = path.slice(1, end);
            } else {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute2) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
        } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
    else if (isAbsolute2) ret.dir = "/";
    return ret;
}
function fromFileUrl1(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
const mod1 = function() {
    return {
        sep: sep1,
        delimiter: delimiter1,
        resolve: resolve1,
        normalize: normalize1,
        isAbsolute: isAbsolute1,
        join: join1,
        relative: relative1,
        toNamespacedPath: toNamespacedPath1,
        dirname: dirname1,
        basename: basename1,
        extname: extname1,
        format: format1,
        parse: parse1,
        fromFileUrl: fromFileUrl1
    };
}();
const path6 = isWindows ? mod : mod1;
const { basename: basename2 , delimiter: delimiter2 , dirname: dirname2 , extname: extname2 , format: format2 , fromFileUrl: fromFileUrl2 , isAbsolute: isAbsolute2 , join: join2 , normalize: normalize2 , parse: parse2 , relative: relative2 , resolve: resolve2 , sep: sep2 , toNamespacedPath: toNamespacedPath2 ,  } = path6;
const setImmediate = (cb, ...args)=>window.setTimeout(cb, 0, ...args)
;
const hexTable = new Array(256);
for(let i3 = 0; i3 < 256; ++i3){
    hexTable[i3] = "%" + ((i3 < 16 ? "0" : "") + i3.toString(16)).toUpperCase();
}
function parse3(str1, sep3 = "&", eq = "=", { decodeURIComponent =unescape1 , maxKeys =1000  } = {
}) {
    const entries = str1.split(sep3).map((entry)=>entry.split(eq).map(decodeURIComponent)
    );
    const __final = {
    };
    let i4 = 0;
    while(true){
        if (Object.keys(__final).length === maxKeys && !!maxKeys || !entries[i4]) {
            break;
        }
        const [key, val] = entries[i4];
        if (__final[key]) {
            if (Array.isArray(__final[key])) {
                __final[key].push(val);
            } else {
                __final[key] = [
                    __final[key],
                    val
                ];
            }
        } else {
            __final[key] = val;
        }
        i4++;
    }
    return __final;
}
const unescape1 = decodeURIComponent;
const HEX_CHARS = "0123456789abcdef".split("");
const EXTRA = [
    -2147483648,
    8388608,
    32768,
    128
];
const SHIFT = [
    24,
    16,
    8,
    0
];
const blocks = [];
class Sha1 {
    #blocks;
    #block;
    #start;
    #bytes;
    #hBytes;
    #finalized;
    #hashed;
    #h0=1732584193;
    #h1=4023233417;
    #h2=2562383102;
    #h3=271733878;
    #h4=3285377520;
    #lastByteIndex=0;
    constructor(sharedMemory = false){
        if (sharedMemory) {
            blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
            this.#blocks = blocks;
        } else {
            this.#blocks = [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ];
        }
        this.#h0 = 1732584193;
        this.#h1 = 4023233417;
        this.#h2 = 2562383102;
        this.#h3 = 271733878;
        this.#h4 = 3285377520;
        this.#block = this.#start = this.#bytes = this.#hBytes = 0;
        this.#finalized = this.#hashed = false;
    }
    update(message) {
        if (this.#finalized) {
            return this;
        }
        let msg;
        if (message instanceof ArrayBuffer) {
            msg = new Uint8Array(message);
        } else {
            msg = message;
        }
        let index = 0;
        const length = msg.length;
        const blocks1 = this.#blocks;
        while(index < length){
            let i4;
            if (this.#hashed) {
                this.#hashed = false;
                blocks1[0] = this.#block;
                blocks1[16] = blocks1[1] = blocks1[2] = blocks1[3] = blocks1[4] = blocks1[5] = blocks1[6] = blocks1[7] = blocks1[8] = blocks1[9] = blocks1[10] = blocks1[11] = blocks1[12] = blocks1[13] = blocks1[14] = blocks1[15] = 0;
            }
            if (typeof msg !== "string") {
                for(i4 = this.#start; index < length && i4 < 64; ++index){
                    blocks1[i4 >> 2] |= msg[index] << SHIFT[(i4++) & 3];
                }
            } else {
                for(i4 = this.#start; index < length && i4 < 64; ++index){
                    let code = msg.charCodeAt(index);
                    if (code < 128) {
                        blocks1[i4 >> 2] |= code << SHIFT[(i4++) & 3];
                    } else if (code < 2048) {
                        blocks1[i4 >> 2] |= (192 | code >> 6) << SHIFT[(i4++) & 3];
                        blocks1[i4 >> 2] |= (128 | code & 63) << SHIFT[(i4++) & 3];
                    } else if (code < 55296 || code >= 57344) {
                        blocks1[i4 >> 2] |= (224 | code >> 12) << SHIFT[(i4++) & 3];
                        blocks1[i4 >> 2] |= (128 | code >> 6 & 63) << SHIFT[(i4++) & 3];
                        blocks1[i4 >> 2] |= (128 | code & 63) << SHIFT[(i4++) & 3];
                    } else {
                        code = 65536 + ((code & 1023) << 10 | msg.charCodeAt(++index) & 1023);
                        blocks1[i4 >> 2] |= (240 | code >> 18) << SHIFT[(i4++) & 3];
                        blocks1[i4 >> 2] |= (128 | code >> 12 & 63) << SHIFT[(i4++) & 3];
                        blocks1[i4 >> 2] |= (128 | code >> 6 & 63) << SHIFT[(i4++) & 3];
                        blocks1[i4 >> 2] |= (128 | code & 63) << SHIFT[(i4++) & 3];
                    }
                }
            }
            this.#lastByteIndex = i4;
            this.#bytes += i4 - this.#start;
            if (i4 >= 64) {
                this.#block = blocks1[16];
                this.#start = i4 - 64;
                this.hash();
                this.#hashed = true;
            } else {
                this.#start = i4;
            }
        }
        if (this.#bytes > 4294967295) {
            this.#hBytes += this.#bytes / 4294967296 >>> 0;
            this.#bytes = this.#bytes >>> 0;
        }
        return this;
    }
    finalize() {
        if (this.#finalized) {
            return;
        }
        this.#finalized = true;
        const blocks1 = this.#blocks;
        const i4 = this.#lastByteIndex;
        blocks1[16] = this.#block;
        blocks1[i4 >> 2] |= EXTRA[i4 & 3];
        this.#block = blocks1[16];
        if (i4 >= 56) {
            if (!this.#hashed) {
                this.hash();
            }
            blocks1[0] = this.#block;
            blocks1[16] = blocks1[1] = blocks1[2] = blocks1[3] = blocks1[4] = blocks1[5] = blocks1[6] = blocks1[7] = blocks1[8] = blocks1[9] = blocks1[10] = blocks1[11] = blocks1[12] = blocks1[13] = blocks1[14] = blocks1[15] = 0;
        }
        blocks1[14] = this.#hBytes << 3 | this.#bytes >>> 29;
        blocks1[15] = this.#bytes << 3;
        this.hash();
    }
    hash() {
        let a = this.#h0;
        let b = this.#h1;
        let c = this.#h2;
        let d = this.#h3;
        let e = this.#h4;
        let f;
        let j;
        let t;
        const blocks1 = this.#blocks;
        for(j = 16; j < 80; ++j){
            t = blocks1[j - 3] ^ blocks1[j - 8] ^ blocks1[j - 14] ^ blocks1[j - 16];
            blocks1[j] = t << 1 | t >>> 31;
        }
        for(j = 0; j < 20; j += 5){
            f = b & c | ~b & d;
            t = a << 5 | a >>> 27;
            e = t + f + e + 1518500249 + blocks1[j] >>> 0;
            b = b << 30 | b >>> 2;
            f = a & b | ~a & c;
            t = e << 5 | e >>> 27;
            d = t + f + d + 1518500249 + blocks1[j + 1] >>> 0;
            a = a << 30 | a >>> 2;
            f = e & a | ~e & b;
            t = d << 5 | d >>> 27;
            c = t + f + c + 1518500249 + blocks1[j + 2] >>> 0;
            e = e << 30 | e >>> 2;
            f = d & e | ~d & a;
            t = c << 5 | c >>> 27;
            b = t + f + b + 1518500249 + blocks1[j + 3] >>> 0;
            d = d << 30 | d >>> 2;
            f = c & d | ~c & e;
            t = b << 5 | b >>> 27;
            a = t + f + a + 1518500249 + blocks1[j + 4] >>> 0;
            c = c << 30 | c >>> 2;
        }
        for(; j < 40; j += 5){
            f = b ^ c ^ d;
            t = a << 5 | a >>> 27;
            e = t + f + e + 1859775393 + blocks1[j] >>> 0;
            b = b << 30 | b >>> 2;
            f = a ^ b ^ c;
            t = e << 5 | e >>> 27;
            d = t + f + d + 1859775393 + blocks1[j + 1] >>> 0;
            a = a << 30 | a >>> 2;
            f = e ^ a ^ b;
            t = d << 5 | d >>> 27;
            c = t + f + c + 1859775393 + blocks1[j + 2] >>> 0;
            e = e << 30 | e >>> 2;
            f = d ^ e ^ a;
            t = c << 5 | c >>> 27;
            b = t + f + b + 1859775393 + blocks1[j + 3] >>> 0;
            d = d << 30 | d >>> 2;
            f = c ^ d ^ e;
            t = b << 5 | b >>> 27;
            a = t + f + a + 1859775393 + blocks1[j + 4] >>> 0;
            c = c << 30 | c >>> 2;
        }
        for(; j < 60; j += 5){
            f = b & c | b & d | c & d;
            t = a << 5 | a >>> 27;
            e = t + f + e - 1894007588 + blocks1[j] >>> 0;
            b = b << 30 | b >>> 2;
            f = a & b | a & c | b & c;
            t = e << 5 | e >>> 27;
            d = t + f + d - 1894007588 + blocks1[j + 1] >>> 0;
            a = a << 30 | a >>> 2;
            f = e & a | e & b | a & b;
            t = d << 5 | d >>> 27;
            c = t + f + c - 1894007588 + blocks1[j + 2] >>> 0;
            e = e << 30 | e >>> 2;
            f = d & e | d & a | e & a;
            t = c << 5 | c >>> 27;
            b = t + f + b - 1894007588 + blocks1[j + 3] >>> 0;
            d = d << 30 | d >>> 2;
            f = c & d | c & e | d & e;
            t = b << 5 | b >>> 27;
            a = t + f + a - 1894007588 + blocks1[j + 4] >>> 0;
            c = c << 30 | c >>> 2;
        }
        for(; j < 80; j += 5){
            f = b ^ c ^ d;
            t = a << 5 | a >>> 27;
            e = t + f + e - 899497514 + blocks1[j] >>> 0;
            b = b << 30 | b >>> 2;
            f = a ^ b ^ c;
            t = e << 5 | e >>> 27;
            d = t + f + d - 899497514 + blocks1[j + 1] >>> 0;
            a = a << 30 | a >>> 2;
            f = e ^ a ^ b;
            t = d << 5 | d >>> 27;
            c = t + f + c - 899497514 + blocks1[j + 2] >>> 0;
            e = e << 30 | e >>> 2;
            f = d ^ e ^ a;
            t = c << 5 | c >>> 27;
            b = t + f + b - 899497514 + blocks1[j + 3] >>> 0;
            d = d << 30 | d >>> 2;
            f = c ^ d ^ e;
            t = b << 5 | b >>> 27;
            a = t + f + a - 899497514 + blocks1[j + 4] >>> 0;
            c = c << 30 | c >>> 2;
        }
        this.#h0 = this.#h0 + a >>> 0;
        this.#h1 = this.#h1 + b >>> 0;
        this.#h2 = this.#h2 + c >>> 0;
        this.#h3 = this.#h3 + d >>> 0;
        this.#h4 = this.#h4 + e >>> 0;
    }
    hex() {
        this.finalize();
        const h0 = this.#h0;
        const h1 = this.#h1;
        const h2 = this.#h2;
        const h3 = this.#h3;
        const h4 = this.#h4;
        return HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15];
    }
    toString() {
        return this.hex();
    }
    digest() {
        this.finalize();
        const h0 = this.#h0;
        const h1 = this.#h1;
        const h2 = this.#h2;
        const h3 = this.#h3;
        const h4 = this.#h4;
        return [
            h0 >> 24 & 255,
            h0 >> 16 & 255,
            h0 >> 8 & 255,
            h0 & 255,
            h1 >> 24 & 255,
            h1 >> 16 & 255,
            h1 >> 8 & 255,
            h1 & 255,
            h2 >> 24 & 255,
            h2 >> 16 & 255,
            h2 >> 8 & 255,
            h2 & 255,
            h3 >> 24 & 255,
            h3 >> 16 & 255,
            h3 >> 8 & 255,
            h3 & 255,
            h4 >> 24 & 255,
            h4 >> 16 & 255,
            h4 >> 8 & 255,
            h4 & 255, 
        ];
    }
    array() {
        return this.digest();
    }
    arrayBuffer() {
        this.finalize();
        const buffer = new ArrayBuffer(20);
        const dataView = new DataView(buffer);
        dataView.setUint32(0, this.#h0);
        dataView.setUint32(4, this.#h1);
        dataView.setUint32(8, this.#h2);
        dataView.setUint32(12, this.#h3);
        dataView.setUint32(16, this.#h4);
        return buffer;
    }
}
function typeGuard(o, isMatched = true) {
    o;
    return isMatched;
}
var CtxLike;
(function(CtxLike1) {
    function match(o) {
        return typeGuard(o) && o instanceof Object && typeof o.done === "function" && typeof o.abort === "function" && typeof o.zz__addHandler === "function" && typeof o.zz__removeHandler === "function";
    }
    CtxLike1.match = match;
})(CtxLike || (CtxLike = {
}));
function assert1(condition, msg) {
    if (!condition) {
        throw new Error(msg);
    }
}
const id = (x)=>x
;
var EventTargetLike;
(function(EventTargetLike1) {
    var RxJSSubject;
    (function(RxJSSubject1) {
        function match(eventTarget) {
            return typeGuard(eventTarget) && eventTarget instanceof Object && typeof eventTarget.subscribe === "function";
        }
        RxJSSubject1.match = match;
    })(RxJSSubject || (RxJSSubject = {
    }));
    var NodeStyleEventEmitter;
    (function(NodeStyleEventEmitter1) {
        function match(eventTarget) {
            return typeGuard(eventTarget) && eventTarget instanceof Object && typeof eventTarget.addListener === "function" && typeof eventTarget.removeListener === "function";
        }
        NodeStyleEventEmitter1.match = match;
    })(NodeStyleEventEmitter || (NodeStyleEventEmitter = {
    }));
    var JQueryStyleEventEmitter;
    (function(JQueryStyleEventEmitter1) {
        function match(eventTarget) {
            return typeGuard(eventTarget) && eventTarget instanceof Object && typeof eventTarget.on === "function" && typeof eventTarget.off === "function";
        }
        JQueryStyleEventEmitter1.match = match;
    })(JQueryStyleEventEmitter || (JQueryStyleEventEmitter = {
    }));
    var HasEventTargetAddRemove;
    (function(HasEventTargetAddRemove1) {
        function match(eventTarget) {
            return typeGuard(eventTarget) && eventTarget instanceof Object && typeof eventTarget.addEventListener === "function" && typeof eventTarget.removeEventListener === "function";
        }
        HasEventTargetAddRemove1.match = match;
    })(HasEventTargetAddRemove || (HasEventTargetAddRemove = {
    }));
    function canBe(o) {
        try {
            return HasEventTargetAddRemove.match(o) || NodeStyleEventEmitter.match(o) || JQueryStyleEventEmitter.match(o) || RxJSSubject.match(o);
        } catch  {
            return false;
        }
    }
    EventTargetLike1.canBe = canBe;
    EventTargetLike1.RxJSSubject = RxJSSubject, EventTargetLike1.NodeStyleEventEmitter = NodeStyleEventEmitter, EventTargetLike1.JQueryStyleEventEmitter = JQueryStyleEventEmitter, EventTargetLike1.HasEventTargetAddRemove = HasEventTargetAddRemove;
})(EventTargetLike || (EventTargetLike = {
}));
var EvtError;
(function(EvtError1) {
    class Timeout extends Error {
        constructor(timeout){
            super(`Evt timeout after ${timeout}ms`);
            this.timeout = timeout;
            Object.setPrototypeOf(this, new.target.prototype);
        }
    }
    EvtError1.Timeout = Timeout;
    class Detached extends Error {
        constructor(){
            super(`Evt handler detached`);
            Object.setPrototypeOf(this, new.target.prototype);
        }
    }
    EvtError1.Detached = Detached;
})(EvtError || (EvtError = {
}));
var Operator;
(function(Operator1) {
    var f;
    (function(f1) {
        var Stateful;
        (function(Stateful1) {
            function match(op) {
                return typeof op !== "function";
            }
            Stateful1.match = match;
        })(Stateful || (Stateful = {
        }));
        var Result;
        (function(Result1) {
            function match(result) {
                return Matched.match(result) || NotMatched.match(result);
            }
            Result1.match = match;
            function getDetachArg(result) {
                const detach = Matched.match(result) ? result[1] : result;
                if (Detach.FromEvt.match(detach)) {
                    return true;
                }
                if (Detach.WithCtxArg.match(detach)) {
                    return [
                        detach.DETACH,
                        detach.err,
                        detach.res
                    ];
                }
                return false;
            }
            Result1.getDetachArg = getDetachArg;
            var NotMatched;
            (function(NotMatched1) {
                function match1(result) {
                    return result === null || Detach.match(result);
                }
                NotMatched1.match = match1;
            })(NotMatched || (NotMatched = {
            }));
            var Matched;
            (function(Matched1) {
                function match1(result) {
                    return typeGuard(result) && result instanceof Object && !("input" in result) && (result.length === 1 || result.length === 2 && (result[1] === null || Detach.match(result[1])));
                }
                Matched1.match = match1;
            })(Matched || (Matched = {
            }));
            var Detach;
            (function(Detach1) {
                var FromEvt;
                (function(FromEvt1) {
                    function match1(detach) {
                        return detach === "DETACH";
                    }
                    FromEvt1.match = match1;
                })(FromEvt || (FromEvt = {
                }));
                var WithCtxArg;
                (function(WithCtxArg1) {
                    function match1(detach) {
                        return typeGuard(detach) && detach instanceof Object && detach.DETACH instanceof Object;
                    }
                    WithCtxArg1.match = match1;
                })(WithCtxArg || (WithCtxArg = {
                }));
                function match1(detach) {
                    return FromEvt.match(detach) || WithCtxArg.match(detach);
                }
                Detach1.match = match1;
                Detach1.FromEvt = FromEvt, Detach1.WithCtxArg = WithCtxArg;
            })(Detach || (Detach = {
            }));
            Result1.NotMatched = NotMatched, Result1.Matched = Matched, Result1.Detach = Detach;
        })(Result || (Result = {
        }));
        f1.Stateful = Stateful, f1.Result = Result;
    })(f || (f = {
    }));
    Operator1.f = f;
})(Operator || (Operator = {
}));
function encapsulateOpState(statefulFOp) {
    let state = statefulFOp[1];
    return id((...[data, , cbInvokedIfMatched])=>{
        const opResult = statefulFOp[0](data, state, cbInvokedIfMatched);
        if (!!cbInvokedIfMatched && Operator.f.Result.Matched.match(opResult)) {
            state = opResult[0];
        }
        return opResult;
    });
}
function invokeOperator(op, data, isPost) {
    const result = op(data, undefined, isPost);
    return Operator.f.Result.match(result) ? result : !!result ? [
        data
    ] : null;
}
function f_o_g(op1, op2) {
    const opAtoB = Operator.f.Stateful.match(op1) ? encapsulateOpState(op1) : id(op1);
    const opBtoC = Operator.f.Stateful.match(op2) ? encapsulateOpState(op2) : id(op2);
    return id((...[dataA, , isPost])=>{
        const resultB = invokeOperator(opAtoB, dataA, isPost);
        if (Operator.f.Result.NotMatched.match(resultB)) {
            assert1(typeGuard(resultB));
            return resultB;
        }
        const detachOp1 = !!resultB[1] ? resultB[1] : null;
        assert1(typeGuard(detachOp1));
        const [dataB] = resultB;
        const resultC = invokeOperator(opBtoC, dataB, isPost);
        if (Operator.f.Result.NotMatched.match(resultC)) {
            assert1(typeGuard(resultC));
            return detachOp1 !== null ? detachOp1 : resultC;
        }
        return id([
            resultC[0],
            !!detachOp1 ? detachOp1 : !!resultC[1] ? resultC[1] : null
        ]);
    });
}
function compose(...ops) {
    if (ops.length === 1) {
        const [op] = ops;
        return Operator.f.Stateful.match(op) ? encapsulateOpState(op) : op;
    }
    const [op1, op2, ...rest] = ops;
    const op1_o_op2 = f_o_g(op1, op2);
    if (rest.length === 0) {
        return op1_o_op2;
    }
    return compose(op1_o_op2, ...rest);
}
const throttleTime = (duration)=>compose([
        (data, { lastClick  })=>{
            const now = Date.now();
            return now - lastClick < duration ? null : [
                {
                    data,
                    "lastClick": now
                }
            ];
        },
        {
            "lastClick": 0,
            "data": null
        }
    ], ({ data  })=>[
            data
        ]
    )
;
class LightMapImpl {
    record = [];
    constructor(){
    }
    has(key) {
        return this.record.map(([_key])=>_key
        ).indexOf(key) >= 0;
    }
    get(key) {
        const [entry] = this.record.filter(([_key])=>_key === key
        );
        if (entry === undefined) {
            return undefined;
        }
        return entry[1];
    }
    set(key, value) {
        const [entry] = this.record.filter(([_key])=>_key === key
        );
        if (entry === undefined) {
            this.record.push([
                key,
                value
            ]);
        } else {
            entry[1] = value;
        }
        return this;
    }
    delete(key) {
        const index = this.record.map(([key])=>key
        ).indexOf(key);
        if (index < 0) {
            return false;
        }
        this.record.splice(index, 1);
        return true;
    }
    keys() {
        return this.record.map(([key])=>key
        );
    }
}
const Polyfill = typeof Map !== "undefined" ? Map : LightMapImpl;
class LightSetImpl {
    map = new Polyfill();
    constructor(values){
        if (values === undefined) {
            return;
        }
        for (let value1 of values){
            this.add(value1);
        }
    }
    has(value) {
        return this.map.has(value);
    }
    add(value) {
        this.map.set(value, true);
        return this;
    }
    values() {
        return this.map.keys();
    }
    delete(value) {
        return this.map.delete(value);
    }
}
const Polyfill1 = typeof Set !== "undefined" ? Set : LightSetImpl;
const Polyfill2 = typeof WeakMap !== "undefined" ? WeakMap : Polyfill;
const overwriteReadonlyProp = (obj, propertyName, value2)=>{
    try {
        obj[propertyName] = value2;
    } catch  {
    }
    if (obj[propertyName] === value2) {
        return value2;
    }
    let errorDefineProperty = undefined;
    const propertyDescriptor = Object.getOwnPropertyDescriptor(obj, propertyName) || {
        "enumerable": true,
        "configurable": true
    };
    if (!!propertyDescriptor.get) {
        throw new Error(`Probably a wrong ides to overwrite ${propertyName} getter`);
    }
    try {
        Object.defineProperty(obj, propertyName, {
            ...propertyDescriptor,
            value: value2
        });
    } catch (error) {
        errorDefineProperty = error;
    }
    if (obj[propertyName] !== value2) {
        throw errorDefineProperty || new Error("Can't assign");
    }
    return value2;
};
const importProxy = {
};
const defineAccessors = (obj, propertyName, propertyDescriptor)=>{
    const { get , set  } = propertyDescriptor;
    Object.defineProperty(obj, propertyName, {
        ...Object.getOwnPropertyDescriptor(obj, propertyName) || {
            "enumerable": true,
            "configurable": true
        },
        ...get !== undefined ? {
            "get": function() {
                return get.call(this);
            }
        } : {
        },
        ...set !== undefined ? {
            "set": function(value2) {
                set.call(this, value2);
            }
        } : {
        }
    });
};
class LazyEvt {
    initialPostCount = 0;
    static __1 = (()=>{
        if (false) {
            LazyEvt.__1;
        }
        defineAccessors(LazyEvt.prototype, "evt", {
            "get": function() {
                if (this.__evt === undefined) {
                    this.__evt = new importProxy.Evt();
                    overwriteReadonlyProp(this.__evt, "postCount", this.initialPostCount);
                }
                return this.__evt;
            }
        });
    })();
    post(data) {
        if (this.__evt === undefined) {
            return ++this.initialPostCount;
        }
        return this.__evt.post(data);
    }
}
class CtxImpl {
    lazyEvtAttach = new LazyEvt();
    lazyEvtDetach = new LazyEvt();
    lazyEvtDoneOrAborted = new LazyEvt();
    onDoneOrAborted(doneEvtData) {
        this.lazyEvtDoneOrAborted.post(doneEvtData);
    }
    static __1 = (()=>{
        if (false) {
            CtxImpl.__1;
        }
        defineAccessors(CtxImpl.prototype, "evtDoneOrAborted", {
            "get": function() {
                return this.lazyEvtDoneOrAborted.evt;
            }
        });
        defineAccessors(CtxImpl.prototype, "evtAttach", {
            "get": function() {
                return this.lazyEvtAttach.evt;
            }
        });
        defineAccessors(CtxImpl.prototype, "evtDetach", {
            "get": function() {
                return this.lazyEvtDetach.evt;
            }
        });
    })();
    waitFor(timeout) {
        return this.evtDoneOrAborted.waitFor(timeout).then((data)=>{
            if (data.type === "ABORTED") {
                throw data.error;
            }
            return data.result;
        }, (timeoutError)=>{
            this.abort(timeoutError);
            throw timeoutError;
        });
    }
    abort(error) {
        return this.__done(error);
    }
    done(result) {
        return this.__done(undefined, result);
    }
    __done(error, result) {
        const handlers = [];
        for (const handler of this.handlers.values()){
            const evt = this.evtByHandler.get(handler);
            const wasStillAttached = handler.detach();
            if (!wasStillAttached) {
                continue;
            }
            handlers.push({
                handler,
                evt
            });
        }
        this.onDoneOrAborted({
            ...!!error ? {
                type: "ABORTED",
                error
            } : {
                type: "DONE",
                "result": result
            },
            handlers
        });
        return handlers;
    }
    handlers = new Polyfill1();
    evtByHandler = new Polyfill2();
    getHandlers() {
        return Array.from(this.handlers.values()).map((handler)=>({
                handler,
                "evt": this.evtByHandler.get(handler)
            })
        );
    }
    zz__addHandler(handler, evt) {
        assert1(handler.ctx === this);
        assert1(typeGuard(handler));
        this.handlers.add(handler);
        this.evtByHandler.set(handler, evt);
        this.lazyEvtAttach.post({
            handler,
            evt
        });
    }
    zz__removeHandler(handler) {
        assert1(handler.ctx === this);
        assert1(typeGuard(handler));
        this.lazyEvtDetach.post({
            handler,
            "evt": this.evtByHandler.get(handler)
        });
        this.handlers.delete(handler);
    }
}
const Ctx = CtxImpl;
try {
    overwriteReadonlyProp(Ctx, "name", "Ctx");
} catch  {
}
importProxy.Ctx = Ctx;
if (!Array.prototype.find) {
    Object.defineProperty(Array.prototype, 'find', {
        value: function(predicate) {
            if (this == null) {
                throw new TypeError('"this" is null or not defined');
            }
            var o = Object(this);
            var len = o.length >>> 0;
            if (typeof predicate !== 'function') {
                throw new TypeError('predicate must be a function');
            }
            var thisArg = arguments[1];
            var k = 0;
            while(k < len){
                var kValue = o[k];
                if (predicate.call(thisArg, kValue, k, o)) {
                    return kValue;
                }
                k++;
            }
            return undefined;
        },
        configurable: true,
        writable: true
    });
}
function create1(...args) {
    return args.length === 0 ? new importProxy.Evt() : new importProxy.StatefulEvt(args[0]);
}
function getCtxFactory() {
    const ctxByObj = new Polyfill2();
    function getCtx(obj) {
        let ctx = ctxByObj.get(obj);
        if (ctx === undefined) {
            ctx = new importProxy.Ctx();
            ctxByObj.set(obj, ctx);
        }
        return ctx;
    }
    return getCtx;
}
function factorize1(evt) {
    return evt;
}
function mergeImpl(ctx, evts) {
    const evtUnion = new importProxy.Evt();
    const callback = (data)=>evtUnion.post(data)
    ;
    evts.forEach((evt)=>{
        if (ctx === undefined) {
            evt.attach(callback);
        } else {
            evt.attach(ctx, callback);
        }
    });
    return evtUnion;
}
function merge1(p1, p2) {
    return "length" in p1 ? mergeImpl(undefined, p1) : mergeImpl(p1, p2);
}
function fromImpl(ctx, target, eventName, options) {
    const matchEventTargetLike = (target_)=>EventTargetLike.canBe(target_)
    ;
    if (!matchEventTargetLike(target)) {
        if ("then" in target) {
            const evt = new importProxy.Evt();
            const isCtxDone = (()=>{
                const getEvtDonePostCount = ()=>ctx?.evtDoneOrAborted.postCount
                ;
                const n = getEvtDonePostCount();
                return ()=>n !== getEvtDonePostCount()
                ;
            })();
            target.then((data)=>{
                if (isCtxDone()) {
                    return;
                }
                evt.post(data);
            });
            return evt;
        }
        return mergeImpl(ctx, Array.from(target).map((target1)=>fromImpl(ctx, target1, eventName, options)
        ));
    }
    let proxy;
    if (EventTargetLike.NodeStyleEventEmitter.match(target)) {
        proxy = {
            "on": (listener1, eventName1)=>target.addListener(eventName1, listener1)
            ,
            "off": (listener1, eventName1)=>target.removeListener(eventName1, listener1)
        };
    } else if (EventTargetLike.JQueryStyleEventEmitter.match(target)) {
        proxy = {
            "on": (listener1, eventName1)=>target.on(eventName1, listener1)
            ,
            "off": (listener1, eventName1)=>target.off(eventName1, listener1)
        };
    } else if (EventTargetLike.HasEventTargetAddRemove.match(target)) {
        proxy = {
            "on": (listener1, eventName1, options1)=>target.addEventListener(eventName1, listener1, options1)
            ,
            "off": (listener1, eventName1, options1)=>target.removeEventListener(eventName1, listener1, options1)
        };
    } else if (EventTargetLike.RxJSSubject.match(target)) {
        let subscription;
        proxy = {
            "on": (listener1)=>subscription = target.subscribe((data)=>listener1(data)
                )
            ,
            "off": ()=>subscription.unsubscribe()
        };
    } else {
        id(target);
        assert1(false);
    }
    const evt = new importProxy.Evt();
    const listener1 = (data)=>evt.post(data)
    ;
    ctx?.evtDoneOrAborted.attachOnce(()=>proxy.off(listener1, eventName, options)
    );
    proxy.on(listener1, eventName, options);
    return evt;
}
function from1(ctxOrTarget, targetOrEventName, eventNameOrOptions, options) {
    if ("evtDoneOrAborted" in ctxOrTarget) {
        assert1(typeGuard(targetOrEventName) && typeGuard(eventNameOrOptions) && typeGuard(options));
        return fromImpl(ctxOrTarget, targetOrEventName, eventNameOrOptions, options);
    } else {
        assert1(typeGuard(targetOrEventName) && typeGuard(eventNameOrOptions));
        return fromImpl(undefined, ctxOrTarget, targetOrEventName, eventNameOrOptions);
    }
}
function useEffect1(effect, evt, dataFirst) {
    let i4 = 0;
    ("state" in evt ? evt.evtChange : evt).attach((data)=>effect(data, {
            "isFirst": false,
            data
        }, i4++)
    );
    effect("state" in evt ? evt.state : dataFirst?.[0], {
        "isFirst": true
    }, i4++);
}
function asPostable1(evt) {
    return evt;
}
function asNonPostable1(evt) {
    return evt;
}
function matchAll() {
    return true;
}
const canBeOperator = (p)=>{
    return p !== undefined && typeGuard(p) && (typeof p === "function" || typeof p[0] === "function");
};
const defaultParams = {
    "op": matchAll,
    "ctx": undefined,
    "timeout": undefined,
    "callback": undefined
};
function parsePropsFromArgs(inputs, methodName) {
    typeGuard(defaultParams);
    switch(methodName){
        case "pipe":
            {
                const getOpWrap = (ops)=>ops.length === 0 ? {
                    } : {
                        "op": ops.length === 1 ? ops[0] : compose(...ops)
                    }
                ;
                if (canBeOperator(inputs[0])) {
                    return id({
                        ...defaultParams,
                        ...getOpWrap(inputs)
                    });
                } else {
                    const [ctx, ...rest] = inputs;
                    return id({
                        ...defaultParams,
                        ...ctx !== undefined ? {
                            ctx
                        } : {
                        },
                        ...getOpWrap(rest)
                    });
                }
            }
            break;
        case "waitFor":
            {
                return parsePropsFromArgs([
                    ...inputs.filter((value2, index)=>!(index === inputs.length - 1 && value2 === undefined)
                    ),
                    defaultParams.callback
                ], "attach*");
            }
            break;
        case "attach*":
            {
                const n = inputs.length;
                switch(n){
                    case 4:
                        {
                            const [p1, p2, p3, p4] = inputs;
                            return id({
                                ...defaultParams,
                                "op": p1,
                                "ctx": p2,
                                "timeout": p3,
                                "callback": p4
                            });
                        }
                    case 3:
                        {
                            const [p1, p2, p3] = inputs;
                            if (typeof p2 === "number") {
                                const timeout = p2;
                                const callback = p3;
                                if (canBeOperator(p1)) {
                                    return id({
                                        ...defaultParams,
                                        timeout,
                                        callback,
                                        "op": p1
                                    });
                                } else {
                                    return id({
                                        ...defaultParams,
                                        timeout,
                                        callback,
                                        "ctx": p1
                                    });
                                }
                            } else {
                                return id({
                                    ...defaultParams,
                                    "op": p1,
                                    "ctx": p2,
                                    "callback": p3
                                });
                            }
                        }
                    case 2:
                        {
                            const [p1, p2] = inputs;
                            if (typeof p1 === "number") {
                                return id({
                                    ...defaultParams,
                                    "timeout": p1,
                                    "callback": p2
                                });
                            } else {
                                const callback = p2;
                                if (canBeOperator(p1)) {
                                    return id({
                                        ...defaultParams,
                                        callback,
                                        "op": p1
                                    });
                                } else {
                                    return id({
                                        ...defaultParams,
                                        callback,
                                        "ctx": p1
                                    });
                                }
                            }
                        }
                    case 1:
                        {
                            const [p] = inputs;
                            return id({
                                ...defaultParams,
                                "callback": p
                            });
                        }
                    case 0:
                        {
                            return id({
                                ...defaultParams
                            });
                        }
                }
            }
            break;
    }
}
function newCtx1() {
    return new importProxy.Ctx();
}
class ExecQueue {
    queuedCalls = [];
    isRunning = false;
    cancelAllQueuedCalls() {
        let n;
        this.queuedCalls.splice(0, n = this.queuedCalls.length);
        return n;
    }
    prComplete = Promise.resolve();
}
const globalContext = {
};
const clusters = new Polyfill2();
function getOrCreateExecQueue(context, groupRef) {
    let execQueueByGroup = clusters.get(context);
    if (!execQueueByGroup) {
        execQueueByGroup = new Polyfill2();
        clusters.set(context, execQueueByGroup);
    }
    let execQueue = execQueueByGroup.get(groupRef);
    if (!execQueue) {
        execQueue = new ExecQueue();
        execQueueByGroup.set(groupRef, execQueue);
    }
    return execQueue;
}
function createGroupRef() {
    return new Array(0);
}
const groupByRunExclusiveFunction = new Polyfill2();
function buildMethodCb(...inputs) {
    switch(inputs.length){
        case 1:
            return buildFnCallback(false, createGroupRef(), inputs[0]);
        case 2:
            return buildFnCallback(false, inputs[0], inputs[1]);
    }
}
function buildFnCallback(isGlobal, groupRef, fun) {
    let execQueue;
    const runExclusiveFunction = function(...inputs) {
        if (!isGlobal) {
            if (!(this instanceof Object)) {
                throw new Error("Run exclusive, <this> should be an object");
            }
            execQueue = getOrCreateExecQueue(this, groupRef);
        }
        let callback = undefined;
        if (inputs.length && typeof inputs[inputs.length - 1] === "function") {
            callback = inputs.pop();
        }
        let onPrCompleteResolve;
        execQueue.prComplete = new Promise((resolve3)=>onPrCompleteResolve = ()=>resolve3()
        );
        const onComplete = (...inputs1)=>{
            onPrCompleteResolve();
            execQueue.isRunning = false;
            if (execQueue.queuedCalls.length) {
                execQueue.queuedCalls.shift()();
            }
            if (callback) {
                callback.apply(this, inputs1);
            }
        };
        onComplete.hasCallback = !!callback;
        (function callee(...inputs1) {
            if (execQueue.isRunning) {
                execQueue.queuedCalls.push(()=>callee.apply(this, inputs1)
                );
                return;
            }
            execQueue.isRunning = true;
            try {
                fun.apply(this, [
                    ...inputs1,
                    onComplete
                ]);
            } catch (error) {
                error.message += " ( This exception should not have been thrown, miss use of run-exclusive buildCb )";
                throw error;
            }
        }).apply(this, inputs);
    };
    if (isGlobal) {
        execQueue = getOrCreateExecQueue(globalContext, groupRef);
    }
    groupByRunExclusiveFunction.set(runExclusiveFunction, groupRef);
    return runExclusiveFunction;
}
class Deferred {
    constructor(){
        let resolve3;
        let reject;
        this.pr = new Promise((resolve_, reject_)=>{
            resolve3 = (value2)=>{
                overwriteReadonlyProp(this, "isPending", false);
                resolve_(value2);
            };
            reject = (error)=>{
                overwriteReadonlyProp(this, "isPending", false);
                reject_(error);
            };
        });
        this.resolve = resolve3;
        this.reject = reject;
    }
    isPending = true;
}
function loosenType1(evt) {
    return evt;
}
const safeSetTimeout = (callback, ms)=>setTimeout(callback, ms)
;
const safeClearTimeout = (timer)=>clearTimeout(timer)
;
class EvtImpl {
    static create = create1;
    static newCtx = newCtx1;
    static merge = merge1;
    static from = from1;
    static useEffect = useEffect1;
    static getCtx = getCtxFactory();
    static loosenType = loosenType1;
    static factorize = factorize1;
    static asPostable = asPostable1;
    static asyncPipe = asyncPipe;
    static asNonPostable = asNonPostable1;
    static __defaultMaxHandlers = 25;
    static setDefaultMaxHandlers(n) {
        this.__defaultMaxHandlers = isFinite(n) ? n : 0;
    }
    toStateful(p1, p2) {
        const isP1Ctx = CtxLike.match(p1);
        const initialValue = isP1Ctx ? undefined : p1;
        const ctx = p2 || (isP1Ctx ? p1 : undefined);
        const out = new importProxy.StatefulEvt(initialValue);
        const callback = (data)=>out.post(data)
        ;
        if (!!ctx) {
            this.attach(ctx, callback);
        } else {
            this.attach(callback);
        }
        return out;
    }
    lazyEvtAttach = new LazyEvt();
    lazyEvtDetach = new LazyEvt();
    static __1 = (()=>{
        if (false) {
            EvtImpl.__1;
        }
        defineAccessors(EvtImpl.prototype, "evtAttach", {
            "get": function() {
                return this.lazyEvtAttach.evt;
            }
        });
        defineAccessors(EvtImpl.prototype, "evtDetach", {
            "get": function() {
                return this.lazyEvtDetach.evt;
            }
        });
    })();
    __maxHandlers = undefined;
    setMaxHandlers(n) {
        this.__maxHandlers = isFinite(n) ? n : 0;
        return this;
    }
    postCount = 0;
    traceId = null;
    enableTrace(params) {
        const { id: id1 , formatter , log  } = params;
        this.traceId = id1;
        this.traceFormatter = formatter || ((data)=>{
            try {
                return JSON.stringify(data, null, 2);
            } catch  {
                return `${data}`;
            }
        });
        this.log = log === undefined ? (...inputs)=>console.log(...inputs)
         : log === false ? undefined : log;
    }
    disableTrace() {
        this.traceId = null;
        return this;
    }
    handlers = [];
    handlerTriggers = new Polyfill();
    static __2 = (()=>{
        if (false) {
            EvtImpl.__2;
        }
        Object.defineProperties(EvtImpl.prototype, [
            "__asyncHandlerChronologyMark",
            "__asyncHandlerChronologyExceptionRange",
            "__statelessByStatefulOp"
        ].map((key)=>[
                key.substr(2),
                {
                    "get": function() {
                        if (this[key] === undefined) {
                            this[key] = new Polyfill2();
                        }
                        return this[key];
                    }
                }
            ]
        ).reduce((prev, [key, obj])=>({
                ...prev,
                [key]: obj
            })
        , {
        }));
    })();
    __currentChronologyMark = 0;
    getChronologyMark() {
        return this.__currentChronologyMark++;
    }
    asyncHandlerCount = 0;
    detachHandler(handler, wTimer, rejectPr) {
        const index = this.handlers.indexOf(handler);
        if (index < 0) {
            return false;
        }
        if (typeGuard(handler, !!handler.ctx)) {
            handler.ctx.zz__removeHandler(handler);
        }
        this.handlers.splice(index, 1);
        if (handler.async) {
            this.asyncHandlerCount--;
        }
        this.handlerTriggers.delete(handler);
        if (wTimer[0] !== undefined) {
            safeClearTimeout(wTimer[0]);
            rejectPr(new EvtError.Detached());
        }
        this.lazyEvtDetach.post(handler);
        return true;
    }
    triggerHandler(handler, wTimer, resolvePr, opResult) {
        const { callback , once  } = handler;
        if (wTimer[0] !== undefined) {
            safeClearTimeout(wTimer[0]);
            wTimer[0] = undefined;
        }
        EvtImpl.doDetachIfNeeded(handler, opResult, once);
        const [transformedData] = opResult;
        callback?.call(this, transformedData);
        resolvePr?.(transformedData);
    }
    addHandler(propsFromArgs, propsFromMethodName) {
        if (Operator.f.Stateful.match(propsFromArgs.op)) {
            this.statelessByStatefulOp.set(propsFromArgs.op, encapsulateOpState(propsFromArgs.op));
        }
        const d = new Deferred();
        const wTimer = [
            undefined
        ];
        const handler = {
            ...propsFromArgs,
            ...propsFromMethodName,
            "detach": ()=>this.detachHandler(handler, wTimer, d.reject)
            ,
            "promise": d.pr
        };
        if (typeof handler.timeout === "number") {
            wTimer[0] = safeSetTimeout(()=>{
                wTimer[0] = undefined;
                handler.detach();
                d.reject(new EvtError.Timeout(handler.timeout));
            }, handler.timeout);
        }
        this.handlerTriggers.set(handler, (opResult)=>this.triggerHandler(handler, wTimer, d.isPending ? d.resolve : undefined, opResult)
        );
        if (handler.async) {
            this.asyncHandlerChronologyMark.set(handler, this.getChronologyMark());
        }
        if (handler.prepend) {
            let i4;
            for(i4 = 0; i4 < this.handlers.length; i4++){
                if (this.handlers[i4].extract) {
                    continue;
                }
                break;
            }
            this.handlers.splice(i4, 0, handler);
        } else {
            this.handlers.push(handler);
        }
        if (handler.async) {
            this.asyncHandlerCount++;
        }
        this.checkForPotentialMemoryLeak();
        if (typeGuard(handler, !!handler.ctx)) {
            handler.ctx.zz__addHandler(handler, this);
        }
        this.lazyEvtAttach.post(handler);
        return handler;
    }
    checkForPotentialMemoryLeak() {
        const maxHandlers = this.__maxHandlers !== undefined ? this.__maxHandlers : EvtImpl.__defaultMaxHandlers;
        if (maxHandlers === 0 || this.handlers.length % (maxHandlers + 1) !== 0) {
            return;
        }
        let message2 = [
            `MaxHandlersExceededWarning: Possible Evt memory leak detected.`,
            `${this.handlers.length} handlers attached${this.traceId ? ` to "${this.traceId}"` : ""}.\n`,
            `Use Evt.prototype.setMaxHandlers(n) to increase limit on a specific Evt.\n`,
            `Use Evt.setDefaultMaxHandlers(n) to change the default limit currently set to ${EvtImpl.__defaultMaxHandlers}.\n`, 
        ].join("");
        const map = new Polyfill();
        this.getHandlers().map(({ ctx , async , once , prepend , extract , op , callback  })=>({
                "hasCtx": !!ctx,
                once,
                prepend,
                extract,
                "isWaitFor": async,
                ...op === matchAll ? {
                } : {
                    "op": op.toString()
                },
                ...!callback ? {
                } : {
                    "callback": callback.toString()
                }
            })
        ).map((obj)=>"{\n" + Object.keys(obj).map((key)=>`  ${key}: ${obj[key]}`
            ).join(",\n") + "\n}"
        ).forEach((str1)=>map.set(str1, (map.has(str1) ? map.get(str1) : 0) + 1)
        );
        message2 += "\n" + Array.from(map.keys()).map((str1)=>`${map.get(str1)} handler${map.get(str1) === 1 ? "" : "s"} like:\n${str1}`
        ).join("\n") + "\n";
        if (this.traceId === null) {
            message2 += "\n" + [
                `To validate the identify of the Evt instance that is triggering this warning you can call`,
                `Evt.prototype.enableTrace({ "id": "My evt id", "log": false }) on the Evt that you suspect.\n`
            ].join(" ");
        }
        try {
            console.warn(message2);
        } catch  {
        }
    }
    getStatelessOp(op) {
        return Operator.f.Stateful.match(op) ? this.statelessByStatefulOp.get(op) : op;
    }
    trace(data) {
        if (this.traceId === null) {
            return;
        }
        let message2 = `(${this.traceId}) `;
        const isExtracted = !!this.handlers.find(({ extract , op  })=>extract && !!this.getStatelessOp(op)(data)
        );
        if (isExtracted) {
            message2 += "extracted ";
        } else {
            const handlerCount = this.handlers.filter(({ extract , op  })=>!extract && !!this.getStatelessOp(op)(data)
            ).length;
            message2 += `${handlerCount} handler${handlerCount > 1 ? "s" : ""}, `;
        }
        this.log?.(message2 + this.traceFormatter(data));
    }
    postSync(data) {
        for (const handler of [
            ...this.handlers
        ]){
            const { async , op , extract  } = handler;
            if (async) {
                continue;
            }
            const opResult = invokeOperator(this.getStatelessOp(op), data, true);
            if (Operator.f.Result.NotMatched.match(opResult)) {
                EvtImpl.doDetachIfNeeded(handler, opResult);
                continue;
            }
            const handlerTrigger = this.handlerTriggers.get(handler);
            if (!handlerTrigger) {
                continue;
            }
            handlerTrigger(opResult);
            if (extract) {
                return true;
            }
        }
        return false;
    }
    postAsyncFactory() {
        return buildMethodCb((data, postChronologyMark, releaseLock)=>{
            if (this.asyncHandlerCount === 0) {
                releaseLock();
                return;
            }
            const promises = [];
            let chronologyMarkStartResolveTick;
            Promise.resolve().then(()=>chronologyMarkStartResolveTick = this.getChronologyMark()
            );
            for (const handler of [
                ...this.handlers
            ]){
                if (!handler.async) {
                    continue;
                }
                const opResult = invokeOperator(this.getStatelessOp(handler.op), data, true);
                if (Operator.f.Result.NotMatched.match(opResult)) {
                    EvtImpl.doDetachIfNeeded(handler, opResult);
                    continue;
                }
                const handlerTrigger = this.handlerTriggers.get(handler);
                if (!handlerTrigger) {
                    continue;
                }
                const shouldCallHandlerTrigger = (()=>{
                    const handlerMark = this.asyncHandlerChronologyMark.get(handler);
                    if (postChronologyMark > handlerMark) {
                        return true;
                    }
                    const exceptionRange = this.asyncHandlerChronologyExceptionRange.get(handler);
                    return exceptionRange !== undefined && exceptionRange.lowerMark < postChronologyMark && postChronologyMark < exceptionRange.upperMark && handlerMark > exceptionRange.upperMark;
                })();
                if (!shouldCallHandlerTrigger) {
                    continue;
                }
                promises.push(new Promise((resolve4)=>handler.promise.then(()=>resolve4()
                    ).catch(()=>resolve4()
                    )
                ));
                handlerTrigger(opResult);
            }
            if (promises.length === 0) {
                releaseLock();
                return;
            }
            const handlersDump = [
                ...this.handlers
            ];
            Promise.all(promises).then(()=>{
                for (const handler1 of this.handlers){
                    if (!handler1.async) {
                        continue;
                    }
                    if (handlersDump.indexOf(handler1) >= 0) {
                        continue;
                    }
                    this.asyncHandlerChronologyExceptionRange.set(handler1, {
                        "lowerMark": postChronologyMark,
                        "upperMark": chronologyMarkStartResolveTick
                    });
                }
                releaseLock();
            });
        });
    }
    static propsFormMethodNames = {
        "waitFor": {
            "async": true,
            "extract": false,
            "once": true,
            "prepend": false
        },
        "attach": {
            "async": false,
            "extract": false,
            "once": false,
            "prepend": false
        },
        "attachExtract": {
            "async": false,
            "extract": true,
            "once": false,
            "prepend": true
        },
        "attachPrepend": {
            "async": false,
            "extract": false,
            "once": false,
            "prepend": true
        },
        "attachOnce": {
            "async": false,
            "extract": false,
            "once": true,
            "prepend": false
        },
        "attachOncePrepend": {
            "async": false,
            "extract": false,
            "once": true,
            "prepend": true
        },
        "attachOnceExtract": {
            "async": false,
            "extract": true,
            "once": true,
            "prepend": true
        }
    };
    isHandled(data) {
        return !!this.getHandlers().find(({ op  })=>!!this.getStatelessOp(op)(data)
        );
    }
    getHandlers() {
        return [
            ...this.handlers
        ];
    }
    detach(ctx) {
        const detachedHandlers = [];
        for (const handler of this.getHandlers()){
            if (ctx !== undefined && handler.ctx !== ctx) {
                continue;
            }
            const wasStillAttached = handler.detach();
            if (!wasStillAttached) {
                continue;
            }
            detachedHandlers.push(handler);
        }
        return detachedHandlers;
    }
    pipe(...args) {
        const evtDelegate = new EvtImpl();
        this.addHandler({
            ...parsePropsFromArgs(args, "pipe"),
            "callback": (transformedData)=>evtDelegate.post(transformedData)
        }, EvtImpl.propsFormMethodNames.attach);
        return evtDelegate;
    }
    waitFor(...args) {
        return this.addHandler(parsePropsFromArgs(args, "waitFor"), EvtImpl.propsFormMethodNames.waitFor).promise;
    }
    $attach(...inputs) {
        return this.attach(...inputs);
    }
    attach(...args) {
        return this.__attachX(args, "attach");
    }
    $attachOnce(...inputs) {
        return this.attachOnce(...inputs);
    }
    attachOnce(...args) {
        return this.__attachX(args, "attachOnce");
    }
    $attachExtract(...inputs) {
        return this.attachExtract(...inputs);
    }
    attachExtract(...args) {
        return this.__attachX(args, "attachExtract");
    }
    $attachPrepend(...inputs) {
        return this.attachPrepend(...inputs);
    }
    attachPrepend(...args) {
        return this.__attachX(args, "attachPrepend");
    }
    $attachOncePrepend(...inputs) {
        return this.attachOncePrepend(...inputs);
    }
    attachOncePrepend(...args) {
        return this.__attachX(args, "attachOncePrepend");
    }
    $attachOnceExtract(...inputs) {
        return this.attachOnceExtract(...inputs);
    }
    attachOnceExtract(...args) {
        return this.__attachX(args, "attachOnceExtract");
    }
    __attachX(args, methodName) {
        const propsFromArgs = parsePropsFromArgs(args, "attach*");
        const handler = this.addHandler(propsFromArgs, EvtImpl.propsFormMethodNames[methodName]);
        return propsFromArgs.timeout === undefined ? this : handler.promise;
    }
    postAsyncOnceHandled(data) {
        if (this.isHandled(data)) {
            return this.post(data);
        }
        const d = new Deferred();
        this.evtAttach.attachOnce(({ op  })=>!!invokeOperator(this.getStatelessOp(op), data)
        , ()=>Promise.resolve().then(()=>d.resolve(this.post(data))
            )
        );
        return d.pr;
    }
    post(data) {
        this.trace(data);
        overwriteReadonlyProp(this, "postCount", this.postCount + 1);
        const postChronologyMark = this.getChronologyMark();
        const isExtracted = this.postSync(data);
        if (isExtracted) {
            return this.postCount;
        }
        if (this.postAsync === undefined) {
            if (this.asyncHandlerCount === 0) {
                return this.postCount;
            }
            this.postAsync = this.postAsyncFactory();
        }
        this.postAsync(data, postChronologyMark);
        return this.postCount;
    }
}
function asyncPipe(evt, asyncOp) {
    const out = new Evt();
    evt.attach(async (data)=>{
        const opResult = await asyncOp(data);
        if (opResult === null) {
            return;
        }
        out.post(opResult[0]);
    });
    return out;
}
var EvtImpl;
(function(EvtImpl1) {
    function doDetachIfNeeded(handler, opResult, once) {
        const detach = Operator.f.Result.getDetachArg(opResult);
        if (typeof detach !== "boolean") {
            const [ctx, error, res] = detach;
            if (!!error) {
                ctx.abort(error);
            } else {
                ctx.done(res);
            }
        } else if (detach || !!once) {
            handler.detach();
        }
    }
    EvtImpl1.doDetachIfNeeded = doDetachIfNeeded;
})(EvtImpl || (EvtImpl = {
}));
const Evt = EvtImpl;
try {
    overwriteReadonlyProp(Evt, "name", "Evt");
} catch  {
}
importProxy.Evt = Evt;
if (!Object.is) {
    Object.is = function(x, y) {
        if (x === y) {
            return x !== 0 || 1 / x === 1 / y;
        } else {
            return x !== x && y !== y;
        }
    };
}
class LazyStatefulEvt {
    initialPostCount = 0;
    constructor(initialState){
        this.initialState = initialState;
    }
    static __1 = (()=>{
        if (false) {
            LazyStatefulEvt.__1;
        }
        defineAccessors(LazyStatefulEvt.prototype, "evt", {
            "get": function() {
                if (this.__evt === undefined) {
                    this.__evt = new importProxy.StatefulEvt(this.initialState);
                    delete this.initialState;
                    overwriteReadonlyProp(this.__evt, "postCount", this.initialPostCount);
                }
                return this.__evt;
            }
        });
    })();
    post(data) {
        if (this.__evt === undefined) {
            this.initialState = data;
            return ++this.initialPostCount;
        }
        return this.__evt.post(data);
    }
}
class StatefulEvtImpl extends Evt {
    constructor(initialState1){
        super();
        this.__state = initialState1;
        this.lazyEvtChange = new LazyStatefulEvt(this.__state);
    }
    lazyEvtDiff = new LazyEvt();
    lazyEvtChangeDiff = new LazyEvt();
    static __4 = (()=>{
        if (false) {
            StatefulEvtImpl.__4;
        }
        defineAccessors(StatefulEvtImpl.prototype, "state", {
            "get": function() {
                return this.__state;
            },
            "set": function(state) {
                this.post(state);
            }
        });
        defineAccessors(StatefulEvtImpl.prototype, "evtDiff", {
            "get": function() {
                return this.lazyEvtDiff.evt;
            }
        });
        defineAccessors(StatefulEvtImpl.prototype, "evtChange", {
            "get": function() {
                return this.lazyEvtChange.evt;
            }
        });
        defineAccessors(StatefulEvtImpl.prototype, "evtChangeDiff", {
            "get": function() {
                return this.lazyEvtChangeDiff.evt;
            }
        });
    })();
    post(data) {
        return this.__post(data, false);
    }
    postForceChange(wData) {
        return this.__post(!!wData ? wData[0] : this.state, true);
    }
    __post(data, forceChange) {
        const prevState = this.state;
        this.__state = data;
        const diff = {
            prevState,
            "newState": this.state
        };
        this.lazyEvtDiff.post(diff);
        if (forceChange || !Object.is(prevState, this.state)) {
            this.lazyEvtChange.post(this.state);
            this.lazyEvtChangeDiff.post(diff);
        }
        return super.post(data);
    }
    pipe(...args) {
        const evt = super.pipe(...args);
        const opResult = invokeOperator(this.getStatelessOp(parsePropsFromArgs(args, "pipe").op), this.state);
        if (Operator.f.Result.NotMatched.match(opResult)) {
            throw new Error([
                "Cannot pipe StatefulEvt because the operator does not match",
                "it's current state.",
                "Use evt.toStateless([ctx]).pipe(op).toStatic(initialState)",
                "to be sure the StatefulEvt is correctly initialized"
            ].join(" "));
        }
        return evt.toStateful(opResult[0]);
    }
    toStateless(ctx) {
        return !!ctx ? super.pipe(ctx) : super.pipe();
    }
}
const StatefulEvt = StatefulEvtImpl;
importProxy.StatefulEvt = StatefulEvt;
const db = JSON.parse(`{\n  "application/1d-interleaved-parityfec": {\n    "source": "iana"\n  },\n  "application/3gpdash-qoe-report+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/3gpp-ims+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/a2l": {\n    "source": "iana"\n  },\n  "application/activemessage": {\n    "source": "iana"\n  },\n  "application/activity+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-costmap+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-costmapfilter+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-directory+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-endpointcost+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-endpointcostparams+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-endpointprop+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-endpointpropparams+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-error+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-networkmap+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-networkmapfilter+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-updatestreamcontrol+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-updatestreamparams+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/aml": {\n    "source": "iana"\n  },\n  "application/andrew-inset": {\n    "source": "iana",\n    "extensions": ["ez"]\n  },\n  "application/applefile": {\n    "source": "iana"\n  },\n  "application/applixware": {\n    "source": "apache",\n    "extensions": ["aw"]\n  },\n  "application/atf": {\n    "source": "iana"\n  },\n  "application/atfx": {\n    "source": "iana"\n  },\n  "application/atom+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["atom"]\n  },\n  "application/atomcat+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["atomcat"]\n  },\n  "application/atomdeleted+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["atomdeleted"]\n  },\n  "application/atomicmail": {\n    "source": "iana"\n  },\n  "application/atomsvc+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["atomsvc"]\n  },\n  "application/atsc-dwd+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["dwd"]\n  },\n  "application/atsc-dynamic-event-message": {\n    "source": "iana"\n  },\n  "application/atsc-held+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["held"]\n  },\n  "application/atsc-rdt+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/atsc-rsat+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rsat"]\n  },\n  "application/atxml": {\n    "source": "iana"\n  },\n  "application/auth-policy+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/bacnet-xdd+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/batch-smtp": {\n    "source": "iana"\n  },\n  "application/bdoc": {\n    "compressible": false,\n    "extensions": ["bdoc"]\n  },\n  "application/beep+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/calendar+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/calendar+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xcs"]\n  },\n  "application/call-completion": {\n    "source": "iana"\n  },\n  "application/cals-1840": {\n    "source": "iana"\n  },\n  "application/captive+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/cbor": {\n    "source": "iana"\n  },\n  "application/cbor-seq": {\n    "source": "iana"\n  },\n  "application/cccex": {\n    "source": "iana"\n  },\n  "application/ccmp+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/ccxml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ccxml"]\n  },\n  "application/cdfx+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["cdfx"]\n  },\n  "application/cdmi-capability": {\n    "source": "iana",\n    "extensions": ["cdmia"]\n  },\n  "application/cdmi-container": {\n    "source": "iana",\n    "extensions": ["cdmic"]\n  },\n  "application/cdmi-domain": {\n    "source": "iana",\n    "extensions": ["cdmid"]\n  },\n  "application/cdmi-object": {\n    "source": "iana",\n    "extensions": ["cdmio"]\n  },\n  "application/cdmi-queue": {\n    "source": "iana",\n    "extensions": ["cdmiq"]\n  },\n  "application/cdni": {\n    "source": "iana"\n  },\n  "application/cea": {\n    "source": "iana"\n  },\n  "application/cea-2018+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/cellml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/cfw": {\n    "source": "iana"\n  },\n  "application/clue+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/clue_info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/cms": {\n    "source": "iana"\n  },\n  "application/cnrp+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/coap-group+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/coap-payload": {\n    "source": "iana"\n  },\n  "application/commonground": {\n    "source": "iana"\n  },\n  "application/conference-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/cose": {\n    "source": "iana"\n  },\n  "application/cose-key": {\n    "source": "iana"\n  },\n  "application/cose-key-set": {\n    "source": "iana"\n  },\n  "application/cpl+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/csrattrs": {\n    "source": "iana"\n  },\n  "application/csta+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/cstadata+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/csvm+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/cu-seeme": {\n    "source": "apache",\n    "extensions": ["cu"]\n  },\n  "application/cwt": {\n    "source": "iana"\n  },\n  "application/cybercash": {\n    "source": "iana"\n  },\n  "application/dart": {\n    "compressible": true\n  },\n  "application/dash+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mpd"]\n  },\n  "application/dashdelta": {\n    "source": "iana"\n  },\n  "application/davmount+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["davmount"]\n  },\n  "application/dca-rft": {\n    "source": "iana"\n  },\n  "application/dcd": {\n    "source": "iana"\n  },\n  "application/dec-dx": {\n    "source": "iana"\n  },\n  "application/dialog-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/dicom": {\n    "source": "iana"\n  },\n  "application/dicom+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/dicom+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/dii": {\n    "source": "iana"\n  },\n  "application/dit": {\n    "source": "iana"\n  },\n  "application/dns": {\n    "source": "iana"\n  },\n  "application/dns+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/dns-message": {\n    "source": "iana"\n  },\n  "application/docbook+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["dbk"]\n  },\n  "application/dots+cbor": {\n    "source": "iana"\n  },\n  "application/dskpp+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/dssc+der": {\n    "source": "iana",\n    "extensions": ["dssc"]\n  },\n  "application/dssc+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xdssc"]\n  },\n  "application/dvcs": {\n    "source": "iana"\n  },\n  "application/ecmascript": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ecma","es"]\n  },\n  "application/edi-consent": {\n    "source": "iana"\n  },\n  "application/edi-x12": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/edifact": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/efi": {\n    "source": "iana"\n  },\n  "application/emergencycalldata.cap+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/emergencycalldata.comment+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emergencycalldata.control+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emergencycalldata.deviceinfo+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emergencycalldata.ecall.msd": {\n    "source": "iana"\n  },\n  "application/emergencycalldata.providerinfo+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emergencycalldata.serviceinfo+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emergencycalldata.subscriberinfo+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emergencycalldata.veds+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emma+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["emma"]\n  },\n  "application/emotionml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["emotionml"]\n  },\n  "application/encaprtp": {\n    "source": "iana"\n  },\n  "application/epp+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/epub+zip": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["epub"]\n  },\n  "application/eshop": {\n    "source": "iana"\n  },\n  "application/exi": {\n    "source": "iana",\n    "extensions": ["exi"]\n  },\n  "application/expect-ct-report+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/fastinfoset": {\n    "source": "iana"\n  },\n  "application/fastsoap": {\n    "source": "iana"\n  },\n  "application/fdt+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["fdt"]\n  },\n  "application/fhir+json": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/fhir+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/fido.trusted-apps+json": {\n    "compressible": true\n  },\n  "application/fits": {\n    "source": "iana"\n  },\n  "application/flexfec": {\n    "source": "iana"\n  },\n  "application/font-sfnt": {\n    "source": "iana"\n  },\n  "application/font-tdpfr": {\n    "source": "iana",\n    "extensions": ["pfr"]\n  },\n  "application/font-woff": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/framework-attributes+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/geo+json": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["geojson"]\n  },\n  "application/geo+json-seq": {\n    "source": "iana"\n  },\n  "application/geopackage+sqlite3": {\n    "source": "iana"\n  },\n  "application/geoxacml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/gltf-buffer": {\n    "source": "iana"\n  },\n  "application/gml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["gml"]\n  },\n  "application/gpx+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["gpx"]\n  },\n  "application/gxf": {\n    "source": "apache",\n    "extensions": ["gxf"]\n  },\n  "application/gzip": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["gz"]\n  },\n  "application/h224": {\n    "source": "iana"\n  },\n  "application/held+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/hjson": {\n    "extensions": ["hjson"]\n  },\n  "application/http": {\n    "source": "iana"\n  },\n  "application/hyperstudio": {\n    "source": "iana",\n    "extensions": ["stk"]\n  },\n  "application/ibe-key-request+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/ibe-pkg-reply+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/ibe-pp-data": {\n    "source": "iana"\n  },\n  "application/iges": {\n    "source": "iana"\n  },\n  "application/im-iscomposing+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/index": {\n    "source": "iana"\n  },\n  "application/index.cmd": {\n    "source": "iana"\n  },\n  "application/index.obj": {\n    "source": "iana"\n  },\n  "application/index.response": {\n    "source": "iana"\n  },\n  "application/index.vnd": {\n    "source": "iana"\n  },\n  "application/inkml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ink","inkml"]\n  },\n  "application/iotp": {\n    "source": "iana"\n  },\n  "application/ipfix": {\n    "source": "iana",\n    "extensions": ["ipfix"]\n  },\n  "application/ipp": {\n    "source": "iana"\n  },\n  "application/isup": {\n    "source": "iana"\n  },\n  "application/its+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["its"]\n  },\n  "application/java-archive": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["jar","war","ear"]\n  },\n  "application/java-serialized-object": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["ser"]\n  },\n  "application/java-vm": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["class"]\n  },\n  "application/javascript": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["js","mjs"]\n  },\n  "application/jf2feed+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/jose": {\n    "source": "iana"\n  },\n  "application/jose+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/jrd+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/json": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["json","map"]\n  },\n  "application/json-patch+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/json-seq": {\n    "source": "iana"\n  },\n  "application/json5": {\n    "extensions": ["json5"]\n  },\n  "application/jsonml+json": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["jsonml"]\n  },\n  "application/jwk+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/jwk-set+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/jwt": {\n    "source": "iana"\n  },\n  "application/kpml-request+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/kpml-response+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/ld+json": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["jsonld"]\n  },\n  "application/lgr+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["lgr"]\n  },\n  "application/link-format": {\n    "source": "iana"\n  },\n  "application/load-control+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/lost+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["lostxml"]\n  },\n  "application/lostsync+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/lpf+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/lxf": {\n    "source": "iana"\n  },\n  "application/mac-binhex40": {\n    "source": "iana",\n    "extensions": ["hqx"]\n  },\n  "application/mac-compactpro": {\n    "source": "apache",\n    "extensions": ["cpt"]\n  },\n  "application/macwriteii": {\n    "source": "iana"\n  },\n  "application/mads+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mads"]\n  },\n  "application/manifest+json": {\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["webmanifest"]\n  },\n  "application/marc": {\n    "source": "iana",\n    "extensions": ["mrc"]\n  },\n  "application/marcxml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mrcx"]\n  },\n  "application/mathematica": {\n    "source": "iana",\n    "extensions": ["ma","nb","mb"]\n  },\n  "application/mathml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mathml"]\n  },\n  "application/mathml-content+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mathml-presentation+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-associated-procedure-description+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-deregister+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-envelope+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-msk+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-msk-response+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-protection-description+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-reception-report+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-register+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-register-response+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-schedule+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-user-service-description+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbox": {\n    "source": "iana",\n    "extensions": ["mbox"]\n  },\n  "application/media-policy-dataset+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/media_control+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mediaservercontrol+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mscml"]\n  },\n  "application/merge-patch+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/metalink+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["metalink"]\n  },\n  "application/metalink4+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["meta4"]\n  },\n  "application/mets+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mets"]\n  },\n  "application/mf4": {\n    "source": "iana"\n  },\n  "application/mikey": {\n    "source": "iana"\n  },\n  "application/mipc": {\n    "source": "iana"\n  },\n  "application/mmt-aei+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["maei"]\n  },\n  "application/mmt-usd+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["musd"]\n  },\n  "application/mods+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mods"]\n  },\n  "application/moss-keys": {\n    "source": "iana"\n  },\n  "application/moss-signature": {\n    "source": "iana"\n  },\n  "application/mosskey-data": {\n    "source": "iana"\n  },\n  "application/mosskey-request": {\n    "source": "iana"\n  },\n  "application/mp21": {\n    "source": "iana",\n    "extensions": ["m21","mp21"]\n  },\n  "application/mp4": {\n    "source": "iana",\n    "extensions": ["mp4s","m4p"]\n  },\n  "application/mpeg4-generic": {\n    "source": "iana"\n  },\n  "application/mpeg4-iod": {\n    "source": "iana"\n  },\n  "application/mpeg4-iod-xmt": {\n    "source": "iana"\n  },\n  "application/mrb-consumer+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xdf"]\n  },\n  "application/mrb-publish+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xdf"]\n  },\n  "application/msc-ivr+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/msc-mixer+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/msword": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["doc","dot"]\n  },\n  "application/mud+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/multipart-core": {\n    "source": "iana"\n  },\n  "application/mxf": {\n    "source": "iana",\n    "extensions": ["mxf"]\n  },\n  "application/n-quads": {\n    "source": "iana",\n    "extensions": ["nq"]\n  },\n  "application/n-triples": {\n    "source": "iana",\n    "extensions": ["nt"]\n  },\n  "application/nasdata": {\n    "source": "iana"\n  },\n  "application/news-checkgroups": {\n    "source": "iana",\n    "charset": "US-ASCII"\n  },\n  "application/news-groupinfo": {\n    "source": "iana",\n    "charset": "US-ASCII"\n  },\n  "application/news-transmission": {\n    "source": "iana"\n  },\n  "application/nlsml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/node": {\n    "source": "iana",\n    "extensions": ["cjs"]\n  },\n  "application/nss": {\n    "source": "iana"\n  },\n  "application/ocsp-request": {\n    "source": "iana"\n  },\n  "application/ocsp-response": {\n    "source": "iana"\n  },\n  "application/octet-stream": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]\n  },\n  "application/oda": {\n    "source": "iana",\n    "extensions": ["oda"]\n  },\n  "application/odm+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/odx": {\n    "source": "iana"\n  },\n  "application/oebps-package+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["opf"]\n  },\n  "application/ogg": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["ogx"]\n  },\n  "application/omdoc+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["omdoc"]\n  },\n  "application/onenote": {\n    "source": "apache",\n    "extensions": ["onetoc","onetoc2","onetmp","onepkg"]\n  },\n  "application/opc-nodeset+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/oscore": {\n    "source": "iana"\n  },\n  "application/oxps": {\n    "source": "iana",\n    "extensions": ["oxps"]\n  },\n  "application/p2p-overlay+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["relo"]\n  },\n  "application/parityfec": {\n    "source": "iana"\n  },\n  "application/passport": {\n    "source": "iana"\n  },\n  "application/patch-ops-error+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xer"]\n  },\n  "application/pdf": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["pdf"]\n  },\n  "application/pdx": {\n    "source": "iana"\n  },\n  "application/pem-certificate-chain": {\n    "source": "iana"\n  },\n  "application/pgp-encrypted": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["pgp"]\n  },\n  "application/pgp-keys": {\n    "source": "iana"\n  },\n  "application/pgp-signature": {\n    "source": "iana",\n    "extensions": ["asc","sig"]\n  },\n  "application/pics-rules": {\n    "source": "apache",\n    "extensions": ["prf"]\n  },\n  "application/pidf+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/pidf-diff+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/pkcs10": {\n    "source": "iana",\n    "extensions": ["p10"]\n  },\n  "application/pkcs12": {\n    "source": "iana"\n  },\n  "application/pkcs7-mime": {\n    "source": "iana",\n    "extensions": ["p7m","p7c"]\n  },\n  "application/pkcs7-signature": {\n    "source": "iana",\n    "extensions": ["p7s"]\n  },\n  "application/pkcs8": {\n    "source": "iana",\n    "extensions": ["p8"]\n  },\n  "application/pkcs8-encrypted": {\n    "source": "iana"\n  },\n  "application/pkix-attr-cert": {\n    "source": "iana",\n    "extensions": ["ac"]\n  },\n  "application/pkix-cert": {\n    "source": "iana",\n    "extensions": ["cer"]\n  },\n  "application/pkix-crl": {\n    "source": "iana",\n    "extensions": ["crl"]\n  },\n  "application/pkix-pkipath": {\n    "source": "iana",\n    "extensions": ["pkipath"]\n  },\n  "application/pkixcmp": {\n    "source": "iana",\n    "extensions": ["pki"]\n  },\n  "application/pls+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["pls"]\n  },\n  "application/poc-settings+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/postscript": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ai","eps","ps"]\n  },\n  "application/ppsp-tracker+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/problem+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/problem+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/provenance+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["provx"]\n  },\n  "application/prs.alvestrand.titrax-sheet": {\n    "source": "iana"\n  },\n  "application/prs.cww": {\n    "source": "iana",\n    "extensions": ["cww"]\n  },\n  "application/prs.hpub+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/prs.nprend": {\n    "source": "iana"\n  },\n  "application/prs.plucker": {\n    "source": "iana"\n  },\n  "application/prs.rdf-xml-crypt": {\n    "source": "iana"\n  },\n  "application/prs.xsf+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/pskc+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["pskcxml"]\n  },\n  "application/pvd+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/qsig": {\n    "source": "iana"\n  },\n  "application/raml+yaml": {\n    "compressible": true,\n    "extensions": ["raml"]\n  },\n  "application/raptorfec": {\n    "source": "iana"\n  },\n  "application/rdap+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/rdf+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rdf","owl"]\n  },\n  "application/reginfo+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rif"]\n  },\n  "application/relax-ng-compact-syntax": {\n    "source": "iana",\n    "extensions": ["rnc"]\n  },\n  "application/remote-printing": {\n    "source": "iana"\n  },\n  "application/reputon+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/resource-lists+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rl"]\n  },\n  "application/resource-lists-diff+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rld"]\n  },\n  "application/rfc+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/riscos": {\n    "source": "iana"\n  },\n  "application/rlmi+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/rls-services+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rs"]\n  },\n  "application/route-apd+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rapd"]\n  },\n  "application/route-s-tsid+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["sls"]\n  },\n  "application/route-usd+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rusd"]\n  },\n  "application/rpki-ghostbusters": {\n    "source": "iana",\n    "extensions": ["gbr"]\n  },\n  "application/rpki-manifest": {\n    "source": "iana",\n    "extensions": ["mft"]\n  },\n  "application/rpki-publication": {\n    "source": "iana"\n  },\n  "application/rpki-roa": {\n    "source": "iana",\n    "extensions": ["roa"]\n  },\n  "application/rpki-updown": {\n    "source": "iana"\n  },\n  "application/rsd+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["rsd"]\n  },\n  "application/rss+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["rss"]\n  },\n  "application/rtf": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rtf"]\n  },\n  "application/rtploopback": {\n    "source": "iana"\n  },\n  "application/rtx": {\n    "source": "iana"\n  },\n  "application/samlassertion+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/samlmetadata+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/sarif+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/sbe": {\n    "source": "iana"\n  },\n  "application/sbml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["sbml"]\n  },\n  "application/scaip+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/scim+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/scvp-cv-request": {\n    "source": "iana",\n    "extensions": ["scq"]\n  },\n  "application/scvp-cv-response": {\n    "source": "iana",\n    "extensions": ["scs"]\n  },\n  "application/scvp-vp-request": {\n    "source": "iana",\n    "extensions": ["spq"]\n  },\n  "application/scvp-vp-response": {\n    "source": "iana",\n    "extensions": ["spp"]\n  },\n  "application/sdp": {\n    "source": "iana",\n    "extensions": ["sdp"]\n  },\n  "application/secevent+jwt": {\n    "source": "iana"\n  },\n  "application/senml+cbor": {\n    "source": "iana"\n  },\n  "application/senml+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/senml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["senmlx"]\n  },\n  "application/senml-etch+cbor": {\n    "source": "iana"\n  },\n  "application/senml-etch+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/senml-exi": {\n    "source": "iana"\n  },\n  "application/sensml+cbor": {\n    "source": "iana"\n  },\n  "application/sensml+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/sensml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["sensmlx"]\n  },\n  "application/sensml-exi": {\n    "source": "iana"\n  },\n  "application/sep+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/sep-exi": {\n    "source": "iana"\n  },\n  "application/session-info": {\n    "source": "iana"\n  },\n  "application/set-payment": {\n    "source": "iana"\n  },\n  "application/set-payment-initiation": {\n    "source": "iana",\n    "extensions": ["setpay"]\n  },\n  "application/set-registration": {\n    "source": "iana"\n  },\n  "application/set-registration-initiation": {\n    "source": "iana",\n    "extensions": ["setreg"]\n  },\n  "application/sgml": {\n    "source": "iana"\n  },\n  "application/sgml-open-catalog": {\n    "source": "iana"\n  },\n  "application/shf+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["shf"]\n  },\n  "application/sieve": {\n    "source": "iana",\n    "extensions": ["siv","sieve"]\n  },\n  "application/simple-filter+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/simple-message-summary": {\n    "source": "iana"\n  },\n  "application/simplesymbolcontainer": {\n    "source": "iana"\n  },\n  "application/sipc": {\n    "source": "iana"\n  },\n  "application/slate": {\n    "source": "iana"\n  },\n  "application/smil": {\n    "source": "iana"\n  },\n  "application/smil+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["smi","smil"]\n  },\n  "application/smpte336m": {\n    "source": "iana"\n  },\n  "application/soap+fastinfoset": {\n    "source": "iana"\n  },\n  "application/soap+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/sparql-query": {\n    "source": "iana",\n    "extensions": ["rq"]\n  },\n  "application/sparql-results+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["srx"]\n  },\n  "application/spirits-event+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/sql": {\n    "source": "iana"\n  },\n  "application/srgs": {\n    "source": "iana",\n    "extensions": ["gram"]\n  },\n  "application/srgs+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["grxml"]\n  },\n  "application/sru+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["sru"]\n  },\n  "application/ssdl+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["ssdl"]\n  },\n  "application/ssml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ssml"]\n  },\n  "application/stix+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/swid+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["swidtag"]\n  },\n  "application/tamp-apex-update": {\n    "source": "iana"\n  },\n  "application/tamp-apex-update-confirm": {\n    "source": "iana"\n  },\n  "application/tamp-community-update": {\n    "source": "iana"\n  },\n  "application/tamp-community-update-confirm": {\n    "source": "iana"\n  },\n  "application/tamp-error": {\n    "source": "iana"\n  },\n  "application/tamp-sequence-adjust": {\n    "source": "iana"\n  },\n  "application/tamp-sequence-adjust-confirm": {\n    "source": "iana"\n  },\n  "application/tamp-status-query": {\n    "source": "iana"\n  },\n  "application/tamp-status-response": {\n    "source": "iana"\n  },\n  "application/tamp-update": {\n    "source": "iana"\n  },\n  "application/tamp-update-confirm": {\n    "source": "iana"\n  },\n  "application/tar": {\n    "compressible": true\n  },\n  "application/taxii+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/td+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/tei+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["tei","teicorpus"]\n  },\n  "application/tetra_isi": {\n    "source": "iana"\n  },\n  "application/thraud+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["tfi"]\n  },\n  "application/timestamp-query": {\n    "source": "iana"\n  },\n  "application/timestamp-reply": {\n    "source": "iana"\n  },\n  "application/timestamped-data": {\n    "source": "iana",\n    "extensions": ["tsd"]\n  },\n  "application/tlsrpt+gzip": {\n    "source": "iana"\n  },\n  "application/tlsrpt+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/tnauthlist": {\n    "source": "iana"\n  },\n  "application/toml": {\n    "compressible": true,\n    "extensions": ["toml"]\n  },\n  "application/trickle-ice-sdpfrag": {\n    "source": "iana"\n  },\n  "application/trig": {\n    "source": "iana"\n  },\n  "application/ttml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ttml"]\n  },\n  "application/tve-trigger": {\n    "source": "iana"\n  },\n  "application/tzif": {\n    "source": "iana"\n  },\n  "application/tzif-leap": {\n    "source": "iana"\n  },\n  "application/ubjson": {\n    "compressible": false,\n    "extensions": ["ubj"]\n  },\n  "application/ulpfec": {\n    "source": "iana"\n  },\n  "application/urc-grpsheet+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/urc-ressheet+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rsheet"]\n  },\n  "application/urc-targetdesc+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["td"]\n  },\n  "application/urc-uisocketdesc+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vcard+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vcard+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vemmi": {\n    "source": "iana"\n  },\n  "application/vividence.scriptfile": {\n    "source": "apache"\n  },\n  "application/vnd.1000minds.decision-model+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["1km"]\n  },\n  "application/vnd.3gpp-prose+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp-prose-pc3ch+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp-v2x-local-service-information": {\n    "source": "iana"\n  },\n  "application/vnd.3gpp.access-transfer-events+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.bsf+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.gmop+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mc-signalling-ear": {\n    "source": "iana"\n  },\n  "application/vnd.3gpp.mcdata-affiliation-command+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcdata-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcdata-payload": {\n    "source": "iana"\n  },\n  "application/vnd.3gpp.mcdata-service-config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcdata-signalling": {\n    "source": "iana"\n  },\n  "application/vnd.3gpp.mcdata-ue-config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcdata-user-profile+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-affiliation-command+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-floor-request+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-location-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-service-config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-signed+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-ue-config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-ue-init-config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-user-profile+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-affiliation-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-location-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-service-config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-transmission-request+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-ue-config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-user-profile+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mid-call+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.pic-bw-large": {\n    "source": "iana",\n    "extensions": ["plb"]\n  },\n  "application/vnd.3gpp.pic-bw-small": {\n    "source": "iana",\n    "extensions": ["psb"]\n  },\n  "application/vnd.3gpp.pic-bw-var": {\n    "source": "iana",\n    "extensions": ["pvb"]\n  },\n  "application/vnd.3gpp.sms": {\n    "source": "iana"\n  },\n  "application/vnd.3gpp.sms+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.srvcc-ext+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.srvcc-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.state-and-event-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.ussd+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp2.bcmcsinfo+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp2.sms": {\n    "source": "iana"\n  },\n  "application/vnd.3gpp2.tcap": {\n    "source": "iana",\n    "extensions": ["tcap"]\n  },\n  "application/vnd.3lightssoftware.imagescal": {\n    "source": "iana"\n  },\n  "application/vnd.3m.post-it-notes": {\n    "source": "iana",\n    "extensions": ["pwn"]\n  },\n  "application/vnd.accpac.simply.aso": {\n    "source": "iana",\n    "extensions": ["aso"]\n  },\n  "application/vnd.accpac.simply.imp": {\n    "source": "iana",\n    "extensions": ["imp"]\n  },\n  "application/vnd.acucobol": {\n    "source": "iana",\n    "extensions": ["acu"]\n  },\n  "application/vnd.acucorp": {\n    "source": "iana",\n    "extensions": ["atc","acutc"]\n  },\n  "application/vnd.adobe.air-application-installer-package+zip": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["air"]\n  },\n  "application/vnd.adobe.flash.movie": {\n    "source": "iana"\n  },\n  "application/vnd.adobe.formscentral.fcdt": {\n    "source": "iana",\n    "extensions": ["fcdt"]\n  },\n  "application/vnd.adobe.fxp": {\n    "source": "iana",\n    "extensions": ["fxp","fxpl"]\n  },\n  "application/vnd.adobe.partial-upload": {\n    "source": "iana"\n  },\n  "application/vnd.adobe.xdp+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xdp"]\n  },\n  "application/vnd.adobe.xfdf": {\n    "source": "iana",\n    "extensions": ["xfdf"]\n  },\n  "application/vnd.aether.imp": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.afplinedata": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.afplinedata-pagedef": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.foca-charset": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.foca-codedfont": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.foca-codepage": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.modca": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.modca-formdef": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.modca-mediummap": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.modca-objectcontainer": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.modca-overlay": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.modca-pagesegment": {\n    "source": "iana"\n  },\n  "application/vnd.ah-barcode": {\n    "source": "iana"\n  },\n  "application/vnd.ahead.space": {\n    "source": "iana",\n    "extensions": ["ahead"]\n  },\n  "application/vnd.airzip.filesecure.azf": {\n    "source": "iana",\n    "extensions": ["azf"]\n  },\n  "application/vnd.airzip.filesecure.azs": {\n    "source": "iana",\n    "extensions": ["azs"]\n  },\n  "application/vnd.amadeus+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.amazon.ebook": {\n    "source": "apache",\n    "extensions": ["azw"]\n  },\n  "application/vnd.amazon.mobi8-ebook": {\n    "source": "iana"\n  },\n  "application/vnd.americandynamics.acc": {\n    "source": "iana",\n    "extensions": ["acc"]\n  },\n  "application/vnd.amiga.ami": {\n    "source": "iana",\n    "extensions": ["ami"]\n  },\n  "application/vnd.amundsen.maze+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.android.ota": {\n    "source": "iana"\n  },\n  "application/vnd.android.package-archive": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["apk"]\n  },\n  "application/vnd.anki": {\n    "source": "iana"\n  },\n  "application/vnd.anser-web-certificate-issue-initiation": {\n    "source": "iana",\n    "extensions": ["cii"]\n  },\n  "application/vnd.anser-web-funds-transfer-initiation": {\n    "source": "apache",\n    "extensions": ["fti"]\n  },\n  "application/vnd.antix.game-component": {\n    "source": "iana",\n    "extensions": ["atx"]\n  },\n  "application/vnd.apache.thrift.binary": {\n    "source": "iana"\n  },\n  "application/vnd.apache.thrift.compact": {\n    "source": "iana"\n  },\n  "application/vnd.apache.thrift.json": {\n    "source": "iana"\n  },\n  "application/vnd.api+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.aplextor.warrp+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.apothekende.reservation+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.apple.installer+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mpkg"]\n  },\n  "application/vnd.apple.keynote": {\n    "source": "iana",\n    "extensions": ["key"]\n  },\n  "application/vnd.apple.mpegurl": {\n    "source": "iana",\n    "extensions": ["m3u8"]\n  },\n  "application/vnd.apple.numbers": {\n    "source": "iana",\n    "extensions": ["numbers"]\n  },\n  "application/vnd.apple.pages": {\n    "source": "iana",\n    "extensions": ["pages"]\n  },\n  "application/vnd.apple.pkpass": {\n    "compressible": false,\n    "extensions": ["pkpass"]\n  },\n  "application/vnd.arastra.swi": {\n    "source": "iana"\n  },\n  "application/vnd.aristanetworks.swi": {\n    "source": "iana",\n    "extensions": ["swi"]\n  },\n  "application/vnd.artisan+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.artsquare": {\n    "source": "iana"\n  },\n  "application/vnd.astraea-software.iota": {\n    "source": "iana",\n    "extensions": ["iota"]\n  },\n  "application/vnd.audiograph": {\n    "source": "iana",\n    "extensions": ["aep"]\n  },\n  "application/vnd.autopackage": {\n    "source": "iana"\n  },\n  "application/vnd.avalon+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.avistar+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.balsamiq.bmml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["bmml"]\n  },\n  "application/vnd.balsamiq.bmpr": {\n    "source": "iana"\n  },\n  "application/vnd.banana-accounting": {\n    "source": "iana"\n  },\n  "application/vnd.bbf.usp.error": {\n    "source": "iana"\n  },\n  "application/vnd.bbf.usp.msg": {\n    "source": "iana"\n  },\n  "application/vnd.bbf.usp.msg+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.bekitzur-stech+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.bint.med-content": {\n    "source": "iana"\n  },\n  "application/vnd.biopax.rdf+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.blink-idb-value-wrapper": {\n    "source": "iana"\n  },\n  "application/vnd.blueice.multipass": {\n    "source": "iana",\n    "extensions": ["mpm"]\n  },\n  "application/vnd.bluetooth.ep.oob": {\n    "source": "iana"\n  },\n  "application/vnd.bluetooth.le.oob": {\n    "source": "iana"\n  },\n  "application/vnd.bmi": {\n    "source": "iana",\n    "extensions": ["bmi"]\n  },\n  "application/vnd.bpf": {\n    "source": "iana"\n  },\n  "application/vnd.bpf3": {\n    "source": "iana"\n  },\n  "application/vnd.businessobjects": {\n    "source": "iana",\n    "extensions": ["rep"]\n  },\n  "application/vnd.byu.uapi+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.cab-jscript": {\n    "source": "iana"\n  },\n  "application/vnd.canon-cpdl": {\n    "source": "iana"\n  },\n  "application/vnd.canon-lips": {\n    "source": "iana"\n  },\n  "application/vnd.capasystems-pg+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.cendio.thinlinc.clientconf": {\n    "source": "iana"\n  },\n  "application/vnd.century-systems.tcp_stream": {\n    "source": "iana"\n  },\n  "application/vnd.chemdraw+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["cdxml"]\n  },\n  "application/vnd.chess-pgn": {\n    "source": "iana"\n  },\n  "application/vnd.chipnuts.karaoke-mmd": {\n    "source": "iana",\n    "extensions": ["mmd"]\n  },\n  "application/vnd.ciedi": {\n    "source": "iana"\n  },\n  "application/vnd.cinderella": {\n    "source": "iana",\n    "extensions": ["cdy"]\n  },\n  "application/vnd.cirpack.isdn-ext": {\n    "source": "iana"\n  },\n  "application/vnd.citationstyles.style+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["csl"]\n  },\n  "application/vnd.claymore": {\n    "source": "iana",\n    "extensions": ["cla"]\n  },\n  "application/vnd.cloanto.rp9": {\n    "source": "iana",\n    "extensions": ["rp9"]\n  },\n  "application/vnd.clonk.c4group": {\n    "source": "iana",\n    "extensions": ["c4g","c4d","c4f","c4p","c4u"]\n  },\n  "application/vnd.cluetrust.cartomobile-config": {\n    "source": "iana",\n    "extensions": ["c11amc"]\n  },\n  "application/vnd.cluetrust.cartomobile-config-pkg": {\n    "source": "iana",\n    "extensions": ["c11amz"]\n  },\n  "application/vnd.coffeescript": {\n    "source": "iana"\n  },\n  "application/vnd.collabio.xodocuments.document": {\n    "source": "iana"\n  },\n  "application/vnd.collabio.xodocuments.document-template": {\n    "source": "iana"\n  },\n  "application/vnd.collabio.xodocuments.presentation": {\n    "source": "iana"\n  },\n  "application/vnd.collabio.xodocuments.presentation-template": {\n    "source": "iana"\n  },\n  "application/vnd.collabio.xodocuments.spreadsheet": {\n    "source": "iana"\n  },\n  "application/vnd.collabio.xodocuments.spreadsheet-template": {\n    "source": "iana"\n  },\n  "application/vnd.collection+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.collection.doc+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.collection.next+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.comicbook+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.comicbook-rar": {\n    "source": "iana"\n  },\n  "application/vnd.commerce-battelle": {\n    "source": "iana"\n  },\n  "application/vnd.commonspace": {\n    "source": "iana",\n    "extensions": ["csp"]\n  },\n  "application/vnd.contact.cmsg": {\n    "source": "iana",\n    "extensions": ["cdbcmsg"]\n  },\n  "application/vnd.coreos.ignition+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.cosmocaller": {\n    "source": "iana",\n    "extensions": ["cmc"]\n  },\n  "application/vnd.crick.clicker": {\n    "source": "iana",\n    "extensions": ["clkx"]\n  },\n  "application/vnd.crick.clicker.keyboard": {\n    "source": "iana",\n    "extensions": ["clkk"]\n  },\n  "application/vnd.crick.clicker.palette": {\n    "source": "iana",\n    "extensions": ["clkp"]\n  },\n  "application/vnd.crick.clicker.template": {\n    "source": "iana",\n    "extensions": ["clkt"]\n  },\n  "application/vnd.crick.clicker.wordbank": {\n    "source": "iana",\n    "extensions": ["clkw"]\n  },\n  "application/vnd.criticaltools.wbs+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["wbs"]\n  },\n  "application/vnd.cryptii.pipe+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.crypto-shade-file": {\n    "source": "iana"\n  },\n  "application/vnd.ctc-posml": {\n    "source": "iana",\n    "extensions": ["pml"]\n  },\n  "application/vnd.ctct.ws+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.cups-pdf": {\n    "source": "iana"\n  },\n  "application/vnd.cups-postscript": {\n    "source": "iana"\n  },\n  "application/vnd.cups-ppd": {\n    "source": "iana",\n    "extensions": ["ppd"]\n  },\n  "application/vnd.cups-raster": {\n    "source": "iana"\n  },\n  "application/vnd.cups-raw": {\n    "source": "iana"\n  },\n  "application/vnd.curl": {\n    "source": "iana"\n  },\n  "application/vnd.curl.car": {\n    "source": "apache",\n    "extensions": ["car"]\n  },\n  "application/vnd.curl.pcurl": {\n    "source": "apache",\n    "extensions": ["pcurl"]\n  },\n  "application/vnd.cyan.dean.root+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.cybank": {\n    "source": "iana"\n  },\n  "application/vnd.d2l.coursepackage1p0+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.d3m-dataset": {\n    "source": "iana"\n  },\n  "application/vnd.d3m-problem": {\n    "source": "iana"\n  },\n  "application/vnd.dart": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["dart"]\n  },\n  "application/vnd.data-vision.rdz": {\n    "source": "iana",\n    "extensions": ["rdz"]\n  },\n  "application/vnd.datapackage+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dataresource+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dbf": {\n    "source": "iana",\n    "extensions": ["dbf"]\n  },\n  "application/vnd.debian.binary-package": {\n    "source": "iana"\n  },\n  "application/vnd.dece.data": {\n    "source": "iana",\n    "extensions": ["uvf","uvvf","uvd","uvvd"]\n  },\n  "application/vnd.dece.ttml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["uvt","uvvt"]\n  },\n  "application/vnd.dece.unspecified": {\n    "source": "iana",\n    "extensions": ["uvx","uvvx"]\n  },\n  "application/vnd.dece.zip": {\n    "source": "iana",\n    "extensions": ["uvz","uvvz"]\n  },\n  "application/vnd.denovo.fcselayout-link": {\n    "source": "iana",\n    "extensions": ["fe_launch"]\n  },\n  "application/vnd.desmume.movie": {\n    "source": "iana"\n  },\n  "application/vnd.dir-bi.plate-dl-nosuffix": {\n    "source": "iana"\n  },\n  "application/vnd.dm.delegation+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dna": {\n    "source": "iana",\n    "extensions": ["dna"]\n  },\n  "application/vnd.document+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dolby.mlp": {\n    "source": "apache",\n    "extensions": ["mlp"]\n  },\n  "application/vnd.dolby.mobile.1": {\n    "source": "iana"\n  },\n  "application/vnd.dolby.mobile.2": {\n    "source": "iana"\n  },\n  "application/vnd.doremir.scorecloud-binary-document": {\n    "source": "iana"\n  },\n  "application/vnd.dpgraph": {\n    "source": "iana",\n    "extensions": ["dpg"]\n  },\n  "application/vnd.dreamfactory": {\n    "source": "iana",\n    "extensions": ["dfac"]\n  },\n  "application/vnd.drive+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ds-keypoint": {\n    "source": "apache",\n    "extensions": ["kpxx"]\n  },\n  "application/vnd.dtg.local": {\n    "source": "iana"\n  },\n  "application/vnd.dtg.local.flash": {\n    "source": "iana"\n  },\n  "application/vnd.dtg.local.html": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.ait": {\n    "source": "iana",\n    "extensions": ["ait"]\n  },\n  "application/vnd.dvb.dvbisl+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.dvbj": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.esgcontainer": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.ipdcdftnotifaccess": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.ipdcesgaccess": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.ipdcesgaccess2": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.ipdcesgpdd": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.ipdcroaming": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.iptv.alfec-base": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.iptv.alfec-enhancement": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.notif-aggregate-root+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.notif-container+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.notif-generic+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.notif-ia-msglist+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.notif-ia-registration-request+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.notif-ia-registration-response+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.notif-init+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.pfr": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.service": {\n    "source": "iana",\n    "extensions": ["svc"]\n  },\n  "application/vnd.dxr": {\n    "source": "iana"\n  },\n  "application/vnd.dynageo": {\n    "source": "iana",\n    "extensions": ["geo"]\n  },\n  "application/vnd.dzr": {\n    "source": "iana"\n  },\n  "application/vnd.easykaraoke.cdgdownload": {\n    "source": "iana"\n  },\n  "application/vnd.ecdis-update": {\n    "source": "iana"\n  },\n  "application/vnd.ecip.rlp": {\n    "source": "iana"\n  },\n  "application/vnd.ecowin.chart": {\n    "source": "iana",\n    "extensions": ["mag"]\n  },\n  "application/vnd.ecowin.filerequest": {\n    "source": "iana"\n  },\n  "application/vnd.ecowin.fileupdate": {\n    "source": "iana"\n  },\n  "application/vnd.ecowin.series": {\n    "source": "iana"\n  },\n  "application/vnd.ecowin.seriesrequest": {\n    "source": "iana"\n  },\n  "application/vnd.ecowin.seriesupdate": {\n    "source": "iana"\n  },\n  "application/vnd.efi.img": {\n    "source": "iana"\n  },\n  "application/vnd.efi.iso": {\n    "source": "iana"\n  },\n  "application/vnd.emclient.accessrequest+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.enliven": {\n    "source": "iana",\n    "extensions": ["nml"]\n  },\n  "application/vnd.enphase.envoy": {\n    "source": "iana"\n  },\n  "application/vnd.eprints.data+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.epson.esf": {\n    "source": "iana",\n    "extensions": ["esf"]\n  },\n  "application/vnd.epson.msf": {\n    "source": "iana",\n    "extensions": ["msf"]\n  },\n  "application/vnd.epson.quickanime": {\n    "source": "iana",\n    "extensions": ["qam"]\n  },\n  "application/vnd.epson.salt": {\n    "source": "iana",\n    "extensions": ["slt"]\n  },\n  "application/vnd.epson.ssf": {\n    "source": "iana",\n    "extensions": ["ssf"]\n  },\n  "application/vnd.ericsson.quickcall": {\n    "source": "iana"\n  },\n  "application/vnd.espass-espass+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.eszigno3+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["es3","et3"]\n  },\n  "application/vnd.etsi.aoc+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.asic-e+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.etsi.asic-s+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.etsi.cug+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvcommand+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvdiscovery+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvprofile+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvsad-bc+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvsad-cod+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvsad-npvr+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvservice+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvsync+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvueprofile+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.mcid+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.mheg5": {\n    "source": "iana"\n  },\n  "application/vnd.etsi.overload-control-policy-dataset+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.pstn+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.sci+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.simservs+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.timestamp-token": {\n    "source": "iana"\n  },\n  "application/vnd.etsi.tsl+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.tsl.der": {\n    "source": "iana"\n  },\n  "application/vnd.eudora.data": {\n    "source": "iana"\n  },\n  "application/vnd.evolv.ecig.profile": {\n    "source": "iana"\n  },\n  "application/vnd.evolv.ecig.settings": {\n    "source": "iana"\n  },\n  "application/vnd.evolv.ecig.theme": {\n    "source": "iana"\n  },\n  "application/vnd.exstream-empower+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.exstream-package": {\n    "source": "iana"\n  },\n  "application/vnd.ezpix-album": {\n    "source": "iana",\n    "extensions": ["ez2"]\n  },\n  "application/vnd.ezpix-package": {\n    "source": "iana",\n    "extensions": ["ez3"]\n  },\n  "application/vnd.f-secure.mobile": {\n    "source": "iana"\n  },\n  "application/vnd.fastcopy-disk-image": {\n    "source": "iana"\n  },\n  "application/vnd.fdf": {\n    "source": "iana",\n    "extensions": ["fdf"]\n  },\n  "application/vnd.fdsn.mseed": {\n    "source": "iana",\n    "extensions": ["mseed"]\n  },\n  "application/vnd.fdsn.seed": {\n    "source": "iana",\n    "extensions": ["seed","dataless"]\n  },\n  "application/vnd.ffsns": {\n    "source": "iana"\n  },\n  "application/vnd.ficlab.flb+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.filmit.zfc": {\n    "source": "iana"\n  },\n  "application/vnd.fints": {\n    "source": "iana"\n  },\n  "application/vnd.firemonkeys.cloudcell": {\n    "source": "iana"\n  },\n  "application/vnd.flographit": {\n    "source": "iana",\n    "extensions": ["gph"]\n  },\n  "application/vnd.fluxtime.clip": {\n    "source": "iana",\n    "extensions": ["ftc"]\n  },\n  "application/vnd.font-fontforge-sfd": {\n    "source": "iana"\n  },\n  "application/vnd.framemaker": {\n    "source": "iana",\n    "extensions": ["fm","frame","maker","book"]\n  },\n  "application/vnd.frogans.fnc": {\n    "source": "iana",\n    "extensions": ["fnc"]\n  },\n  "application/vnd.frogans.ltf": {\n    "source": "iana",\n    "extensions": ["ltf"]\n  },\n  "application/vnd.fsc.weblaunch": {\n    "source": "iana",\n    "extensions": ["fsc"]\n  },\n  "application/vnd.fujitsu.oasys": {\n    "source": "iana",\n    "extensions": ["oas"]\n  },\n  "application/vnd.fujitsu.oasys2": {\n    "source": "iana",\n    "extensions": ["oa2"]\n  },\n  "application/vnd.fujitsu.oasys3": {\n    "source": "iana",\n    "extensions": ["oa3"]\n  },\n  "application/vnd.fujitsu.oasysgp": {\n    "source": "iana",\n    "extensions": ["fg5"]\n  },\n  "application/vnd.fujitsu.oasysprs": {\n    "source": "iana",\n    "extensions": ["bh2"]\n  },\n  "application/vnd.fujixerox.art-ex": {\n    "source": "iana"\n  },\n  "application/vnd.fujixerox.art4": {\n    "source": "iana"\n  },\n  "application/vnd.fujixerox.ddd": {\n    "source": "iana",\n    "extensions": ["ddd"]\n  },\n  "application/vnd.fujixerox.docuworks": {\n    "source": "iana",\n    "extensions": ["xdw"]\n  },\n  "application/vnd.fujixerox.docuworks.binder": {\n    "source": "iana",\n    "extensions": ["xbd"]\n  },\n  "application/vnd.fujixerox.docuworks.container": {\n    "source": "iana"\n  },\n  "application/vnd.fujixerox.hbpl": {\n    "source": "iana"\n  },\n  "application/vnd.fut-misnet": {\n    "source": "iana"\n  },\n  "application/vnd.futoin+cbor": {\n    "source": "iana"\n  },\n  "application/vnd.futoin+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.fuzzysheet": {\n    "source": "iana",\n    "extensions": ["fzs"]\n  },\n  "application/vnd.genomatix.tuxedo": {\n    "source": "iana",\n    "extensions": ["txd"]\n  },\n  "application/vnd.gentics.grd+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.geo+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.geocube+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.geogebra.file": {\n    "source": "iana",\n    "extensions": ["ggb"]\n  },\n  "application/vnd.geogebra.tool": {\n    "source": "iana",\n    "extensions": ["ggt"]\n  },\n  "application/vnd.geometry-explorer": {\n    "source": "iana",\n    "extensions": ["gex","gre"]\n  },\n  "application/vnd.geonext": {\n    "source": "iana",\n    "extensions": ["gxt"]\n  },\n  "application/vnd.geoplan": {\n    "source": "iana",\n    "extensions": ["g2w"]\n  },\n  "application/vnd.geospace": {\n    "source": "iana",\n    "extensions": ["g3w"]\n  },\n  "application/vnd.gerber": {\n    "source": "iana"\n  },\n  "application/vnd.globalplatform.card-content-mgt": {\n    "source": "iana"\n  },\n  "application/vnd.globalplatform.card-content-mgt-response": {\n    "source": "iana"\n  },\n  "application/vnd.gmx": {\n    "source": "iana",\n    "extensions": ["gmx"]\n  },\n  "application/vnd.google-apps.document": {\n    "compressible": false,\n    "extensions": ["gdoc"]\n  },\n  "application/vnd.google-apps.presentation": {\n    "compressible": false,\n    "extensions": ["gslides"]\n  },\n  "application/vnd.google-apps.spreadsheet": {\n    "compressible": false,\n    "extensions": ["gsheet"]\n  },\n  "application/vnd.google-earth.kml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["kml"]\n  },\n  "application/vnd.google-earth.kmz": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["kmz"]\n  },\n  "application/vnd.gov.sk.e-form+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.gov.sk.e-form+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.gov.sk.xmldatacontainer+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.grafeq": {\n    "source": "iana",\n    "extensions": ["gqf","gqs"]\n  },\n  "application/vnd.gridmp": {\n    "source": "iana"\n  },\n  "application/vnd.groove-account": {\n    "source": "iana",\n    "extensions": ["gac"]\n  },\n  "application/vnd.groove-help": {\n    "source": "iana",\n    "extensions": ["ghf"]\n  },\n  "application/vnd.groove-identity-message": {\n    "source": "iana",\n    "extensions": ["gim"]\n  },\n  "application/vnd.groove-injector": {\n    "source": "iana",\n    "extensions": ["grv"]\n  },\n  "application/vnd.groove-tool-message": {\n    "source": "iana",\n    "extensions": ["gtm"]\n  },\n  "application/vnd.groove-tool-template": {\n    "source": "iana",\n    "extensions": ["tpl"]\n  },\n  "application/vnd.groove-vcard": {\n    "source": "iana",\n    "extensions": ["vcg"]\n  },\n  "application/vnd.hal+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.hal+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["hal"]\n  },\n  "application/vnd.handheld-entertainment+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["zmm"]\n  },\n  "application/vnd.hbci": {\n    "source": "iana",\n    "extensions": ["hbci"]\n  },\n  "application/vnd.hc+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.hcl-bireports": {\n    "source": "iana"\n  },\n  "application/vnd.hdt": {\n    "source": "iana"\n  },\n  "application/vnd.heroku+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.hhe.lesson-player": {\n    "source": "iana",\n    "extensions": ["les"]\n  },\n  "application/vnd.hp-hpgl": {\n    "source": "iana",\n    "extensions": ["hpgl"]\n  },\n  "application/vnd.hp-hpid": {\n    "source": "iana",\n    "extensions": ["hpid"]\n  },\n  "application/vnd.hp-hps": {\n    "source": "iana",\n    "extensions": ["hps"]\n  },\n  "application/vnd.hp-jlyt": {\n    "source": "iana",\n    "extensions": ["jlt"]\n  },\n  "application/vnd.hp-pcl": {\n    "source": "iana",\n    "extensions": ["pcl"]\n  },\n  "application/vnd.hp-pclxl": {\n    "source": "iana",\n    "extensions": ["pclxl"]\n  },\n  "application/vnd.httphone": {\n    "source": "iana"\n  },\n  "application/vnd.hydrostatix.sof-data": {\n    "source": "iana",\n    "extensions": ["sfd-hdstx"]\n  },\n  "application/vnd.hyper+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.hyper-item+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.hyperdrive+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.hzn-3d-crossword": {\n    "source": "iana"\n  },\n  "application/vnd.ibm.afplinedata": {\n    "source": "iana"\n  },\n  "application/vnd.ibm.electronic-media": {\n    "source": "iana"\n  },\n  "application/vnd.ibm.minipay": {\n    "source": "iana",\n    "extensions": ["mpy"]\n  },\n  "application/vnd.ibm.modcap": {\n    "source": "iana",\n    "extensions": ["afp","listafp","list3820"]\n  },\n  "application/vnd.ibm.rights-management": {\n    "source": "iana",\n    "extensions": ["irm"]\n  },\n  "application/vnd.ibm.secure-container": {\n    "source": "iana",\n    "extensions": ["sc"]\n  },\n  "application/vnd.iccprofile": {\n    "source": "iana",\n    "extensions": ["icc","icm"]\n  },\n  "application/vnd.ieee.1905": {\n    "source": "iana"\n  },\n  "application/vnd.igloader": {\n    "source": "iana",\n    "extensions": ["igl"]\n  },\n  "application/vnd.imagemeter.folder+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.imagemeter.image+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.immervision-ivp": {\n    "source": "iana",\n    "extensions": ["ivp"]\n  },\n  "application/vnd.immervision-ivu": {\n    "source": "iana",\n    "extensions": ["ivu"]\n  },\n  "application/vnd.ims.imsccv1p1": {\n    "source": "iana"\n  },\n  "application/vnd.ims.imsccv1p2": {\n    "source": "iana"\n  },\n  "application/vnd.ims.imsccv1p3": {\n    "source": "iana"\n  },\n  "application/vnd.ims.lis.v2.result+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ims.lti.v2.toolproxy+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ims.lti.v2.toolproxy.id+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ims.lti.v2.toolsettings+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ims.lti.v2.toolsettings.simple+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.informedcontrol.rms+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.informix-visionary": {\n    "source": "iana"\n  },\n  "application/vnd.infotech.project": {\n    "source": "iana"\n  },\n  "application/vnd.infotech.project+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.innopath.wamp.notification": {\n    "source": "iana"\n  },\n  "application/vnd.insors.igm": {\n    "source": "iana",\n    "extensions": ["igm"]\n  },\n  "application/vnd.intercon.formnet": {\n    "source": "iana",\n    "extensions": ["xpw","xpx"]\n  },\n  "application/vnd.intergeo": {\n    "source": "iana",\n    "extensions": ["i2g"]\n  },\n  "application/vnd.intertrust.digibox": {\n    "source": "iana"\n  },\n  "application/vnd.intertrust.nncp": {\n    "source": "iana"\n  },\n  "application/vnd.intu.qbo": {\n    "source": "iana",\n    "extensions": ["qbo"]\n  },\n  "application/vnd.intu.qfx": {\n    "source": "iana",\n    "extensions": ["qfx"]\n  },\n  "application/vnd.iptc.g2.catalogitem+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.iptc.g2.conceptitem+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.iptc.g2.knowledgeitem+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.iptc.g2.newsitem+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.iptc.g2.newsmessage+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.iptc.g2.packageitem+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.iptc.g2.planningitem+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ipunplugged.rcprofile": {\n    "source": "iana",\n    "extensions": ["rcprofile"]\n  },\n  "application/vnd.irepository.package+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["irp"]\n  },\n  "application/vnd.is-xpr": {\n    "source": "iana",\n    "extensions": ["xpr"]\n  },\n  "application/vnd.isac.fcs": {\n    "source": "iana",\n    "extensions": ["fcs"]\n  },\n  "application/vnd.iso11783-10+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.jam": {\n    "source": "iana",\n    "extensions": ["jam"]\n  },\n  "application/vnd.japannet-directory-service": {\n    "source": "iana"\n  },\n  "application/vnd.japannet-jpnstore-wakeup": {\n    "source": "iana"\n  },\n  "application/vnd.japannet-payment-wakeup": {\n    "source": "iana"\n  },\n  "application/vnd.japannet-registration": {\n    "source": "iana"\n  },\n  "application/vnd.japannet-registration-wakeup": {\n    "source": "iana"\n  },\n  "application/vnd.japannet-setstore-wakeup": {\n    "source": "iana"\n  },\n  "application/vnd.japannet-verification": {\n    "source": "iana"\n  },\n  "application/vnd.japannet-verification-wakeup": {\n    "source": "iana"\n  },\n  "application/vnd.jcp.javame.midlet-rms": {\n    "source": "iana",\n    "extensions": ["rms"]\n  },\n  "application/vnd.jisp": {\n    "source": "iana",\n    "extensions": ["jisp"]\n  },\n  "application/vnd.joost.joda-archive": {\n    "source": "iana",\n    "extensions": ["joda"]\n  },\n  "application/vnd.jsk.isdn-ngn": {\n    "source": "iana"\n  },\n  "application/vnd.kahootz": {\n    "source": "iana",\n    "extensions": ["ktz","ktr"]\n  },\n  "application/vnd.kde.karbon": {\n    "source": "iana",\n    "extensions": ["karbon"]\n  },\n  "application/vnd.kde.kchart": {\n    "source": "iana",\n    "extensions": ["chrt"]\n  },\n  "application/vnd.kde.kformula": {\n    "source": "iana",\n    "extensions": ["kfo"]\n  },\n  "application/vnd.kde.kivio": {\n    "source": "iana",\n    "extensions": ["flw"]\n  },\n  "application/vnd.kde.kontour": {\n    "source": "iana",\n    "extensions": ["kon"]\n  },\n  "application/vnd.kde.kpresenter": {\n    "source": "iana",\n    "extensions": ["kpr","kpt"]\n  },\n  "application/vnd.kde.kspread": {\n    "source": "iana",\n    "extensions": ["ksp"]\n  },\n  "application/vnd.kde.kword": {\n    "source": "iana",\n    "extensions": ["kwd","kwt"]\n  },\n  "application/vnd.kenameaapp": {\n    "source": "iana",\n    "extensions": ["htke"]\n  },\n  "application/vnd.kidspiration": {\n    "source": "iana",\n    "extensions": ["kia"]\n  },\n  "application/vnd.kinar": {\n    "source": "iana",\n    "extensions": ["kne","knp"]\n  },\n  "application/vnd.koan": {\n    "source": "iana",\n    "extensions": ["skp","skd","skt","skm"]\n  },\n  "application/vnd.kodak-descriptor": {\n    "source": "iana",\n    "extensions": ["sse"]\n  },\n  "application/vnd.las": {\n    "source": "iana"\n  },\n  "application/vnd.las.las+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.las.las+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["lasxml"]\n  },\n  "application/vnd.laszip": {\n    "source": "iana"\n  },\n  "application/vnd.leap+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.liberty-request+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.llamagraphics.life-balance.desktop": {\n    "source": "iana",\n    "extensions": ["lbd"]\n  },\n  "application/vnd.llamagraphics.life-balance.exchange+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["lbe"]\n  },\n  "application/vnd.logipipe.circuit+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.loom": {\n    "source": "iana"\n  },\n  "application/vnd.lotus-1-2-3": {\n    "source": "iana",\n    "extensions": ["123"]\n  },\n  "application/vnd.lotus-approach": {\n    "source": "iana",\n    "extensions": ["apr"]\n  },\n  "application/vnd.lotus-freelance": {\n    "source": "iana",\n    "extensions": ["pre"]\n  },\n  "application/vnd.lotus-notes": {\n    "source": "iana",\n    "extensions": ["nsf"]\n  },\n  "application/vnd.lotus-organizer": {\n    "source": "iana",\n    "extensions": ["org"]\n  },\n  "application/vnd.lotus-screencam": {\n    "source": "iana",\n    "extensions": ["scm"]\n  },\n  "application/vnd.lotus-wordpro": {\n    "source": "iana",\n    "extensions": ["lwp"]\n  },\n  "application/vnd.macports.portpkg": {\n    "source": "iana",\n    "extensions": ["portpkg"]\n  },\n  "application/vnd.mapbox-vector-tile": {\n    "source": "iana"\n  },\n  "application/vnd.marlin.drm.actiontoken+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.marlin.drm.conftoken+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.marlin.drm.license+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.marlin.drm.mdcf": {\n    "source": "iana"\n  },\n  "application/vnd.mason+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.maxmind.maxmind-db": {\n    "source": "iana"\n  },\n  "application/vnd.mcd": {\n    "source": "iana",\n    "extensions": ["mcd"]\n  },\n  "application/vnd.medcalcdata": {\n    "source": "iana",\n    "extensions": ["mc1"]\n  },\n  "application/vnd.mediastation.cdkey": {\n    "source": "iana",\n    "extensions": ["cdkey"]\n  },\n  "application/vnd.meridian-slingshot": {\n    "source": "iana"\n  },\n  "application/vnd.mfer": {\n    "source": "iana",\n    "extensions": ["mwf"]\n  },\n  "application/vnd.mfmp": {\n    "source": "iana",\n    "extensions": ["mfm"]\n  },\n  "application/vnd.micro+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.micrografx.flo": {\n    "source": "iana",\n    "extensions": ["flo"]\n  },\n  "application/vnd.micrografx.igx": {\n    "source": "iana",\n    "extensions": ["igx"]\n  },\n  "application/vnd.microsoft.portable-executable": {\n    "source": "iana"\n  },\n  "application/vnd.microsoft.windows.thumbnail-cache": {\n    "source": "iana"\n  },\n  "application/vnd.miele+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.mif": {\n    "source": "iana",\n    "extensions": ["mif"]\n  },\n  "application/vnd.minisoft-hp3000-save": {\n    "source": "iana"\n  },\n  "application/vnd.mitsubishi.misty-guard.trustweb": {\n    "source": "iana"\n  },\n  "application/vnd.mobius.daf": {\n    "source": "iana",\n    "extensions": ["daf"]\n  },\n  "application/vnd.mobius.dis": {\n    "source": "iana",\n    "extensions": ["dis"]\n  },\n  "application/vnd.mobius.mbk": {\n    "source": "iana",\n    "extensions": ["mbk"]\n  },\n  "application/vnd.mobius.mqy": {\n    "source": "iana",\n    "extensions": ["mqy"]\n  },\n  "application/vnd.mobius.msl": {\n    "source": "iana",\n    "extensions": ["msl"]\n  },\n  "application/vnd.mobius.plc": {\n    "source": "iana",\n    "extensions": ["plc"]\n  },\n  "application/vnd.mobius.txf": {\n    "source": "iana",\n    "extensions": ["txf"]\n  },\n  "application/vnd.mophun.application": {\n    "source": "iana",\n    "extensions": ["mpn"]\n  },\n  "application/vnd.mophun.certificate": {\n    "source": "iana",\n    "extensions": ["mpc"]\n  },\n  "application/vnd.motorola.flexsuite": {\n    "source": "iana"\n  },\n  "application/vnd.motorola.flexsuite.adsi": {\n    "source": "iana"\n  },\n  "application/vnd.motorola.flexsuite.fis": {\n    "source": "iana"\n  },\n  "application/vnd.motorola.flexsuite.gotap": {\n    "source": "iana"\n  },\n  "application/vnd.motorola.flexsuite.kmr": {\n    "source": "iana"\n  },\n  "application/vnd.motorola.flexsuite.ttc": {\n    "source": "iana"\n  },\n  "application/vnd.motorola.flexsuite.wem": {\n    "source": "iana"\n  },\n  "application/vnd.motorola.iprm": {\n    "source": "iana"\n  },\n  "application/vnd.mozilla.xul+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xul"]\n  },\n  "application/vnd.ms-3mfdocument": {\n    "source": "iana"\n  },\n  "application/vnd.ms-artgalry": {\n    "source": "iana",\n    "extensions": ["cil"]\n  },\n  "application/vnd.ms-asf": {\n    "source": "iana"\n  },\n  "application/vnd.ms-cab-compressed": {\n    "source": "iana",\n    "extensions": ["cab"]\n  },\n  "application/vnd.ms-color.iccprofile": {\n    "source": "apache"\n  },\n  "application/vnd.ms-excel": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["xls","xlm","xla","xlc","xlt","xlw"]\n  },\n  "application/vnd.ms-excel.addin.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["xlam"]\n  },\n  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["xlsb"]\n  },\n  "application/vnd.ms-excel.sheet.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["xlsm"]\n  },\n  "application/vnd.ms-excel.template.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["xltm"]\n  },\n  "application/vnd.ms-fontobject": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["eot"]\n  },\n  "application/vnd.ms-htmlhelp": {\n    "source": "iana",\n    "extensions": ["chm"]\n  },\n  "application/vnd.ms-ims": {\n    "source": "iana",\n    "extensions": ["ims"]\n  },\n  "application/vnd.ms-lrm": {\n    "source": "iana",\n    "extensions": ["lrm"]\n  },\n  "application/vnd.ms-office.activex+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ms-officetheme": {\n    "source": "iana",\n    "extensions": ["thmx"]\n  },\n  "application/vnd.ms-opentype": {\n    "source": "apache",\n    "compressible": true\n  },\n  "application/vnd.ms-outlook": {\n    "compressible": false,\n    "extensions": ["msg"]\n  },\n  "application/vnd.ms-package.obfuscated-opentype": {\n    "source": "apache"\n  },\n  "application/vnd.ms-pki.seccat": {\n    "source": "apache",\n    "extensions": ["cat"]\n  },\n  "application/vnd.ms-pki.stl": {\n    "source": "apache",\n    "extensions": ["stl"]\n  },\n  "application/vnd.ms-playready.initiator+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ms-powerpoint": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["ppt","pps","pot"]\n  },\n  "application/vnd.ms-powerpoint.addin.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["ppam"]\n  },\n  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["pptm"]\n  },\n  "application/vnd.ms-powerpoint.slide.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["sldm"]\n  },\n  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["ppsm"]\n  },\n  "application/vnd.ms-powerpoint.template.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["potm"]\n  },\n  "application/vnd.ms-printdevicecapabilities+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ms-printing.printticket+xml": {\n    "source": "apache",\n    "compressible": true\n  },\n  "application/vnd.ms-printschematicket+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ms-project": {\n    "source": "iana",\n    "extensions": ["mpp","mpt"]\n  },\n  "application/vnd.ms-tnef": {\n    "source": "iana"\n  },\n  "application/vnd.ms-windows.devicepairing": {\n    "source": "iana"\n  },\n  "application/vnd.ms-windows.nwprinting.oob": {\n    "source": "iana"\n  },\n  "application/vnd.ms-windows.printerpairing": {\n    "source": "iana"\n  },\n  "application/vnd.ms-windows.wsd.oob": {\n    "source": "iana"\n  },\n  "application/vnd.ms-wmdrm.lic-chlg-req": {\n    "source": "iana"\n  },\n  "application/vnd.ms-wmdrm.lic-resp": {\n    "source": "iana"\n  },\n  "application/vnd.ms-wmdrm.meter-chlg-req": {\n    "source": "iana"\n  },\n  "application/vnd.ms-wmdrm.meter-resp": {\n    "source": "iana"\n  },\n  "application/vnd.ms-word.document.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["docm"]\n  },\n  "application/vnd.ms-word.template.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["dotm"]\n  },\n  "application/vnd.ms-works": {\n    "source": "iana",\n    "extensions": ["wps","wks","wcm","wdb"]\n  },\n  "application/vnd.ms-wpl": {\n    "source": "iana",\n    "extensions": ["wpl"]\n  },\n  "application/vnd.ms-xpsdocument": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["xps"]\n  },\n  "application/vnd.msa-disk-image": {\n    "source": "iana"\n  },\n  "application/vnd.mseq": {\n    "source": "iana",\n    "extensions": ["mseq"]\n  },\n  "application/vnd.msign": {\n    "source": "iana"\n  },\n  "application/vnd.multiad.creator": {\n    "source": "iana"\n  },\n  "application/vnd.multiad.creator.cif": {\n    "source": "iana"\n  },\n  "application/vnd.music-niff": {\n    "source": "iana"\n  },\n  "application/vnd.musician": {\n    "source": "iana",\n    "extensions": ["mus"]\n  },\n  "application/vnd.muvee.style": {\n    "source": "iana",\n    "extensions": ["msty"]\n  },\n  "application/vnd.mynfc": {\n    "source": "iana",\n    "extensions": ["taglet"]\n  },\n  "application/vnd.ncd.control": {\n    "source": "iana"\n  },\n  "application/vnd.ncd.reference": {\n    "source": "iana"\n  },\n  "application/vnd.nearst.inv+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.nervana": {\n    "source": "iana"\n  },\n  "application/vnd.netfpx": {\n    "source": "iana"\n  },\n  "application/vnd.neurolanguage.nlu": {\n    "source": "iana",\n    "extensions": ["nlu"]\n  },\n  "application/vnd.nimn": {\n    "source": "iana"\n  },\n  "application/vnd.nintendo.nitro.rom": {\n    "source": "iana"\n  },\n  "application/vnd.nintendo.snes.rom": {\n    "source": "iana"\n  },\n  "application/vnd.nitf": {\n    "source": "iana",\n    "extensions": ["ntf","nitf"]\n  },\n  "application/vnd.noblenet-directory": {\n    "source": "iana",\n    "extensions": ["nnd"]\n  },\n  "application/vnd.noblenet-sealer": {\n    "source": "iana",\n    "extensions": ["nns"]\n  },\n  "application/vnd.noblenet-web": {\n    "source": "iana",\n    "extensions": ["nnw"]\n  },\n  "application/vnd.nokia.catalogs": {\n    "source": "iana"\n  },\n  "application/vnd.nokia.conml+wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.nokia.conml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.nokia.iptv.config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.nokia.isds-radio-presets": {\n    "source": "iana"\n  },\n  "application/vnd.nokia.landmark+wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.nokia.landmark+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.nokia.landmarkcollection+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.nokia.n-gage.ac+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ac"]\n  },\n  "application/vnd.nokia.n-gage.data": {\n    "source": "iana",\n    "extensions": ["ngdat"]\n  },\n  "application/vnd.nokia.n-gage.symbian.install": {\n    "source": "iana",\n    "extensions": ["n-gage"]\n  },\n  "application/vnd.nokia.ncd": {\n    "source": "iana"\n  },\n  "application/vnd.nokia.pcd+wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.nokia.pcd+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.nokia.radio-preset": {\n    "source": "iana",\n    "extensions": ["rpst"]\n  },\n  "application/vnd.nokia.radio-presets": {\n    "source": "iana",\n    "extensions": ["rpss"]\n  },\n  "application/vnd.novadigm.edm": {\n    "source": "iana",\n    "extensions": ["edm"]\n  },\n  "application/vnd.novadigm.edx": {\n    "source": "iana",\n    "extensions": ["edx"]\n  },\n  "application/vnd.novadigm.ext": {\n    "source": "iana",\n    "extensions": ["ext"]\n  },\n  "application/vnd.ntt-local.content-share": {\n    "source": "iana"\n  },\n  "application/vnd.ntt-local.file-transfer": {\n    "source": "iana"\n  },\n  "application/vnd.ntt-local.ogw_remote-access": {\n    "source": "iana"\n  },\n  "application/vnd.ntt-local.sip-ta_remote": {\n    "source": "iana"\n  },\n  "application/vnd.ntt-local.sip-ta_tcp_stream": {\n    "source": "iana"\n  },\n  "application/vnd.oasis.opendocument.chart": {\n    "source": "iana",\n    "extensions": ["odc"]\n  },\n  "application/vnd.oasis.opendocument.chart-template": {\n    "source": "iana",\n    "extensions": ["otc"]\n  },\n  "application/vnd.oasis.opendocument.database": {\n    "source": "iana",\n    "extensions": ["odb"]\n  },\n  "application/vnd.oasis.opendocument.formula": {\n    "source": "iana",\n    "extensions": ["odf"]\n  },\n  "application/vnd.oasis.opendocument.formula-template": {\n    "source": "iana",\n    "extensions": ["odft"]\n  },\n  "application/vnd.oasis.opendocument.graphics": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["odg"]\n  },\n  "application/vnd.oasis.opendocument.graphics-template": {\n    "source": "iana",\n    "extensions": ["otg"]\n  },\n  "application/vnd.oasis.opendocument.image": {\n    "source": "iana",\n    "extensions": ["odi"]\n  },\n  "application/vnd.oasis.opendocument.image-template": {\n    "source": "iana",\n    "extensions": ["oti"]\n  },\n  "application/vnd.oasis.opendocument.presentation": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["odp"]\n  },\n  "application/vnd.oasis.opendocument.presentation-template": {\n    "source": "iana",\n    "extensions": ["otp"]\n  },\n  "application/vnd.oasis.opendocument.spreadsheet": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["ods"]\n  },\n  "application/vnd.oasis.opendocument.spreadsheet-template": {\n    "source": "iana",\n    "extensions": ["ots"]\n  },\n  "application/vnd.oasis.opendocument.text": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["odt"]\n  },\n  "application/vnd.oasis.opendocument.text-master": {\n    "source": "iana",\n    "extensions": ["odm"]\n  },\n  "application/vnd.oasis.opendocument.text-template": {\n    "source": "iana",\n    "extensions": ["ott"]\n  },\n  "application/vnd.oasis.opendocument.text-web": {\n    "source": "iana",\n    "extensions": ["oth"]\n  },\n  "application/vnd.obn": {\n    "source": "iana"\n  },\n  "application/vnd.ocf+cbor": {\n    "source": "iana"\n  },\n  "application/vnd.oci.image.manifest.v1+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oftn.l10n+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.contentaccessdownload+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.contentaccessstreaming+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.cspg-hexbinary": {\n    "source": "iana"\n  },\n  "application/vnd.oipf.dae.svg+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.dae.xhtml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.mippvcontrolmessage+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.pae.gem": {\n    "source": "iana"\n  },\n  "application/vnd.oipf.spdiscovery+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.spdlist+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.ueprofile+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.userprofile+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.olpc-sugar": {\n    "source": "iana",\n    "extensions": ["xo"]\n  },\n  "application/vnd.oma-scws-config": {\n    "source": "iana"\n  },\n  "application/vnd.oma-scws-http-request": {\n    "source": "iana"\n  },\n  "application/vnd.oma-scws-http-response": {\n    "source": "iana"\n  },\n  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.bcast.drm-trigger+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.bcast.imd+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.bcast.ltkm": {\n    "source": "iana"\n  },\n  "application/vnd.oma.bcast.notification+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.bcast.provisioningtrigger": {\n    "source": "iana"\n  },\n  "application/vnd.oma.bcast.sgboot": {\n    "source": "iana"\n  },\n  "application/vnd.oma.bcast.sgdd+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.bcast.sgdu": {\n    "source": "iana"\n  },\n  "application/vnd.oma.bcast.simple-symbol-container": {\n    "source": "iana"\n  },\n  "application/vnd.oma.bcast.smartcard-trigger+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.bcast.sprov+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.bcast.stkm": {\n    "source": "iana"\n  },\n  "application/vnd.oma.cab-address-book+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.cab-feature-handler+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.cab-pcc+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.cab-subs-invite+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.cab-user-prefs+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.dcd": {\n    "source": "iana"\n  },\n  "application/vnd.oma.dcdc": {\n    "source": "iana"\n  },\n  "application/vnd.oma.dd2+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["dd2"]\n  },\n  "application/vnd.oma.drm.risd+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.group-usage-list+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.lwm2m+cbor": {\n    "source": "iana"\n  },\n  "application/vnd.oma.lwm2m+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.lwm2m+tlv": {\n    "source": "iana"\n  },\n  "application/vnd.oma.pal+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.poc.detailed-progress-report+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.poc.final-report+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.poc.groups+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.poc.invocation-descriptor+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.poc.optimized-progress-report+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.push": {\n    "source": "iana"\n  },\n  "application/vnd.oma.scidm.messages+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.xcap-directory+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.omads-email+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/vnd.omads-file+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/vnd.omads-folder+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/vnd.omaloc-supl-init": {\n    "source": "iana"\n  },\n  "application/vnd.onepager": {\n    "source": "iana"\n  },\n  "application/vnd.onepagertamp": {\n    "source": "iana"\n  },\n  "application/vnd.onepagertamx": {\n    "source": "iana"\n  },\n  "application/vnd.onepagertat": {\n    "source": "iana"\n  },\n  "application/vnd.onepagertatp": {\n    "source": "iana"\n  },\n  "application/vnd.onepagertatx": {\n    "source": "iana"\n  },\n  "application/vnd.openblox.game+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["obgx"]\n  },\n  "application/vnd.openblox.game-binary": {\n    "source": "iana"\n  },\n  "application/vnd.openeye.oeb": {\n    "source": "iana"\n  },\n  "application/vnd.openofficeorg.extension": {\n    "source": "apache",\n    "extensions": ["oxt"]\n  },\n  "application/vnd.openstreetmap.data+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["osm"]\n  },\n  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.drawing+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["pptx"]\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.slide": {\n    "source": "iana",\n    "extensions": ["sldx"]\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {\n    "source": "iana",\n    "extensions": ["ppsx"]\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.template": {\n    "source": "iana",\n    "extensions": ["potx"]\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["xlsx"]\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {\n    "source": "iana",\n    "extensions": ["xltx"]\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.theme+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.vmldrawing": {\n    "source": "iana"\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["docx"]\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {\n    "source": "iana",\n    "extensions": ["dotx"]\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-package.core-properties+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-package.relationships+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oracle.resource+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.orange.indata": {\n    "source": "iana"\n  },\n  "application/vnd.osa.netdeploy": {\n    "source": "iana"\n  },\n  "application/vnd.osgeo.mapguide.package": {\n    "source": "iana",\n    "extensions": ["mgp"]\n  },\n  "application/vnd.osgi.bundle": {\n    "source": "iana"\n  },\n  "application/vnd.osgi.dp": {\n    "source": "iana",\n    "extensions": ["dp"]\n  },\n  "application/vnd.osgi.subsystem": {\n    "source": "iana",\n    "extensions": ["esa"]\n  },\n  "application/vnd.otps.ct-kip+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oxli.countgraph": {\n    "source": "iana"\n  },\n  "application/vnd.pagerduty+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.palm": {\n    "source": "iana",\n    "extensions": ["pdb","pqa","oprc"]\n  },\n  "application/vnd.panoply": {\n    "source": "iana"\n  },\n  "application/vnd.paos.xml": {\n    "source": "iana"\n  },\n  "application/vnd.patentdive": {\n    "source": "iana"\n  },\n  "application/vnd.patientecommsdoc": {\n    "source": "iana"\n  },\n  "application/vnd.pawaafile": {\n    "source": "iana",\n    "extensions": ["paw"]\n  },\n  "application/vnd.pcos": {\n    "source": "iana"\n  },\n  "application/vnd.pg.format": {\n    "source": "iana",\n    "extensions": ["str"]\n  },\n  "application/vnd.pg.osasli": {\n    "source": "iana",\n    "extensions": ["ei6"]\n  },\n  "application/vnd.piaccess.application-licence": {\n    "source": "iana"\n  },\n  "application/vnd.picsel": {\n    "source": "iana",\n    "extensions": ["efif"]\n  },\n  "application/vnd.pmi.widget": {\n    "source": "iana",\n    "extensions": ["wg"]\n  },\n  "application/vnd.poc.group-advertisement+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.pocketlearn": {\n    "source": "iana",\n    "extensions": ["plf"]\n  },\n  "application/vnd.powerbuilder6": {\n    "source": "iana",\n    "extensions": ["pbd"]\n  },\n  "application/vnd.powerbuilder6-s": {\n    "source": "iana"\n  },\n  "application/vnd.powerbuilder7": {\n    "source": "iana"\n  },\n  "application/vnd.powerbuilder7-s": {\n    "source": "iana"\n  },\n  "application/vnd.powerbuilder75": {\n    "source": "iana"\n  },\n  "application/vnd.powerbuilder75-s": {\n    "source": "iana"\n  },\n  "application/vnd.preminet": {\n    "source": "iana"\n  },\n  "application/vnd.previewsystems.box": {\n    "source": "iana",\n    "extensions": ["box"]\n  },\n  "application/vnd.proteus.magazine": {\n    "source": "iana",\n    "extensions": ["mgz"]\n  },\n  "application/vnd.psfs": {\n    "source": "iana"\n  },\n  "application/vnd.publishare-delta-tree": {\n    "source": "iana",\n    "extensions": ["qps"]\n  },\n  "application/vnd.pvi.ptid1": {\n    "source": "iana",\n    "extensions": ["ptid"]\n  },\n  "application/vnd.pwg-multiplexed": {\n    "source": "iana"\n  },\n  "application/vnd.pwg-xhtml-print+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.qualcomm.brew-app-res": {\n    "source": "iana"\n  },\n  "application/vnd.quarantainenet": {\n    "source": "iana"\n  },\n  "application/vnd.quark.quarkxpress": {\n    "source": "iana",\n    "extensions": ["qxd","qxt","qwd","qwt","qxl","qxb"]\n  },\n  "application/vnd.quobject-quoxdocument": {\n    "source": "iana"\n  },\n  "application/vnd.radisys.moml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-audit+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-audit-conf+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-audit-conn+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-audit-dialog+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-audit-stream+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-conf+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-dialog+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-dialog-base+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-dialog-fax-detect+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-dialog-group+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-dialog-speech+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-dialog-transform+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.rainstor.data": {\n    "source": "iana"\n  },\n  "application/vnd.rapid": {\n    "source": "iana"\n  },\n  "application/vnd.rar": {\n    "source": "iana",\n    "extensions": ["rar"]\n  },\n  "application/vnd.realvnc.bed": {\n    "source": "iana",\n    "extensions": ["bed"]\n  },\n  "application/vnd.recordare.musicxml": {\n    "source": "iana",\n    "extensions": ["mxl"]\n  },\n  "application/vnd.recordare.musicxml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["musicxml"]\n  },\n  "application/vnd.renlearn.rlprint": {\n    "source": "iana"\n  },\n  "application/vnd.restful+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.rig.cryptonote": {\n    "source": "iana",\n    "extensions": ["cryptonote"]\n  },\n  "application/vnd.rim.cod": {\n    "source": "apache",\n    "extensions": ["cod"]\n  },\n  "application/vnd.rn-realmedia": {\n    "source": "apache",\n    "extensions": ["rm"]\n  },\n  "application/vnd.rn-realmedia-vbr": {\n    "source": "apache",\n    "extensions": ["rmvb"]\n  },\n  "application/vnd.route66.link66+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["link66"]\n  },\n  "application/vnd.rs-274x": {\n    "source": "iana"\n  },\n  "application/vnd.ruckus.download": {\n    "source": "iana"\n  },\n  "application/vnd.s3sms": {\n    "source": "iana"\n  },\n  "application/vnd.sailingtracker.track": {\n    "source": "iana",\n    "extensions": ["st"]\n  },\n  "application/vnd.sar": {\n    "source": "iana"\n  },\n  "application/vnd.sbm.cid": {\n    "source": "iana"\n  },\n  "application/vnd.sbm.mid2": {\n    "source": "iana"\n  },\n  "application/vnd.scribus": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.3df": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.csf": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.doc": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.eml": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.mht": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.net": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.ppt": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.tiff": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.xls": {\n    "source": "iana"\n  },\n  "application/vnd.sealedmedia.softseal.html": {\n    "source": "iana"\n  },\n  "application/vnd.sealedmedia.softseal.pdf": {\n    "source": "iana"\n  },\n  "application/vnd.seemail": {\n    "source": "iana",\n    "extensions": ["see"]\n  },\n  "application/vnd.sema": {\n    "source": "iana",\n    "extensions": ["sema"]\n  },\n  "application/vnd.semd": {\n    "source": "iana",\n    "extensions": ["semd"]\n  },\n  "application/vnd.semf": {\n    "source": "iana",\n    "extensions": ["semf"]\n  },\n  "application/vnd.shade-save-file": {\n    "source": "iana"\n  },\n  "application/vnd.shana.informed.formdata": {\n    "source": "iana",\n    "extensions": ["ifm"]\n  },\n  "application/vnd.shana.informed.formtemplate": {\n    "source": "iana",\n    "extensions": ["itp"]\n  },\n  "application/vnd.shana.informed.interchange": {\n    "source": "iana",\n    "extensions": ["iif"]\n  },\n  "application/vnd.shana.informed.package": {\n    "source": "iana",\n    "extensions": ["ipk"]\n  },\n  "application/vnd.shootproof+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.shopkick+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.shp": {\n    "source": "iana"\n  },\n  "application/vnd.shx": {\n    "source": "iana"\n  },\n  "application/vnd.sigrok.session": {\n    "source": "iana"\n  },\n  "application/vnd.simtech-mindmapper": {\n    "source": "iana",\n    "extensions": ["twd","twds"]\n  },\n  "application/vnd.siren+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.smaf": {\n    "source": "iana",\n    "extensions": ["mmf"]\n  },\n  "application/vnd.smart.notebook": {\n    "source": "iana"\n  },\n  "application/vnd.smart.teacher": {\n    "source": "iana",\n    "extensions": ["teacher"]\n  },\n  "application/vnd.snesdev-page-table": {\n    "source": "iana"\n  },\n  "application/vnd.software602.filler.form+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["fo"]\n  },\n  "application/vnd.software602.filler.form-xml-zip": {\n    "source": "iana"\n  },\n  "application/vnd.solent.sdkm+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["sdkm","sdkd"]\n  },\n  "application/vnd.spotfire.dxp": {\n    "source": "iana",\n    "extensions": ["dxp"]\n  },\n  "application/vnd.spotfire.sfs": {\n    "source": "iana",\n    "extensions": ["sfs"]\n  },\n  "application/vnd.sqlite3": {\n    "source": "iana"\n  },\n  "application/vnd.sss-cod": {\n    "source": "iana"\n  },\n  "application/vnd.sss-dtf": {\n    "source": "iana"\n  },\n  "application/vnd.sss-ntf": {\n    "source": "iana"\n  },\n  "application/vnd.stardivision.calc": {\n    "source": "apache",\n    "extensions": ["sdc"]\n  },\n  "application/vnd.stardivision.draw": {\n    "source": "apache",\n    "extensions": ["sda"]\n  },\n  "application/vnd.stardivision.impress": {\n    "source": "apache",\n    "extensions": ["sdd"]\n  },\n  "application/vnd.stardivision.math": {\n    "source": "apache",\n    "extensions": ["smf"]\n  },\n  "application/vnd.stardivision.writer": {\n    "source": "apache",\n    "extensions": ["sdw","vor"]\n  },\n  "application/vnd.stardivision.writer-global": {\n    "source": "apache",\n    "extensions": ["sgl"]\n  },\n  "application/vnd.stepmania.package": {\n    "source": "iana",\n    "extensions": ["smzip"]\n  },\n  "application/vnd.stepmania.stepchart": {\n    "source": "iana",\n    "extensions": ["sm"]\n  },\n  "application/vnd.street-stream": {\n    "source": "iana"\n  },\n  "application/vnd.sun.wadl+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["wadl"]\n  },\n  "application/vnd.sun.xml.calc": {\n    "source": "apache",\n    "extensions": ["sxc"]\n  },\n  "application/vnd.sun.xml.calc.template": {\n    "source": "apache",\n    "extensions": ["stc"]\n  },\n  "application/vnd.sun.xml.draw": {\n    "source": "apache",\n    "extensions": ["sxd"]\n  },\n  "application/vnd.sun.xml.draw.template": {\n    "source": "apache",\n    "extensions": ["std"]\n  },\n  "application/vnd.sun.xml.impress": {\n    "source": "apache",\n    "extensions": ["sxi"]\n  },\n  "application/vnd.sun.xml.impress.template": {\n    "source": "apache",\n    "extensions": ["sti"]\n  },\n  "application/vnd.sun.xml.math": {\n    "source": "apache",\n    "extensions": ["sxm"]\n  },\n  "application/vnd.sun.xml.writer": {\n    "source": "apache",\n    "extensions": ["sxw"]\n  },\n  "application/vnd.sun.xml.writer.global": {\n    "source": "apache",\n    "extensions": ["sxg"]\n  },\n  "application/vnd.sun.xml.writer.template": {\n    "source": "apache",\n    "extensions": ["stw"]\n  },\n  "application/vnd.sus-calendar": {\n    "source": "iana",\n    "extensions": ["sus","susp"]\n  },\n  "application/vnd.svd": {\n    "source": "iana",\n    "extensions": ["svd"]\n  },\n  "application/vnd.swiftview-ics": {\n    "source": "iana"\n  },\n  "application/vnd.sycle+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.symbian.install": {\n    "source": "apache",\n    "extensions": ["sis","sisx"]\n  },\n  "application/vnd.syncml+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["xsm"]\n  },\n  "application/vnd.syncml.dm+wbxml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "extensions": ["bdm"]\n  },\n  "application/vnd.syncml.dm+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["xdm"]\n  },\n  "application/vnd.syncml.dm.notification": {\n    "source": "iana"\n  },\n  "application/vnd.syncml.dmddf+wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.syncml.dmddf+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["ddf"]\n  },\n  "application/vnd.syncml.dmtnds+wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.syncml.dmtnds+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/vnd.syncml.ds.notification": {\n    "source": "iana"\n  },\n  "application/vnd.tableschema+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.tao.intent-module-archive": {\n    "source": "iana",\n    "extensions": ["tao"]\n  },\n  "application/vnd.tcpdump.pcap": {\n    "source": "iana",\n    "extensions": ["pcap","cap","dmp"]\n  },\n  "application/vnd.think-cell.ppttc+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.tmd.mediaflex.api+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.tml": {\n    "source": "iana"\n  },\n  "application/vnd.tmobile-livetv": {\n    "source": "iana",\n    "extensions": ["tmo"]\n  },\n  "application/vnd.tri.onesource": {\n    "source": "iana"\n  },\n  "application/vnd.trid.tpt": {\n    "source": "iana",\n    "extensions": ["tpt"]\n  },\n  "application/vnd.triscape.mxs": {\n    "source": "iana",\n    "extensions": ["mxs"]\n  },\n  "application/vnd.trueapp": {\n    "source": "iana",\n    "extensions": ["tra"]\n  },\n  "application/vnd.truedoc": {\n    "source": "iana"\n  },\n  "application/vnd.ubisoft.webplayer": {\n    "source": "iana"\n  },\n  "application/vnd.ufdl": {\n    "source": "iana",\n    "extensions": ["ufd","ufdl"]\n  },\n  "application/vnd.uiq.theme": {\n    "source": "iana",\n    "extensions": ["utz"]\n  },\n  "application/vnd.umajin": {\n    "source": "iana",\n    "extensions": ["umj"]\n  },\n  "application/vnd.unity": {\n    "source": "iana",\n    "extensions": ["unityweb"]\n  },\n  "application/vnd.uoml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["uoml"]\n  },\n  "application/vnd.uplanet.alert": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.alert-wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.bearer-choice": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.bearer-choice-wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.cacheop": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.cacheop-wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.channel": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.channel-wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.list": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.list-wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.listcmd": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.listcmd-wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.signal": {\n    "source": "iana"\n  },\n  "application/vnd.uri-map": {\n    "source": "iana"\n  },\n  "application/vnd.valve.source.material": {\n    "source": "iana"\n  },\n  "application/vnd.vcx": {\n    "source": "iana",\n    "extensions": ["vcx"]\n  },\n  "application/vnd.vd-study": {\n    "source": "iana"\n  },\n  "application/vnd.vectorworks": {\n    "source": "iana"\n  },\n  "application/vnd.vel+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.verimatrix.vcas": {\n    "source": "iana"\n  },\n  "application/vnd.veryant.thin": {\n    "source": "iana"\n  },\n  "application/vnd.ves.encrypted": {\n    "source": "iana"\n  },\n  "application/vnd.vidsoft.vidconference": {\n    "source": "iana"\n  },\n  "application/vnd.visio": {\n    "source": "iana",\n    "extensions": ["vsd","vst","vss","vsw"]\n  },\n  "application/vnd.visionary": {\n    "source": "iana",\n    "extensions": ["vis"]\n  },\n  "application/vnd.vividence.scriptfile": {\n    "source": "iana"\n  },\n  "application/vnd.vsf": {\n    "source": "iana",\n    "extensions": ["vsf"]\n  },\n  "application/vnd.wap.sic": {\n    "source": "iana"\n  },\n  "application/vnd.wap.slc": {\n    "source": "iana"\n  },\n  "application/vnd.wap.wbxml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "extensions": ["wbxml"]\n  },\n  "application/vnd.wap.wmlc": {\n    "source": "iana",\n    "extensions": ["wmlc"]\n  },\n  "application/vnd.wap.wmlscriptc": {\n    "source": "iana",\n    "extensions": ["wmlsc"]\n  },\n  "application/vnd.webturbo": {\n    "source": "iana",\n    "extensions": ["wtb"]\n  },\n  "application/vnd.wfa.p2p": {\n    "source": "iana"\n  },\n  "application/vnd.wfa.wsc": {\n    "source": "iana"\n  },\n  "application/vnd.windows.devicepairing": {\n    "source": "iana"\n  },\n  "application/vnd.wmc": {\n    "source": "iana"\n  },\n  "application/vnd.wmf.bootstrap": {\n    "source": "iana"\n  },\n  "application/vnd.wolfram.mathematica": {\n    "source": "iana"\n  },\n  "application/vnd.wolfram.mathematica.package": {\n    "source": "iana"\n  },\n  "application/vnd.wolfram.player": {\n    "source": "iana",\n    "extensions": ["nbp"]\n  },\n  "application/vnd.wordperfect": {\n    "source": "iana",\n    "extensions": ["wpd"]\n  },\n  "application/vnd.wqd": {\n    "source": "iana",\n    "extensions": ["wqd"]\n  },\n  "application/vnd.wrq-hp3000-labelled": {\n    "source": "iana"\n  },\n  "application/vnd.wt.stf": {\n    "source": "iana",\n    "extensions": ["stf"]\n  },\n  "application/vnd.wv.csp+wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.wv.csp+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.wv.ssp+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.xacml+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.xara": {\n    "source": "iana",\n    "extensions": ["xar"]\n  },\n  "application/vnd.xfdl": {\n    "source": "iana",\n    "extensions": ["xfdl"]\n  },\n  "application/vnd.xfdl.webform": {\n    "source": "iana"\n  },\n  "application/vnd.xmi+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.xmpie.cpkg": {\n    "source": "iana"\n  },\n  "application/vnd.xmpie.dpkg": {\n    "source": "iana"\n  },\n  "application/vnd.xmpie.plan": {\n    "source": "iana"\n  },\n  "application/vnd.xmpie.ppkg": {\n    "source": "iana"\n  },\n  "application/vnd.xmpie.xlim": {\n    "source": "iana"\n  },\n  "application/vnd.yamaha.hv-dic": {\n    "source": "iana",\n    "extensions": ["hvd"]\n  },\n  "application/vnd.yamaha.hv-script": {\n    "source": "iana",\n    "extensions": ["hvs"]\n  },\n  "application/vnd.yamaha.hv-voice": {\n    "source": "iana",\n    "extensions": ["hvp"]\n  },\n  "application/vnd.yamaha.openscoreformat": {\n    "source": "iana",\n    "extensions": ["osf"]\n  },\n  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["osfpvg"]\n  },\n  "application/vnd.yamaha.remote-setup": {\n    "source": "iana"\n  },\n  "application/vnd.yamaha.smaf-audio": {\n    "source": "iana",\n    "extensions": ["saf"]\n  },\n  "application/vnd.yamaha.smaf-phrase": {\n    "source": "iana",\n    "extensions": ["spf"]\n  },\n  "application/vnd.yamaha.through-ngn": {\n    "source": "iana"\n  },\n  "application/vnd.yamaha.tunnel-udpencap": {\n    "source": "iana"\n  },\n  "application/vnd.yaoweme": {\n    "source": "iana"\n  },\n  "application/vnd.yellowriver-custom-menu": {\n    "source": "iana",\n    "extensions": ["cmp"]\n  },\n  "application/vnd.youtube.yt": {\n    "source": "iana"\n  },\n  "application/vnd.zul": {\n    "source": "iana",\n    "extensions": ["zir","zirz"]\n  },\n  "application/vnd.zzazz.deck+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["zaz"]\n  },\n  "application/voicexml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["vxml"]\n  },\n  "application/voucher-cms+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vq-rtcpxr": {\n    "source": "iana"\n  },\n  "application/wasm": {\n    "compressible": true,\n    "extensions": ["wasm"]\n  },\n  "application/watcherinfo+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/webpush-options+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/whoispp-query": {\n    "source": "iana"\n  },\n  "application/whoispp-response": {\n    "source": "iana"\n  },\n  "application/widget": {\n    "source": "iana",\n    "extensions": ["wgt"]\n  },\n  "application/winhlp": {\n    "source": "apache",\n    "extensions": ["hlp"]\n  },\n  "application/wita": {\n    "source": "iana"\n  },\n  "application/wordperfect5.1": {\n    "source": "iana"\n  },\n  "application/wsdl+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["wsdl"]\n  },\n  "application/wspolicy+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["wspolicy"]\n  },\n  "application/x-7z-compressed": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["7z"]\n  },\n  "application/x-abiword": {\n    "source": "apache",\n    "extensions": ["abw"]\n  },\n  "application/x-ace-compressed": {\n    "source": "apache",\n    "extensions": ["ace"]\n  },\n  "application/x-amf": {\n    "source": "apache"\n  },\n  "application/x-apple-diskimage": {\n    "source": "apache",\n    "extensions": ["dmg"]\n  },\n  "application/x-arj": {\n    "compressible": false,\n    "extensions": ["arj"]\n  },\n  "application/x-authorware-bin": {\n    "source": "apache",\n    "extensions": ["aab","x32","u32","vox"]\n  },\n  "application/x-authorware-map": {\n    "source": "apache",\n    "extensions": ["aam"]\n  },\n  "application/x-authorware-seg": {\n    "source": "apache",\n    "extensions": ["aas"]\n  },\n  "application/x-bcpio": {\n    "source": "apache",\n    "extensions": ["bcpio"]\n  },\n  "application/x-bdoc": {\n    "compressible": false,\n    "extensions": ["bdoc"]\n  },\n  "application/x-bittorrent": {\n    "source": "apache",\n    "extensions": ["torrent"]\n  },\n  "application/x-blorb": {\n    "source": "apache",\n    "extensions": ["blb","blorb"]\n  },\n  "application/x-bzip": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["bz"]\n  },\n  "application/x-bzip2": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["bz2","boz"]\n  },\n  "application/x-cbr": {\n    "source": "apache",\n    "extensions": ["cbr","cba","cbt","cbz","cb7"]\n  },\n  "application/x-cdlink": {\n    "source": "apache",\n    "extensions": ["vcd"]\n  },\n  "application/x-cfs-compressed": {\n    "source": "apache",\n    "extensions": ["cfs"]\n  },\n  "application/x-chat": {\n    "source": "apache",\n    "extensions": ["chat"]\n  },\n  "application/x-chess-pgn": {\n    "source": "apache",\n    "extensions": ["pgn"]\n  },\n  "application/x-chrome-extension": {\n    "extensions": ["crx"]\n  },\n  "application/x-cocoa": {\n    "source": "nginx",\n    "extensions": ["cco"]\n  },\n  "application/x-compress": {\n    "source": "apache"\n  },\n  "application/x-conference": {\n    "source": "apache",\n    "extensions": ["nsc"]\n  },\n  "application/x-cpio": {\n    "source": "apache",\n    "extensions": ["cpio"]\n  },\n  "application/x-csh": {\n    "source": "apache",\n    "extensions": ["csh"]\n  },\n  "application/x-deb": {\n    "compressible": false\n  },\n  "application/x-debian-package": {\n    "source": "apache",\n    "extensions": ["deb","udeb"]\n  },\n  "application/x-dgc-compressed": {\n    "source": "apache",\n    "extensions": ["dgc"]\n  },\n  "application/x-director": {\n    "source": "apache",\n    "extensions": ["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]\n  },\n  "application/x-doom": {\n    "source": "apache",\n    "extensions": ["wad"]\n  },\n  "application/x-dtbncx+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["ncx"]\n  },\n  "application/x-dtbook+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["dtb"]\n  },\n  "application/x-dtbresource+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["res"]\n  },\n  "application/x-dvi": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["dvi"]\n  },\n  "application/x-envoy": {\n    "source": "apache",\n    "extensions": ["evy"]\n  },\n  "application/x-eva": {\n    "source": "apache",\n    "extensions": ["eva"]\n  },\n  "application/x-font-bdf": {\n    "source": "apache",\n    "extensions": ["bdf"]\n  },\n  "application/x-font-dos": {\n    "source": "apache"\n  },\n  "application/x-font-framemaker": {\n    "source": "apache"\n  },\n  "application/x-font-ghostscript": {\n    "source": "apache",\n    "extensions": ["gsf"]\n  },\n  "application/x-font-libgrx": {\n    "source": "apache"\n  },\n  "application/x-font-linux-psf": {\n    "source": "apache",\n    "extensions": ["psf"]\n  },\n  "application/x-font-pcf": {\n    "source": "apache",\n    "extensions": ["pcf"]\n  },\n  "application/x-font-snf": {\n    "source": "apache",\n    "extensions": ["snf"]\n  },\n  "application/x-font-speedo": {\n    "source": "apache"\n  },\n  "application/x-font-sunos-news": {\n    "source": "apache"\n  },\n  "application/x-font-type1": {\n    "source": "apache",\n    "extensions": ["pfa","pfb","pfm","afm"]\n  },\n  "application/x-font-vfont": {\n    "source": "apache"\n  },\n  "application/x-freearc": {\n    "source": "apache",\n    "extensions": ["arc"]\n  },\n  "application/x-futuresplash": {\n    "source": "apache",\n    "extensions": ["spl"]\n  },\n  "application/x-gca-compressed": {\n    "source": "apache",\n    "extensions": ["gca"]\n  },\n  "application/x-glulx": {\n    "source": "apache",\n    "extensions": ["ulx"]\n  },\n  "application/x-gnumeric": {\n    "source": "apache",\n    "extensions": ["gnumeric"]\n  },\n  "application/x-gramps-xml": {\n    "source": "apache",\n    "extensions": ["gramps"]\n  },\n  "application/x-gtar": {\n    "source": "apache",\n    "extensions": ["gtar"]\n  },\n  "application/x-gzip": {\n    "source": "apache"\n  },\n  "application/x-hdf": {\n    "source": "apache",\n    "extensions": ["hdf"]\n  },\n  "application/x-httpd-php": {\n    "compressible": true,\n    "extensions": ["php"]\n  },\n  "application/x-install-instructions": {\n    "source": "apache",\n    "extensions": ["install"]\n  },\n  "application/x-iso9660-image": {\n    "source": "apache",\n    "extensions": ["iso"]\n  },\n  "application/x-java-archive-diff": {\n    "source": "nginx",\n    "extensions": ["jardiff"]\n  },\n  "application/x-java-jnlp-file": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["jnlp"]\n  },\n  "application/x-javascript": {\n    "compressible": true\n  },\n  "application/x-keepass2": {\n    "extensions": ["kdbx"]\n  },\n  "application/x-latex": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["latex"]\n  },\n  "application/x-lua-bytecode": {\n    "extensions": ["luac"]\n  },\n  "application/x-lzh-compressed": {\n    "source": "apache",\n    "extensions": ["lzh","lha"]\n  },\n  "application/x-makeself": {\n    "source": "nginx",\n    "extensions": ["run"]\n  },\n  "application/x-mie": {\n    "source": "apache",\n    "extensions": ["mie"]\n  },\n  "application/x-mobipocket-ebook": {\n    "source": "apache",\n    "extensions": ["prc","mobi"]\n  },\n  "application/x-mpegurl": {\n    "compressible": false\n  },\n  "application/x-ms-application": {\n    "source": "apache",\n    "extensions": ["application"]\n  },\n  "application/x-ms-shortcut": {\n    "source": "apache",\n    "extensions": ["lnk"]\n  },\n  "application/x-ms-wmd": {\n    "source": "apache",\n    "extensions": ["wmd"]\n  },\n  "application/x-ms-wmz": {\n    "source": "apache",\n    "extensions": ["wmz"]\n  },\n  "application/x-ms-xbap": {\n    "source": "apache",\n    "extensions": ["xbap"]\n  },\n  "application/x-msaccess": {\n    "source": "apache",\n    "extensions": ["mdb"]\n  },\n  "application/x-msbinder": {\n    "source": "apache",\n    "extensions": ["obd"]\n  },\n  "application/x-mscardfile": {\n    "source": "apache",\n    "extensions": ["crd"]\n  },\n  "application/x-msclip": {\n    "source": "apache",\n    "extensions": ["clp"]\n  },\n  "application/x-msdos-program": {\n    "extensions": ["exe"]\n  },\n  "application/x-msdownload": {\n    "source": "apache",\n    "extensions": ["exe","dll","com","bat","msi"]\n  },\n  "application/x-msmediaview": {\n    "source": "apache",\n    "extensions": ["mvb","m13","m14"]\n  },\n  "application/x-msmetafile": {\n    "source": "apache",\n    "extensions": ["wmf","wmz","emf","emz"]\n  },\n  "application/x-msmoney": {\n    "source": "apache",\n    "extensions": ["mny"]\n  },\n  "application/x-mspublisher": {\n    "source": "apache",\n    "extensions": ["pub"]\n  },\n  "application/x-msschedule": {\n    "source": "apache",\n    "extensions": ["scd"]\n  },\n  "application/x-msterminal": {\n    "source": "apache",\n    "extensions": ["trm"]\n  },\n  "application/x-mswrite": {\n    "source": "apache",\n    "extensions": ["wri"]\n  },\n  "application/x-netcdf": {\n    "source": "apache",\n    "extensions": ["nc","cdf"]\n  },\n  "application/x-ns-proxy-autoconfig": {\n    "compressible": true,\n    "extensions": ["pac"]\n  },\n  "application/x-nzb": {\n    "source": "apache",\n    "extensions": ["nzb"]\n  },\n  "application/x-perl": {\n    "source": "nginx",\n    "extensions": ["pl","pm"]\n  },\n  "application/x-pilot": {\n    "source": "nginx",\n    "extensions": ["prc","pdb"]\n  },\n  "application/x-pkcs12": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["p12","pfx"]\n  },\n  "application/x-pkcs7-certificates": {\n    "source": "apache",\n    "extensions": ["p7b","spc"]\n  },\n  "application/x-pkcs7-certreqresp": {\n    "source": "apache",\n    "extensions": ["p7r"]\n  },\n  "application/x-pki-message": {\n    "source": "iana"\n  },\n  "application/x-rar-compressed": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["rar"]\n  },\n  "application/x-redhat-package-manager": {\n    "source": "nginx",\n    "extensions": ["rpm"]\n  },\n  "application/x-research-info-systems": {\n    "source": "apache",\n    "extensions": ["ris"]\n  },\n  "application/x-sea": {\n    "source": "nginx",\n    "extensions": ["sea"]\n  },\n  "application/x-sh": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["sh"]\n  },\n  "application/x-shar": {\n    "source": "apache",\n    "extensions": ["shar"]\n  },\n  "application/x-shockwave-flash": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["swf"]\n  },\n  "application/x-silverlight-app": {\n    "source": "apache",\n    "extensions": ["xap"]\n  },\n  "application/x-sql": {\n    "source": "apache",\n    "extensions": ["sql"]\n  },\n  "application/x-stuffit": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["sit"]\n  },\n  "application/x-stuffitx": {\n    "source": "apache",\n    "extensions": ["sitx"]\n  },\n  "application/x-subrip": {\n    "source": "apache",\n    "extensions": ["srt"]\n  },\n  "application/x-sv4cpio": {\n    "source": "apache",\n    "extensions": ["sv4cpio"]\n  },\n  "application/x-sv4crc": {\n    "source": "apache",\n    "extensions": ["sv4crc"]\n  },\n  "application/x-t3vm-image": {\n    "source": "apache",\n    "extensions": ["t3"]\n  },\n  "application/x-tads": {\n    "source": "apache",\n    "extensions": ["gam"]\n  },\n  "application/x-tar": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["tar"]\n  },\n  "application/x-tcl": {\n    "source": "apache",\n    "extensions": ["tcl","tk"]\n  },\n  "application/x-tex": {\n    "source": "apache",\n    "extensions": ["tex"]\n  },\n  "application/x-tex-tfm": {\n    "source": "apache",\n    "extensions": ["tfm"]\n  },\n  "application/x-texinfo": {\n    "source": "apache",\n    "extensions": ["texinfo","texi"]\n  },\n  "application/x-tgif": {\n    "source": "apache",\n    "extensions": ["obj"]\n  },\n  "application/x-ustar": {\n    "source": "apache",\n    "extensions": ["ustar"]\n  },\n  "application/x-virtualbox-hdd": {\n    "compressible": true,\n    "extensions": ["hdd"]\n  },\n  "application/x-virtualbox-ova": {\n    "compressible": true,\n    "extensions": ["ova"]\n  },\n  "application/x-virtualbox-ovf": {\n    "compressible": true,\n    "extensions": ["ovf"]\n  },\n  "application/x-virtualbox-vbox": {\n    "compressible": true,\n    "extensions": ["vbox"]\n  },\n  "application/x-virtualbox-vbox-extpack": {\n    "compressible": false,\n    "extensions": ["vbox-extpack"]\n  },\n  "application/x-virtualbox-vdi": {\n    "compressible": true,\n    "extensions": ["vdi"]\n  },\n  "application/x-virtualbox-vhd": {\n    "compressible": true,\n    "extensions": ["vhd"]\n  },\n  "application/x-virtualbox-vmdk": {\n    "compressible": true,\n    "extensions": ["vmdk"]\n  },\n  "application/x-wais-source": {\n    "source": "apache",\n    "extensions": ["src"]\n  },\n  "application/x-web-app-manifest+json": {\n    "compressible": true,\n    "extensions": ["webapp"]\n  },\n  "application/x-www-form-urlencoded": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/x-x509-ca-cert": {\n    "source": "iana",\n    "extensions": ["der","crt","pem"]\n  },\n  "application/x-x509-ca-ra-cert": {\n    "source": "iana"\n  },\n  "application/x-x509-next-ca-cert": {\n    "source": "iana"\n  },\n  "application/x-xfig": {\n    "source": "apache",\n    "extensions": ["fig"]\n  },\n  "application/x-xliff+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["xlf"]\n  },\n  "application/x-xpinstall": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["xpi"]\n  },\n  "application/x-xz": {\n    "source": "apache",\n    "extensions": ["xz"]\n  },\n  "application/x-zmachine": {\n    "source": "apache",\n    "extensions": ["z1","z2","z3","z4","z5","z6","z7","z8"]\n  },\n  "application/x400-bp": {\n    "source": "iana"\n  },\n  "application/xacml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/xaml+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["xaml"]\n  },\n  "application/xcap-att+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xav"]\n  },\n  "application/xcap-caps+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xca"]\n  },\n  "application/xcap-diff+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xdf"]\n  },\n  "application/xcap-el+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xel"]\n  },\n  "application/xcap-error+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xer"]\n  },\n  "application/xcap-ns+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xns"]\n  },\n  "application/xcon-conference-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/xcon-conference-info-diff+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/xenc+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xenc"]\n  },\n  "application/xhtml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xhtml","xht"]\n  },\n  "application/xhtml-voice+xml": {\n    "source": "apache",\n    "compressible": true\n  },\n  "application/xliff+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xlf"]\n  },\n  "application/xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xml","xsl","xsd","rng"]\n  },\n  "application/xml-dtd": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["dtd"]\n  },\n  "application/xml-external-parsed-entity": {\n    "source": "iana"\n  },\n  "application/xml-patch+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/xmpp+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/xop+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xop"]\n  },\n  "application/xproc+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["xpl"]\n  },\n  "application/xslt+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xsl","xslt"]\n  },\n  "application/xspf+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["xspf"]\n  },\n  "application/xv+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mxml","xhvml","xvml","xvm"]\n  },\n  "application/yang": {\n    "source": "iana",\n    "extensions": ["yang"]\n  },\n  "application/yang-data+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/yang-data+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/yang-patch+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/yang-patch+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/yin+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["yin"]\n  },\n  "application/zip": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["zip"]\n  },\n  "application/zlib": {\n    "source": "iana"\n  },\n  "application/zstd": {\n    "source": "iana"\n  },\n  "audio/1d-interleaved-parityfec": {\n    "source": "iana"\n  },\n  "audio/32kadpcm": {\n    "source": "iana"\n  },\n  "audio/3gpp": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["3gpp"]\n  },\n  "audio/3gpp2": {\n    "source": "iana"\n  },\n  "audio/aac": {\n    "source": "iana"\n  },\n  "audio/ac3": {\n    "source": "iana"\n  },\n  "audio/adpcm": {\n    "source": "apache",\n    "extensions": ["adp"]\n  },\n  "audio/amr": {\n    "source": "iana"\n  },\n  "audio/amr-wb": {\n    "source": "iana"\n  },\n  "audio/amr-wb+": {\n    "source": "iana"\n  },\n  "audio/aptx": {\n    "source": "iana"\n  },\n  "audio/asc": {\n    "source": "iana"\n  },\n  "audio/atrac-advanced-lossless": {\n    "source": "iana"\n  },\n  "audio/atrac-x": {\n    "source": "iana"\n  },\n  "audio/atrac3": {\n    "source": "iana"\n  },\n  "audio/basic": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["au","snd"]\n  },\n  "audio/bv16": {\n    "source": "iana"\n  },\n  "audio/bv32": {\n    "source": "iana"\n  },\n  "audio/clearmode": {\n    "source": "iana"\n  },\n  "audio/cn": {\n    "source": "iana"\n  },\n  "audio/dat12": {\n    "source": "iana"\n  },\n  "audio/dls": {\n    "source": "iana"\n  },\n  "audio/dsr-es201108": {\n    "source": "iana"\n  },\n  "audio/dsr-es202050": {\n    "source": "iana"\n  },\n  "audio/dsr-es202211": {\n    "source": "iana"\n  },\n  "audio/dsr-es202212": {\n    "source": "iana"\n  },\n  "audio/dv": {\n    "source": "iana"\n  },\n  "audio/dvi4": {\n    "source": "iana"\n  },\n  "audio/eac3": {\n    "source": "iana"\n  },\n  "audio/encaprtp": {\n    "source": "iana"\n  },\n  "audio/evrc": {\n    "source": "iana"\n  },\n  "audio/evrc-qcp": {\n    "source": "iana"\n  },\n  "audio/evrc0": {\n    "source": "iana"\n  },\n  "audio/evrc1": {\n    "source": "iana"\n  },\n  "audio/evrcb": {\n    "source": "iana"\n  },\n  "audio/evrcb0": {\n    "source": "iana"\n  },\n  "audio/evrcb1": {\n    "source": "iana"\n  },\n  "audio/evrcnw": {\n    "source": "iana"\n  },\n  "audio/evrcnw0": {\n    "source": "iana"\n  },\n  "audio/evrcnw1": {\n    "source": "iana"\n  },\n  "audio/evrcwb": {\n    "source": "iana"\n  },\n  "audio/evrcwb0": {\n    "source": "iana"\n  },\n  "audio/evrcwb1": {\n    "source": "iana"\n  },\n  "audio/evs": {\n    "source": "iana"\n  },\n  "audio/flexfec": {\n    "source": "iana"\n  },\n  "audio/fwdred": {\n    "source": "iana"\n  },\n  "audio/g711-0": {\n    "source": "iana"\n  },\n  "audio/g719": {\n    "source": "iana"\n  },\n  "audio/g722": {\n    "source": "iana"\n  },\n  "audio/g7221": {\n    "source": "iana"\n  },\n  "audio/g723": {\n    "source": "iana"\n  },\n  "audio/g726-16": {\n    "source": "iana"\n  },\n  "audio/g726-24": {\n    "source": "iana"\n  },\n  "audio/g726-32": {\n    "source": "iana"\n  },\n  "audio/g726-40": {\n    "source": "iana"\n  },\n  "audio/g728": {\n    "source": "iana"\n  },\n  "audio/g729": {\n    "source": "iana"\n  },\n  "audio/g7291": {\n    "source": "iana"\n  },\n  "audio/g729d": {\n    "source": "iana"\n  },\n  "audio/g729e": {\n    "source": "iana"\n  },\n  "audio/gsm": {\n    "source": "iana"\n  },\n  "audio/gsm-efr": {\n    "source": "iana"\n  },\n  "audio/gsm-hr-08": {\n    "source": "iana"\n  },\n  "audio/ilbc": {\n    "source": "iana"\n  },\n  "audio/ip-mr_v2.5": {\n    "source": "iana"\n  },\n  "audio/isac": {\n    "source": "apache"\n  },\n  "audio/l16": {\n    "source": "iana"\n  },\n  "audio/l20": {\n    "source": "iana"\n  },\n  "audio/l24": {\n    "source": "iana",\n    "compressible": false\n  },\n  "audio/l8": {\n    "source": "iana"\n  },\n  "audio/lpc": {\n    "source": "iana"\n  },\n  "audio/melp": {\n    "source": "iana"\n  },\n  "audio/melp1200": {\n    "source": "iana"\n  },\n  "audio/melp2400": {\n    "source": "iana"\n  },\n  "audio/melp600": {\n    "source": "iana"\n  },\n  "audio/mhas": {\n    "source": "iana"\n  },\n  "audio/midi": {\n    "source": "apache",\n    "extensions": ["mid","midi","kar","rmi"]\n  },\n  "audio/mobile-xmf": {\n    "source": "iana",\n    "extensions": ["mxmf"]\n  },\n  "audio/mp3": {\n    "compressible": false,\n    "extensions": ["mp3"]\n  },\n  "audio/mp4": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["m4a","mp4a"]\n  },\n  "audio/mp4a-latm": {\n    "source": "iana"\n  },\n  "audio/mpa": {\n    "source": "iana"\n  },\n  "audio/mpa-robust": {\n    "source": "iana"\n  },\n  "audio/mpeg": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["mpga","mp2","mp2a","mp3","m2a","m3a"]\n  },\n  "audio/mpeg4-generic": {\n    "source": "iana"\n  },\n  "audio/musepack": {\n    "source": "apache"\n  },\n  "audio/ogg": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["oga","ogg","spx"]\n  },\n  "audio/opus": {\n    "source": "iana"\n  },\n  "audio/parityfec": {\n    "source": "iana"\n  },\n  "audio/pcma": {\n    "source": "iana"\n  },\n  "audio/pcma-wb": {\n    "source": "iana"\n  },\n  "audio/pcmu": {\n    "source": "iana"\n  },\n  "audio/pcmu-wb": {\n    "source": "iana"\n  },\n  "audio/prs.sid": {\n    "source": "iana"\n  },\n  "audio/qcelp": {\n    "source": "iana"\n  },\n  "audio/raptorfec": {\n    "source": "iana"\n  },\n  "audio/red": {\n    "source": "iana"\n  },\n  "audio/rtp-enc-aescm128": {\n    "source": "iana"\n  },\n  "audio/rtp-midi": {\n    "source": "iana"\n  },\n  "audio/rtploopback": {\n    "source": "iana"\n  },\n  "audio/rtx": {\n    "source": "iana"\n  },\n  "audio/s3m": {\n    "source": "apache",\n    "extensions": ["s3m"]\n  },\n  "audio/silk": {\n    "source": "apache",\n    "extensions": ["sil"]\n  },\n  "audio/smv": {\n    "source": "iana"\n  },\n  "audio/smv-qcp": {\n    "source": "iana"\n  },\n  "audio/smv0": {\n    "source": "iana"\n  },\n  "audio/sofa": {\n    "source": "iana"\n  },\n  "audio/sp-midi": {\n    "source": "iana"\n  },\n  "audio/speex": {\n    "source": "iana"\n  },\n  "audio/t140c": {\n    "source": "iana"\n  },\n  "audio/t38": {\n    "source": "iana"\n  },\n  "audio/telephone-event": {\n    "source": "iana"\n  },\n  "audio/tetra_acelp": {\n    "source": "iana"\n  },\n  "audio/tetra_acelp_bb": {\n    "source": "iana"\n  },\n  "audio/tone": {\n    "source": "iana"\n  },\n  "audio/tsvcis": {\n    "source": "iana"\n  },\n  "audio/uemclip": {\n    "source": "iana"\n  },\n  "audio/ulpfec": {\n    "source": "iana"\n  },\n  "audio/usac": {\n    "source": "iana"\n  },\n  "audio/vdvi": {\n    "source": "iana"\n  },\n  "audio/vmr-wb": {\n    "source": "iana"\n  },\n  "audio/vnd.3gpp.iufp": {\n    "source": "iana"\n  },\n  "audio/vnd.4sb": {\n    "source": "iana"\n  },\n  "audio/vnd.audiokoz": {\n    "source": "iana"\n  },\n  "audio/vnd.celp": {\n    "source": "iana"\n  },\n  "audio/vnd.cisco.nse": {\n    "source": "iana"\n  },\n  "audio/vnd.cmles.radio-events": {\n    "source": "iana"\n  },\n  "audio/vnd.cns.anp1": {\n    "source": "iana"\n  },\n  "audio/vnd.cns.inf1": {\n    "source": "iana"\n  },\n  "audio/vnd.dece.audio": {\n    "source": "iana",\n    "extensions": ["uva","uvva"]\n  },\n  "audio/vnd.digital-winds": {\n    "source": "iana",\n    "extensions": ["eol"]\n  },\n  "audio/vnd.dlna.adts": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.heaac.1": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.heaac.2": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.mlp": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.mps": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.pl2": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.pl2x": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.pl2z": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.pulse.1": {\n    "source": "iana"\n  },\n  "audio/vnd.dra": {\n    "source": "iana",\n    "extensions": ["dra"]\n  },\n  "audio/vnd.dts": {\n    "source": "iana",\n    "extensions": ["dts"]\n  },\n  "audio/vnd.dts.hd": {\n    "source": "iana",\n    "extensions": ["dtshd"]\n  },\n  "audio/vnd.dts.uhd": {\n    "source": "iana"\n  },\n  "audio/vnd.dvb.file": {\n    "source": "iana"\n  },\n  "audio/vnd.everad.plj": {\n    "source": "iana"\n  },\n  "audio/vnd.hns.audio": {\n    "source": "iana"\n  },\n  "audio/vnd.lucent.voice": {\n    "source": "iana",\n    "extensions": ["lvp"]\n  },\n  "audio/vnd.ms-playready.media.pya": {\n    "source": "iana",\n    "extensions": ["pya"]\n  },\n  "audio/vnd.nokia.mobile-xmf": {\n    "source": "iana"\n  },\n  "audio/vnd.nortel.vbk": {\n    "source": "iana"\n  },\n  "audio/vnd.nuera.ecelp4800": {\n    "source": "iana",\n    "extensions": ["ecelp4800"]\n  },\n  "audio/vnd.nuera.ecelp7470": {\n    "source": "iana",\n    "extensions": ["ecelp7470"]\n  },\n  "audio/vnd.nuera.ecelp9600": {\n    "source": "iana",\n    "extensions": ["ecelp9600"]\n  },\n  "audio/vnd.octel.sbc": {\n    "source": "iana"\n  },\n  "audio/vnd.presonus.multitrack": {\n    "source": "iana"\n  },\n  "audio/vnd.qcelp": {\n    "source": "iana"\n  },\n  "audio/vnd.rhetorex.32kadpcm": {\n    "source": "iana"\n  },\n  "audio/vnd.rip": {\n    "source": "iana",\n    "extensions": ["rip"]\n  },\n  "audio/vnd.rn-realaudio": {\n    "compressible": false\n  },\n  "audio/vnd.sealedmedia.softseal.mpeg": {\n    "source": "iana"\n  },\n  "audio/vnd.vmx.cvsd": {\n    "source": "iana"\n  },\n  "audio/vnd.wave": {\n    "compressible": false\n  },\n  "audio/vorbis": {\n    "source": "iana",\n    "compressible": false\n  },\n  "audio/vorbis-config": {\n    "source": "iana"\n  },\n  "audio/wav": {\n    "compressible": false,\n    "extensions": ["wav"]\n  },\n  "audio/wave": {\n    "compressible": false,\n    "extensions": ["wav"]\n  },\n  "audio/webm": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["weba"]\n  },\n  "audio/x-aac": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["aac"]\n  },\n  "audio/x-aiff": {\n    "source": "apache",\n    "extensions": ["aif","aiff","aifc"]\n  },\n  "audio/x-caf": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["caf"]\n  },\n  "audio/x-flac": {\n    "source": "apache",\n    "extensions": ["flac"]\n  },\n  "audio/x-m4a": {\n    "source": "nginx",\n    "extensions": ["m4a"]\n  },\n  "audio/x-matroska": {\n    "source": "apache",\n    "extensions": ["mka"]\n  },\n  "audio/x-mpegurl": {\n    "source": "apache",\n    "extensions": ["m3u"]\n  },\n  "audio/x-ms-wax": {\n    "source": "apache",\n    "extensions": ["wax"]\n  },\n  "audio/x-ms-wma": {\n    "source": "apache",\n    "extensions": ["wma"]\n  },\n  "audio/x-pn-realaudio": {\n    "source": "apache",\n    "extensions": ["ram","ra"]\n  },\n  "audio/x-pn-realaudio-plugin": {\n    "source": "apache",\n    "extensions": ["rmp"]\n  },\n  "audio/x-realaudio": {\n    "source": "nginx",\n    "extensions": ["ra"]\n  },\n  "audio/x-tta": {\n    "source": "apache"\n  },\n  "audio/x-wav": {\n    "source": "apache",\n    "extensions": ["wav"]\n  },\n  "audio/xm": {\n    "source": "apache",\n    "extensions": ["xm"]\n  },\n  "chemical/x-cdx": {\n    "source": "apache",\n    "extensions": ["cdx"]\n  },\n  "chemical/x-cif": {\n    "source": "apache",\n    "extensions": ["cif"]\n  },\n  "chemical/x-cmdf": {\n    "source": "apache",\n    "extensions": ["cmdf"]\n  },\n  "chemical/x-cml": {\n    "source": "apache",\n    "extensions": ["cml"]\n  },\n  "chemical/x-csml": {\n    "source": "apache",\n    "extensions": ["csml"]\n  },\n  "chemical/x-pdb": {\n    "source": "apache"\n  },\n  "chemical/x-xyz": {\n    "source": "apache",\n    "extensions": ["xyz"]\n  },\n  "font/collection": {\n    "source": "iana",\n    "extensions": ["ttc"]\n  },\n  "font/otf": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["otf"]\n  },\n  "font/sfnt": {\n    "source": "iana"\n  },\n  "font/ttf": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ttf"]\n  },\n  "font/woff": {\n    "source": "iana",\n    "extensions": ["woff"]\n  },\n  "font/woff2": {\n    "source": "iana",\n    "extensions": ["woff2"]\n  },\n  "image/aces": {\n    "source": "iana",\n    "extensions": ["exr"]\n  },\n  "image/apng": {\n    "compressible": false,\n    "extensions": ["apng"]\n  },\n  "image/avci": {\n    "source": "iana"\n  },\n  "image/avcs": {\n    "source": "iana"\n  },\n  "image/avif": {\n    "compressible": false,\n    "extensions": ["avif"]\n  },\n  "image/bmp": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["bmp"]\n  },\n  "image/cgm": {\n    "source": "iana",\n    "extensions": ["cgm"]\n  },\n  "image/dicom-rle": {\n    "source": "iana",\n    "extensions": ["drle"]\n  },\n  "image/emf": {\n    "source": "iana",\n    "extensions": ["emf"]\n  },\n  "image/fits": {\n    "source": "iana",\n    "extensions": ["fits"]\n  },\n  "image/g3fax": {\n    "source": "iana",\n    "extensions": ["g3"]\n  },\n  "image/gif": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["gif"]\n  },\n  "image/heic": {\n    "source": "iana",\n    "extensions": ["heic"]\n  },\n  "image/heic-sequence": {\n    "source": "iana",\n    "extensions": ["heics"]\n  },\n  "image/heif": {\n    "source": "iana",\n    "extensions": ["heif"]\n  },\n  "image/heif-sequence": {\n    "source": "iana",\n    "extensions": ["heifs"]\n  },\n  "image/hej2k": {\n    "source": "iana",\n    "extensions": ["hej2"]\n  },\n  "image/hsj2": {\n    "source": "iana",\n    "extensions": ["hsj2"]\n  },\n  "image/ief": {\n    "source": "iana",\n    "extensions": ["ief"]\n  },\n  "image/jls": {\n    "source": "iana",\n    "extensions": ["jls"]\n  },\n  "image/jp2": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["jp2","jpg2"]\n  },\n  "image/jpeg": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["jpeg","jpg","jpe"]\n  },\n  "image/jph": {\n    "source": "iana",\n    "extensions": ["jph"]\n  },\n  "image/jphc": {\n    "source": "iana",\n    "extensions": ["jhc"]\n  },\n  "image/jpm": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["jpm"]\n  },\n  "image/jpx": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["jpx","jpf"]\n  },\n  "image/jxr": {\n    "source": "iana",\n    "extensions": ["jxr"]\n  },\n  "image/jxra": {\n    "source": "iana",\n    "extensions": ["jxra"]\n  },\n  "image/jxrs": {\n    "source": "iana",\n    "extensions": ["jxrs"]\n  },\n  "image/jxs": {\n    "source": "iana",\n    "extensions": ["jxs"]\n  },\n  "image/jxsc": {\n    "source": "iana",\n    "extensions": ["jxsc"]\n  },\n  "image/jxsi": {\n    "source": "iana",\n    "extensions": ["jxsi"]\n  },\n  "image/jxss": {\n    "source": "iana",\n    "extensions": ["jxss"]\n  },\n  "image/ktx": {\n    "source": "iana",\n    "extensions": ["ktx"]\n  },\n  "image/ktx2": {\n    "source": "iana",\n    "extensions": ["ktx2"]\n  },\n  "image/naplps": {\n    "source": "iana"\n  },\n  "image/pjpeg": {\n    "compressible": false\n  },\n  "image/png": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["png"]\n  },\n  "image/prs.btif": {\n    "source": "iana",\n    "extensions": ["btif"]\n  },\n  "image/prs.pti": {\n    "source": "iana",\n    "extensions": ["pti"]\n  },\n  "image/pwg-raster": {\n    "source": "iana"\n  },\n  "image/sgi": {\n    "source": "apache",\n    "extensions": ["sgi"]\n  },\n  "image/svg+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["svg","svgz"]\n  },\n  "image/t38": {\n    "source": "iana",\n    "extensions": ["t38"]\n  },\n  "image/tiff": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["tif","tiff"]\n  },\n  "image/tiff-fx": {\n    "source": "iana",\n    "extensions": ["tfx"]\n  },\n  "image/vnd.adobe.photoshop": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["psd"]\n  },\n  "image/vnd.airzip.accelerator.azv": {\n    "source": "iana",\n    "extensions": ["azv"]\n  },\n  "image/vnd.cns.inf2": {\n    "source": "iana"\n  },\n  "image/vnd.dece.graphic": {\n    "source": "iana",\n    "extensions": ["uvi","uvvi","uvg","uvvg"]\n  },\n  "image/vnd.djvu": {\n    "source": "iana",\n    "extensions": ["djvu","djv"]\n  },\n  "image/vnd.dvb.subtitle": {\n    "source": "iana",\n    "extensions": ["sub"]\n  },\n  "image/vnd.dwg": {\n    "source": "iana",\n    "extensions": ["dwg"]\n  },\n  "image/vnd.dxf": {\n    "source": "iana",\n    "extensions": ["dxf"]\n  },\n  "image/vnd.fastbidsheet": {\n    "source": "iana",\n    "extensions": ["fbs"]\n  },\n  "image/vnd.fpx": {\n    "source": "iana",\n    "extensions": ["fpx"]\n  },\n  "image/vnd.fst": {\n    "source": "iana",\n    "extensions": ["fst"]\n  },\n  "image/vnd.fujixerox.edmics-mmr": {\n    "source": "iana",\n    "extensions": ["mmr"]\n  },\n  "image/vnd.fujixerox.edmics-rlc": {\n    "source": "iana",\n    "extensions": ["rlc"]\n  },\n  "image/vnd.globalgraphics.pgb": {\n    "source": "iana"\n  },\n  "image/vnd.microsoft.icon": {\n    "source": "iana",\n    "extensions": ["ico"]\n  },\n  "image/vnd.mix": {\n    "source": "iana"\n  },\n  "image/vnd.mozilla.apng": {\n    "source": "iana"\n  },\n  "image/vnd.ms-dds": {\n    "extensions": ["dds"]\n  },\n  "image/vnd.ms-modi": {\n    "source": "iana",\n    "extensions": ["mdi"]\n  },\n  "image/vnd.ms-photo": {\n    "source": "apache",\n    "extensions": ["wdp"]\n  },\n  "image/vnd.net-fpx": {\n    "source": "iana",\n    "extensions": ["npx"]\n  },\n  "image/vnd.pco.b16": {\n    "source": "iana",\n    "extensions": ["b16"]\n  },\n  "image/vnd.radiance": {\n    "source": "iana"\n  },\n  "image/vnd.sealed.png": {\n    "source": "iana"\n  },\n  "image/vnd.sealedmedia.softseal.gif": {\n    "source": "iana"\n  },\n  "image/vnd.sealedmedia.softseal.jpg": {\n    "source": "iana"\n  },\n  "image/vnd.svf": {\n    "source": "iana"\n  },\n  "image/vnd.tencent.tap": {\n    "source": "iana",\n    "extensions": ["tap"]\n  },\n  "image/vnd.valve.source.texture": {\n    "source": "iana",\n    "extensions": ["vtf"]\n  },\n  "image/vnd.wap.wbmp": {\n    "source": "iana",\n    "extensions": ["wbmp"]\n  },\n  "image/vnd.xiff": {\n    "source": "iana",\n    "extensions": ["xif"]\n  },\n  "image/vnd.zbrush.pcx": {\n    "source": "iana",\n    "extensions": ["pcx"]\n  },\n  "image/webp": {\n    "source": "apache",\n    "extensions": ["webp"]\n  },\n  "image/wmf": {\n    "source": "iana",\n    "extensions": ["wmf"]\n  },\n  "image/x-3ds": {\n    "source": "apache",\n    "extensions": ["3ds"]\n  },\n  "image/x-cmu-raster": {\n    "source": "apache",\n    "extensions": ["ras"]\n  },\n  "image/x-cmx": {\n    "source": "apache",\n    "extensions": ["cmx"]\n  },\n  "image/x-freehand": {\n    "source": "apache",\n    "extensions": ["fh","fhc","fh4","fh5","fh7"]\n  },\n  "image/x-icon": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["ico"]\n  },\n  "image/x-jng": {\n    "source": "nginx",\n    "extensions": ["jng"]\n  },\n  "image/x-mrsid-image": {\n    "source": "apache",\n    "extensions": ["sid"]\n  },\n  "image/x-ms-bmp": {\n    "source": "nginx",\n    "compressible": true,\n    "extensions": ["bmp"]\n  },\n  "image/x-pcx": {\n    "source": "apache",\n    "extensions": ["pcx"]\n  },\n  "image/x-pict": {\n    "source": "apache",\n    "extensions": ["pic","pct"]\n  },\n  "image/x-portable-anymap": {\n    "source": "apache",\n    "extensions": ["pnm"]\n  },\n  "image/x-portable-bitmap": {\n    "source": "apache",\n    "extensions": ["pbm"]\n  },\n  "image/x-portable-graymap": {\n    "source": "apache",\n    "extensions": ["pgm"]\n  },\n  "image/x-portable-pixmap": {\n    "source": "apache",\n    "extensions": ["ppm"]\n  },\n  "image/x-rgb": {\n    "source": "apache",\n    "extensions": ["rgb"]\n  },\n  "image/x-tga": {\n    "source": "apache",\n    "extensions": ["tga"]\n  },\n  "image/x-xbitmap": {\n    "source": "apache",\n    "extensions": ["xbm"]\n  },\n  "image/x-xcf": {\n    "compressible": false\n  },\n  "image/x-xpixmap": {\n    "source": "apache",\n    "extensions": ["xpm"]\n  },\n  "image/x-xwindowdump": {\n    "source": "apache",\n    "extensions": ["xwd"]\n  },\n  "message/cpim": {\n    "source": "iana"\n  },\n  "message/delivery-status": {\n    "source": "iana"\n  },\n  "message/disposition-notification": {\n    "source": "iana",\n    "extensions": [\n      "disposition-notification"\n    ]\n  },\n  "message/external-body": {\n    "source": "iana"\n  },\n  "message/feedback-report": {\n    "source": "iana"\n  },\n  "message/global": {\n    "source": "iana",\n    "extensions": ["u8msg"]\n  },\n  "message/global-delivery-status": {\n    "source": "iana",\n    "extensions": ["u8dsn"]\n  },\n  "message/global-disposition-notification": {\n    "source": "iana",\n    "extensions": ["u8mdn"]\n  },\n  "message/global-headers": {\n    "source": "iana",\n    "extensions": ["u8hdr"]\n  },\n  "message/http": {\n    "source": "iana",\n    "compressible": false\n  },\n  "message/imdn+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "message/news": {\n    "source": "iana"\n  },\n  "message/partial": {\n    "source": "iana",\n    "compressible": false\n  },\n  "message/rfc822": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["eml","mime"]\n  },\n  "message/s-http": {\n    "source": "iana"\n  },\n  "message/sip": {\n    "source": "iana"\n  },\n  "message/sipfrag": {\n    "source": "iana"\n  },\n  "message/tracking-status": {\n    "source": "iana"\n  },\n  "message/vnd.si.simp": {\n    "source": "iana"\n  },\n  "message/vnd.wfa.wsc": {\n    "source": "iana",\n    "extensions": ["wsc"]\n  },\n  "model/3mf": {\n    "source": "iana",\n    "extensions": ["3mf"]\n  },\n  "model/e57": {\n    "source": "iana"\n  },\n  "model/gltf+json": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["gltf"]\n  },\n  "model/gltf-binary": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["glb"]\n  },\n  "model/iges": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["igs","iges"]\n  },\n  "model/mesh": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["msh","mesh","silo"]\n  },\n  "model/mtl": {\n    "source": "iana",\n    "extensions": ["mtl"]\n  },\n  "model/obj": {\n    "source": "iana",\n    "extensions": ["obj"]\n  },\n  "model/stl": {\n    "source": "iana",\n    "extensions": ["stl"]\n  },\n  "model/vnd.collada+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["dae"]\n  },\n  "model/vnd.dwf": {\n    "source": "iana",\n    "extensions": ["dwf"]\n  },\n  "model/vnd.flatland.3dml": {\n    "source": "iana"\n  },\n  "model/vnd.gdl": {\n    "source": "iana",\n    "extensions": ["gdl"]\n  },\n  "model/vnd.gs-gdl": {\n    "source": "apache"\n  },\n  "model/vnd.gs.gdl": {\n    "source": "iana"\n  },\n  "model/vnd.gtw": {\n    "source": "iana",\n    "extensions": ["gtw"]\n  },\n  "model/vnd.moml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "model/vnd.mts": {\n    "source": "iana",\n    "extensions": ["mts"]\n  },\n  "model/vnd.opengex": {\n    "source": "iana",\n    "extensions": ["ogex"]\n  },\n  "model/vnd.parasolid.transmit.binary": {\n    "source": "iana",\n    "extensions": ["x_b"]\n  },\n  "model/vnd.parasolid.transmit.text": {\n    "source": "iana",\n    "extensions": ["x_t"]\n  },\n  "model/vnd.rosette.annotated-data-model": {\n    "source": "iana"\n  },\n  "model/vnd.usdz+zip": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["usdz"]\n  },\n  "model/vnd.valve.source.compiled-map": {\n    "source": "iana",\n    "extensions": ["bsp"]\n  },\n  "model/vnd.vtu": {\n    "source": "iana",\n    "extensions": ["vtu"]\n  },\n  "model/vrml": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["wrl","vrml"]\n  },\n  "model/x3d+binary": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["x3db","x3dbz"]\n  },\n  "model/x3d+fastinfoset": {\n    "source": "iana",\n    "extensions": ["x3db"]\n  },\n  "model/x3d+vrml": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["x3dv","x3dvz"]\n  },\n  "model/x3d+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["x3d","x3dz"]\n  },\n  "model/x3d-vrml": {\n    "source": "iana",\n    "extensions": ["x3dv"]\n  },\n  "multipart/alternative": {\n    "source": "iana",\n    "compressible": false\n  },\n  "multipart/appledouble": {\n    "source": "iana"\n  },\n  "multipart/byteranges": {\n    "source": "iana"\n  },\n  "multipart/digest": {\n    "source": "iana"\n  },\n  "multipart/encrypted": {\n    "source": "iana",\n    "compressible": false\n  },\n  "multipart/form-data": {\n    "source": "iana",\n    "compressible": false\n  },\n  "multipart/header-set": {\n    "source": "iana"\n  },\n  "multipart/mixed": {\n    "source": "iana"\n  },\n  "multipart/multilingual": {\n    "source": "iana"\n  },\n  "multipart/parallel": {\n    "source": "iana"\n  },\n  "multipart/related": {\n    "source": "iana",\n    "compressible": false\n  },\n  "multipart/report": {\n    "source": "iana"\n  },\n  "multipart/signed": {\n    "source": "iana",\n    "compressible": false\n  },\n  "multipart/vnd.bint.med-plus": {\n    "source": "iana"\n  },\n  "multipart/voice-message": {\n    "source": "iana"\n  },\n  "multipart/x-mixed-replace": {\n    "source": "iana"\n  },\n  "text/1d-interleaved-parityfec": {\n    "source": "iana"\n  },\n  "text/cache-manifest": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["appcache","manifest"]\n  },\n  "text/calendar": {\n    "source": "iana",\n    "extensions": ["ics","ifb"]\n  },\n  "text/calender": {\n    "compressible": true\n  },\n  "text/cmd": {\n    "compressible": true\n  },\n  "text/coffeescript": {\n    "extensions": ["coffee","litcoffee"]\n  },\n  "text/css": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["css"]\n  },\n  "text/csv": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["csv"]\n  },\n  "text/csv-schema": {\n    "source": "iana"\n  },\n  "text/directory": {\n    "source": "iana"\n  },\n  "text/dns": {\n    "source": "iana"\n  },\n  "text/ecmascript": {\n    "source": "iana"\n  },\n  "text/encaprtp": {\n    "source": "iana"\n  },\n  "text/enriched": {\n    "source": "iana"\n  },\n  "text/flexfec": {\n    "source": "iana"\n  },\n  "text/fwdred": {\n    "source": "iana"\n  },\n  "text/gff3": {\n    "source": "iana"\n  },\n  "text/grammar-ref-list": {\n    "source": "iana"\n  },\n  "text/html": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["html","htm","shtml"]\n  },\n  "text/jade": {\n    "extensions": ["jade"]\n  },\n  "text/javascript": {\n    "source": "iana",\n    "compressible": true\n  },\n  "text/jcr-cnd": {\n    "source": "iana"\n  },\n  "text/jsx": {\n    "compressible": true,\n    "extensions": ["jsx"]\n  },\n  "text/less": {\n    "compressible": true,\n    "extensions": ["less"]\n  },\n  "text/markdown": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["markdown","md"]\n  },\n  "text/mathml": {\n    "source": "nginx",\n    "extensions": ["mml"]\n  },\n  "text/mdx": {\n    "compressible": true,\n    "extensions": ["mdx"]\n  },\n  "text/mizar": {\n    "source": "iana"\n  },\n  "text/n3": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["n3"]\n  },\n  "text/parameters": {\n    "source": "iana",\n    "charset": "UTF-8"\n  },\n  "text/parityfec": {\n    "source": "iana"\n  },\n  "text/plain": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["txt","text","conf","def","list","log","in","ini"]\n  },\n  "text/provenance-notation": {\n    "source": "iana",\n    "charset": "UTF-8"\n  },\n  "text/prs.fallenstein.rst": {\n    "source": "iana"\n  },\n  "text/prs.lines.tag": {\n    "source": "iana",\n    "extensions": ["dsc"]\n  },\n  "text/prs.prop.logic": {\n    "source": "iana"\n  },\n  "text/raptorfec": {\n    "source": "iana"\n  },\n  "text/red": {\n    "source": "iana"\n  },\n  "text/rfc822-headers": {\n    "source": "iana"\n  },\n  "text/richtext": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rtx"]\n  },\n  "text/rtf": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rtf"]\n  },\n  "text/rtp-enc-aescm128": {\n    "source": "iana"\n  },\n  "text/rtploopback": {\n    "source": "iana"\n  },\n  "text/rtx": {\n    "source": "iana"\n  },\n  "text/sgml": {\n    "source": "iana",\n    "extensions": ["sgml","sgm"]\n  },\n  "text/shaclc": {\n    "source": "iana"\n  },\n  "text/shex": {\n    "extensions": ["shex"]\n  },\n  "text/slim": {\n    "extensions": ["slim","slm"]\n  },\n  "text/spdx": {\n    "source": "iana",\n    "extensions": ["spdx"]\n  },\n  "text/strings": {\n    "source": "iana"\n  },\n  "text/stylus": {\n    "extensions": ["stylus","styl"]\n  },\n  "text/t140": {\n    "source": "iana"\n  },\n  "text/tab-separated-values": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["tsv"]\n  },\n  "text/troff": {\n    "source": "iana",\n    "extensions": ["t","tr","roff","man","me","ms"]\n  },\n  "text/turtle": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "extensions": ["ttl"]\n  },\n  "text/ulpfec": {\n    "source": "iana"\n  },\n  "text/uri-list": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["uri","uris","urls"]\n  },\n  "text/vcard": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["vcard"]\n  },\n  "text/vnd.a": {\n    "source": "iana"\n  },\n  "text/vnd.abc": {\n    "source": "iana"\n  },\n  "text/vnd.ascii-art": {\n    "source": "iana"\n  },\n  "text/vnd.curl": {\n    "source": "iana",\n    "extensions": ["curl"]\n  },\n  "text/vnd.curl.dcurl": {\n    "source": "apache",\n    "extensions": ["dcurl"]\n  },\n  "text/vnd.curl.mcurl": {\n    "source": "apache",\n    "extensions": ["mcurl"]\n  },\n  "text/vnd.curl.scurl": {\n    "source": "apache",\n    "extensions": ["scurl"]\n  },\n  "text/vnd.debian.copyright": {\n    "source": "iana",\n    "charset": "UTF-8"\n  },\n  "text/vnd.dmclientscript": {\n    "source": "iana"\n  },\n  "text/vnd.dvb.subtitle": {\n    "source": "iana",\n    "extensions": ["sub"]\n  },\n  "text/vnd.esmertec.theme-descriptor": {\n    "source": "iana",\n    "charset": "UTF-8"\n  },\n  "text/vnd.ficlab.flt": {\n    "source": "iana"\n  },\n  "text/vnd.fly": {\n    "source": "iana",\n    "extensions": ["fly"]\n  },\n  "text/vnd.fmi.flexstor": {\n    "source": "iana",\n    "extensions": ["flx"]\n  },\n  "text/vnd.gml": {\n    "source": "iana"\n  },\n  "text/vnd.graphviz": {\n    "source": "iana",\n    "extensions": ["gv"]\n  },\n  "text/vnd.hans": {\n    "source": "iana"\n  },\n  "text/vnd.hgl": {\n    "source": "iana"\n  },\n  "text/vnd.in3d.3dml": {\n    "source": "iana",\n    "extensions": ["3dml"]\n  },\n  "text/vnd.in3d.spot": {\n    "source": "iana",\n    "extensions": ["spot"]\n  },\n  "text/vnd.iptc.newsml": {\n    "source": "iana"\n  },\n  "text/vnd.iptc.nitf": {\n    "source": "iana"\n  },\n  "text/vnd.latex-z": {\n    "source": "iana"\n  },\n  "text/vnd.motorola.reflex": {\n    "source": "iana"\n  },\n  "text/vnd.ms-mediapackage": {\n    "source": "iana"\n  },\n  "text/vnd.net2phone.commcenter.command": {\n    "source": "iana"\n  },\n  "text/vnd.radisys.msml-basic-layout": {\n    "source": "iana"\n  },\n  "text/vnd.senx.warpscript": {\n    "source": "iana"\n  },\n  "text/vnd.si.uricatalogue": {\n    "source": "iana"\n  },\n  "text/vnd.sosi": {\n    "source": "iana"\n  },\n  "text/vnd.sun.j2me.app-descriptor": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "extensions": ["jad"]\n  },\n  "text/vnd.trolltech.linguist": {\n    "source": "iana",\n    "charset": "UTF-8"\n  },\n  "text/vnd.wap.si": {\n    "source": "iana"\n  },\n  "text/vnd.wap.sl": {\n    "source": "iana"\n  },\n  "text/vnd.wap.wml": {\n    "source": "iana",\n    "extensions": ["wml"]\n  },\n  "text/vnd.wap.wmlscript": {\n    "source": "iana",\n    "extensions": ["wmls"]\n  },\n  "text/vtt": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["vtt"]\n  },\n  "text/x-asm": {\n    "source": "apache",\n    "extensions": ["s","asm"]\n  },\n  "text/x-c": {\n    "source": "apache",\n    "extensions": ["c","cc","cxx","cpp","h","hh","dic"]\n  },\n  "text/x-component": {\n    "source": "nginx",\n    "extensions": ["htc"]\n  },\n  "text/x-fortran": {\n    "source": "apache",\n    "extensions": ["f","for","f77","f90"]\n  },\n  "text/x-gwt-rpc": {\n    "compressible": true\n  },\n  "text/x-handlebars-template": {\n    "extensions": ["hbs"]\n  },\n  "text/x-java-source": {\n    "source": "apache",\n    "extensions": ["java"]\n  },\n  "text/x-jquery-tmpl": {\n    "compressible": true\n  },\n  "text/x-lua": {\n    "extensions": ["lua"]\n  },\n  "text/x-markdown": {\n    "compressible": true,\n    "extensions": ["mkd"]\n  },\n  "text/x-nfo": {\n    "source": "apache",\n    "extensions": ["nfo"]\n  },\n  "text/x-opml": {\n    "source": "apache",\n    "extensions": ["opml"]\n  },\n  "text/x-org": {\n    "compressible": true,\n    "extensions": ["org"]\n  },\n  "text/x-pascal": {\n    "source": "apache",\n    "extensions": ["p","pas"]\n  },\n  "text/x-processing": {\n    "compressible": true,\n    "extensions": ["pde"]\n  },\n  "text/x-sass": {\n    "extensions": ["sass"]\n  },\n  "text/x-scss": {\n    "extensions": ["scss"]\n  },\n  "text/x-setext": {\n    "source": "apache",\n    "extensions": ["etx"]\n  },\n  "text/x-sfv": {\n    "source": "apache",\n    "extensions": ["sfv"]\n  },\n  "text/x-suse-ymp": {\n    "compressible": true,\n    "extensions": ["ymp"]\n  },\n  "text/x-uuencode": {\n    "source": "apache",\n    "extensions": ["uu"]\n  },\n  "text/x-vcalendar": {\n    "source": "apache",\n    "extensions": ["vcs"]\n  },\n  "text/x-vcard": {\n    "source": "apache",\n    "extensions": ["vcf"]\n  },\n  "text/xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xml"]\n  },\n  "text/xml-external-parsed-entity": {\n    "source": "iana"\n  },\n  "text/yaml": {\n    "extensions": ["yaml","yml"]\n  },\n  "video/1d-interleaved-parityfec": {\n    "source": "iana"\n  },\n  "video/3gpp": {\n    "source": "iana",\n    "extensions": ["3gp","3gpp"]\n  },\n  "video/3gpp-tt": {\n    "source": "iana"\n  },\n  "video/3gpp2": {\n    "source": "iana",\n    "extensions": ["3g2"]\n  },\n  "video/bmpeg": {\n    "source": "iana"\n  },\n  "video/bt656": {\n    "source": "iana"\n  },\n  "video/celb": {\n    "source": "iana"\n  },\n  "video/dv": {\n    "source": "iana"\n  },\n  "video/encaprtp": {\n    "source": "iana"\n  },\n  "video/flexfec": {\n    "source": "iana"\n  },\n  "video/h261": {\n    "source": "iana",\n    "extensions": ["h261"]\n  },\n  "video/h263": {\n    "source": "iana",\n    "extensions": ["h263"]\n  },\n  "video/h263-1998": {\n    "source": "iana"\n  },\n  "video/h263-2000": {\n    "source": "iana"\n  },\n  "video/h264": {\n    "source": "iana",\n    "extensions": ["h264"]\n  },\n  "video/h264-rcdo": {\n    "source": "iana"\n  },\n  "video/h264-svc": {\n    "source": "iana"\n  },\n  "video/h265": {\n    "source": "iana"\n  },\n  "video/iso.segment": {\n    "source": "iana"\n  },\n  "video/jpeg": {\n    "source": "iana",\n    "extensions": ["jpgv"]\n  },\n  "video/jpeg2000": {\n    "source": "iana"\n  },\n  "video/jpm": {\n    "source": "apache",\n    "extensions": ["jpm","jpgm"]\n  },\n  "video/mj2": {\n    "source": "iana",\n    "extensions": ["mj2","mjp2"]\n  },\n  "video/mp1s": {\n    "source": "iana"\n  },\n  "video/mp2p": {\n    "source": "iana"\n  },\n  "video/mp2t": {\n    "source": "iana",\n    "extensions": ["ts"]\n  },\n  "video/mp4": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["mp4","mp4v","mpg4"]\n  },\n  "video/mp4v-es": {\n    "source": "iana"\n  },\n  "video/mpeg": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["mpeg","mpg","mpe","m1v","m2v"]\n  },\n  "video/mpeg4-generic": {\n    "source": "iana"\n  },\n  "video/mpv": {\n    "source": "iana"\n  },\n  "video/nv": {\n    "source": "iana"\n  },\n  "video/ogg": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["ogv"]\n  },\n  "video/parityfec": {\n    "source": "iana"\n  },\n  "video/pointer": {\n    "source": "iana"\n  },\n  "video/quicktime": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["qt","mov"]\n  },\n  "video/raptorfec": {\n    "source": "iana"\n  },\n  "video/raw": {\n    "source": "iana"\n  },\n  "video/rtp-enc-aescm128": {\n    "source": "iana"\n  },\n  "video/rtploopback": {\n    "source": "iana"\n  },\n  "video/rtx": {\n    "source": "iana"\n  },\n  "video/smpte291": {\n    "source": "iana"\n  },\n  "video/smpte292m": {\n    "source": "iana"\n  },\n  "video/ulpfec": {\n    "source": "iana"\n  },\n  "video/vc1": {\n    "source": "iana"\n  },\n  "video/vc2": {\n    "source": "iana"\n  },\n  "video/vnd.cctv": {\n    "source": "iana"\n  },\n  "video/vnd.dece.hd": {\n    "source": "iana",\n    "extensions": ["uvh","uvvh"]\n  },\n  "video/vnd.dece.mobile": {\n    "source": "iana",\n    "extensions": ["uvm","uvvm"]\n  },\n  "video/vnd.dece.mp4": {\n    "source": "iana"\n  },\n  "video/vnd.dece.pd": {\n    "source": "iana",\n    "extensions": ["uvp","uvvp"]\n  },\n  "video/vnd.dece.sd": {\n    "source": "iana",\n    "extensions": ["uvs","uvvs"]\n  },\n  "video/vnd.dece.video": {\n    "source": "iana",\n    "extensions": ["uvv","uvvv"]\n  },\n  "video/vnd.directv.mpeg": {\n    "source": "iana"\n  },\n  "video/vnd.directv.mpeg-tts": {\n    "source": "iana"\n  },\n  "video/vnd.dlna.mpeg-tts": {\n    "source": "iana"\n  },\n  "video/vnd.dvb.file": {\n    "source": "iana",\n    "extensions": ["dvb"]\n  },\n  "video/vnd.fvt": {\n    "source": "iana",\n    "extensions": ["fvt"]\n  },\n  "video/vnd.hns.video": {\n    "source": "iana"\n  },\n  "video/vnd.iptvforum.1dparityfec-1010": {\n    "source": "iana"\n  },\n  "video/vnd.iptvforum.1dparityfec-2005": {\n    "source": "iana"\n  },\n  "video/vnd.iptvforum.2dparityfec-1010": {\n    "source": "iana"\n  },\n  "video/vnd.iptvforum.2dparityfec-2005": {\n    "source": "iana"\n  },\n  "video/vnd.iptvforum.ttsavc": {\n    "source": "iana"\n  },\n  "video/vnd.iptvforum.ttsmpeg2": {\n    "source": "iana"\n  },\n  "video/vnd.motorola.video": {\n    "source": "iana"\n  },\n  "video/vnd.motorola.videop": {\n    "source": "iana"\n  },\n  "video/vnd.mpegurl": {\n    "source": "iana",\n    "extensions": ["mxu","m4u"]\n  },\n  "video/vnd.ms-playready.media.pyv": {\n    "source": "iana",\n    "extensions": ["pyv"]\n  },\n  "video/vnd.nokia.interleaved-multimedia": {\n    "source": "iana"\n  },\n  "video/vnd.nokia.mp4vr": {\n    "source": "iana"\n  },\n  "video/vnd.nokia.videovoip": {\n    "source": "iana"\n  },\n  "video/vnd.objectvideo": {\n    "source": "iana"\n  },\n  "video/vnd.radgamettools.bink": {\n    "source": "iana"\n  },\n  "video/vnd.radgamettools.smacker": {\n    "source": "iana"\n  },\n  "video/vnd.sealed.mpeg1": {\n    "source": "iana"\n  },\n  "video/vnd.sealed.mpeg4": {\n    "source": "iana"\n  },\n  "video/vnd.sealed.swf": {\n    "source": "iana"\n  },\n  "video/vnd.sealedmedia.softseal.mov": {\n    "source": "iana"\n  },\n  "video/vnd.uvvu.mp4": {\n    "source": "iana",\n    "extensions": ["uvu","uvvu"]\n  },\n  "video/vnd.vivo": {\n    "source": "iana",\n    "extensions": ["viv"]\n  },\n  "video/vnd.youtube.yt": {\n    "source": "iana"\n  },\n  "video/vp8": {\n    "source": "iana"\n  },\n  "video/webm": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["webm"]\n  },\n  "video/x-f4v": {\n    "source": "apache",\n    "extensions": ["f4v"]\n  },\n  "video/x-fli": {\n    "source": "apache",\n    "extensions": ["fli"]\n  },\n  "video/x-flv": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["flv"]\n  },\n  "video/x-m4v": {\n    "source": "apache",\n    "extensions": ["m4v"]\n  },\n  "video/x-matroska": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["mkv","mk3d","mks"]\n  },\n  "video/x-mng": {\n    "source": "apache",\n    "extensions": ["mng"]\n  },\n  "video/x-ms-asf": {\n    "source": "apache",\n    "extensions": ["asf","asx"]\n  },\n  "video/x-ms-vob": {\n    "source": "apache",\n    "extensions": ["vob"]\n  },\n  "video/x-ms-wm": {\n    "source": "apache",\n    "extensions": ["wm"]\n  },\n  "video/x-ms-wmv": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["wmv"]\n  },\n  "video/x-ms-wmx": {\n    "source": "apache",\n    "extensions": ["wmx"]\n  },\n  "video/x-ms-wvx": {\n    "source": "apache",\n    "extensions": ["wvx"]\n  },\n  "video/x-msvideo": {\n    "source": "apache",\n    "extensions": ["avi"]\n  },\n  "video/x-sgi-movie": {\n    "source": "apache",\n    "extensions": ["movie"]\n  },\n  "video/x-smv": {\n    "source": "apache",\n    "extensions": ["smv"]\n  },\n  "x-conference/x-cooltalk": {\n    "source": "apache",\n    "extensions": ["ice"]\n  },\n  "x-shader/x-fragment": {\n    "compressible": true\n  },\n  "x-shader/x-vertex": {\n    "compressible": true\n  }\n}`);
const CHAR_FORWARD_SLASH1 = 47;
let NATIVE_OS1 = "linux";
const navigator1 = globalThis.navigator;
if (globalThis.Deno != null) {
    NATIVE_OS1 = Deno.build.os;
} else if (navigator1?.appVersion?.includes?.("Win") ?? false) {
    NATIVE_OS1 = "windows";
}
const isWindows1 = NATIVE_OS1 == "windows";
function assertPath1(path1) {
    if (typeof path1 !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path1)}`);
    }
}
function isPosixPathSeparator1(code) {
    return code === 47;
}
function isPathSeparator1(code) {
    return isPosixPathSeparator1(code) || code === 92;
}
function isWindowsDeviceRoot1(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString1(path1, allowAboveRoot, separator, isPathSeparator2) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i4 = 0, len = path1.length; i4 <= len; ++i4){
        if (i4 < len) code = path1.charCodeAt(i4);
        else if (isPathSeparator2(code)) break;
        else code = CHAR_FORWARD_SLASH1;
        if (isPathSeparator2(code)) {
            if (lastSlash === i4 - 1 || dots === 1) {
            } else if (lastSlash !== i4 - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i4;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i4;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path1.slice(lastSlash + 1, i4);
                else res = path1.slice(lastSlash + 1, i4);
                lastSegmentLength = i4 - lastSlash - 1;
            }
            lastSlash = i4;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format1(sep3, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep3 + base;
}
class DenoStdInternalError1 extends Error {
    constructor(message2){
        super(message2);
        this.name = "DenoStdInternalError";
    }
}
function assert2(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError1(msg);
    }
}
const sep3 = "\\";
const delimiter3 = ";";
function resolve4(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i4 = pathSegments.length - 1; i4 >= -1; i4--){
        let path1;
        if (i4 >= 0) {
            path1 = pathSegments[i4];
        } else if (!resolvedDevice) {
            if (globalThis.Deno == null) {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path1 = Deno.cwd();
        } else {
            if (globalThis.Deno == null) {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path1 = Deno.env.get(`=${resolvedDevice}`) || Deno.cwd();
            if (path1 === undefined || path1.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path1 = `${resolvedDevice}\\`;
            }
        }
        assertPath1(path1);
        const len = path1.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute3 = false;
        const code = path1.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator1(code)) {
                isAbsolute3 = true;
                if (isPathSeparator1(path1.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator1(path1.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path1.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator1(path1.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator1(path1.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path1.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path1.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot1(code)) {
                if (path1.charCodeAt(1) === 58) {
                    device = path1.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator1(path1.charCodeAt(2))) {
                            isAbsolute3 = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator1(code)) {
            rootEnd = 1;
            isAbsolute3 = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path1.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute3;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString1(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator1);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize3(path1) {
    assertPath1(path1);
    const len = path1.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute3 = false;
    const code = path1.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code)) {
            isAbsolute3 = true;
            if (isPathSeparator1(path1.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path1.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path1.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path1.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path1.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path1.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path1.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot1(code)) {
            if (path1.charCodeAt(1) === 58) {
                device = path1.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator1(path1.charCodeAt(2))) {
                        isAbsolute3 = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator1(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString1(path1.slice(rootEnd), !isAbsolute3, "\\", isPathSeparator1);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute3) tail = ".";
    if (tail.length > 0 && isPathSeparator1(path1.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute3) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute3) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute3(path1) {
    assertPath1(path1);
    const len = path1.length;
    if (len === 0) return false;
    const code = path1.charCodeAt(0);
    if (isPathSeparator1(code)) {
        return true;
    } else if (isWindowsDeviceRoot1(code)) {
        if (len > 2 && path1.charCodeAt(1) === 58) {
            if (isPathSeparator1(path1.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join3(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i4 = 0; i4 < pathsCount; ++i4){
        const path1 = paths[i4];
        assertPath1(path1);
        if (path1.length > 0) {
            if (joined === undefined) joined = firstPart = path1;
            else joined += `\\${path1}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert2(firstPart != null);
    if (isPathSeparator1(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator1(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator1(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator1(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize3(joined);
}
function relative3(from2, to) {
    assertPath1(from2);
    assertPath1(to);
    if (from2 === to) return "";
    const fromOrig = resolve4(from2);
    const toOrig = resolve4(to);
    if (fromOrig === toOrig) return "";
    from2 = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from2 === to) return "";
    let fromStart = 0;
    let fromEnd = from2.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from2.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from2.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i4 = 0;
    for(; i4 <= length; ++i4){
        if (i4 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i4) === 92) {
                    return toOrig.slice(toStart + i4 + 1);
                } else if (i4 === 2) {
                    return toOrig.slice(toStart + i4);
                }
            }
            if (fromLen > length) {
                if (from2.charCodeAt(fromStart + i4) === 92) {
                    lastCommonSep = i4;
                } else if (i4 === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from2.charCodeAt(fromStart + i4);
        const toCode = to.charCodeAt(toStart + i4);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i4;
    }
    if (i4 !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i4 = fromStart + lastCommonSep + 1; i4 <= fromEnd; ++i4){
        if (i4 === fromEnd || from2.charCodeAt(i4) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath3(path1) {
    if (typeof path1 !== "string") return path1;
    if (path1.length === 0) return "";
    const resolvedPath = resolve4(path1);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot1(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path1;
}
function dirname3(path1) {
    assertPath1(path1);
    const len = path1.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path1.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator1(path1.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path1.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path1.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path1.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path1;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot1(code)) {
            if (path1.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator1(path1.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator1(code)) {
        return path1;
    }
    for(let i4 = len - 1; i4 >= offset; --i4){
        if (isPathSeparator1(path1.charCodeAt(i4))) {
            if (!matchedSlash) {
                end = i4;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path1.slice(0, end);
}
function basename3(path1, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath1(path1);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i4;
    if (path1.length >= 2) {
        const drive = path1.charCodeAt(0);
        if (isWindowsDeviceRoot1(drive)) {
            if (path1.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path1.length) {
        if (ext.length === path1.length && ext === path1) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i4 = path1.length - 1; i4 >= start; --i4){
            const code = path1.charCodeAt(i4);
            if (isPathSeparator1(code)) {
                if (!matchedSlash) {
                    start = i4 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i4 + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if ((--extIdx) === -1) {
                            end = i4;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path1.length;
        return path1.slice(start, end);
    } else {
        for(i4 = path1.length - 1; i4 >= start; --i4){
            if (isPathSeparator1(path1.charCodeAt(i4))) {
                if (!matchedSlash) {
                    start = i4 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i4 + 1;
            }
        }
        if (end === -1) return "";
        return path1.slice(start, end);
    }
}
function extname3(path1) {
    assertPath1(path1);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path1.length >= 2 && path1.charCodeAt(1) === 58 && isWindowsDeviceRoot1(path1.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i4 = path1.length - 1; i4 >= start; --i4){
        const code = path1.charCodeAt(i4);
        if (isPathSeparator1(code)) {
            if (!matchedSlash) {
                startPart = i4 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i4 + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i4;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path1.slice(startDot, end);
}
function format3(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format1("\\", pathObject);
}
function parse4(path1) {
    assertPath1(path1);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path1.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path1.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code)) {
            rootEnd = 1;
            if (isPathSeparator1(path1.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path1.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path1.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path1.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot1(code)) {
            if (path1.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator1(path1.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path1;
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path1;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator1(code)) {
        ret.root = ret.dir = path1;
        return ret;
    }
    if (rootEnd > 0) ret.root = path1.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i4 = path1.length - 1;
    let preDotState = 0;
    for(; i4 >= rootEnd; --i4){
        code = path1.charCodeAt(i4);
        if (isPathSeparator1(code)) {
            if (!matchedSlash) {
                startPart = i4 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i4 + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i4;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path1.slice(startPart, end);
        }
    } else {
        ret.name = path1.slice(startPart, startDot);
        ret.base = path1.slice(startPart, end);
        ret.ext = path1.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path1.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl3(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path1 = decodeURIComponent(url.pathname.replace(/^\/*([A-Za-z]:)(\/|$)/, "$1/").replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
    if (url.hostname != "") {
        path1 = `\\\\${url.hostname}${path1}`;
    }
    return path1;
}
const mod2 = function() {
    return {
        sep: sep3,
        delimiter: delimiter3,
        resolve: resolve4,
        normalize: normalize3,
        isAbsolute: isAbsolute3,
        join: join3,
        relative: relative3,
        toNamespacedPath: toNamespacedPath3,
        dirname: dirname3,
        basename: basename3,
        extname: extname3,
        format: format3,
        parse: parse4,
        fromFileUrl: fromFileUrl3
    };
}();
const sep4 = "/";
const delimiter4 = ":";
function resolve5(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i4 = pathSegments.length - 1; i4 >= -1 && !resolvedAbsolute; i4--){
        let path1;
        if (i4 >= 0) path1 = pathSegments[i4];
        else {
            if (globalThis.Deno == null) {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path1 = Deno.cwd();
        }
        assertPath1(path1);
        if (path1.length === 0) {
            continue;
        }
        resolvedPath = `${path1}/${resolvedPath}`;
        resolvedAbsolute = path1.charCodeAt(0) === CHAR_FORWARD_SLASH1;
    }
    resolvedPath = normalizeString1(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator1);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize4(path1) {
    assertPath1(path1);
    if (path1.length === 0) return ".";
    const isAbsolute4 = path1.charCodeAt(0) === 47;
    const trailingSeparator = path1.charCodeAt(path1.length - 1) === 47;
    path1 = normalizeString1(path1, !isAbsolute4, "/", isPosixPathSeparator1);
    if (path1.length === 0 && !isAbsolute4) path1 = ".";
    if (path1.length > 0 && trailingSeparator) path1 += "/";
    if (isAbsolute4) return `/${path1}`;
    return path1;
}
function isAbsolute4(path1) {
    assertPath1(path1);
    return path1.length > 0 && path1.charCodeAt(0) === 47;
}
function join4(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i4 = 0, len = paths.length; i4 < len; ++i4){
        const path1 = paths[i4];
        assertPath1(path1);
        if (path1.length > 0) {
            if (!joined) joined = path1;
            else joined += `/${path1}`;
        }
    }
    if (!joined) return ".";
    return normalize4(joined);
}
function relative4(from2, to) {
    assertPath1(from2);
    assertPath1(to);
    if (from2 === to) return "";
    from2 = resolve5(from2);
    to = resolve5(to);
    if (from2 === to) return "";
    let fromStart = 1;
    const fromEnd = from2.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from2.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i4 = 0;
    for(; i4 <= length; ++i4){
        if (i4 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i4) === 47) {
                    return to.slice(toStart + i4 + 1);
                } else if (i4 === 0) {
                    return to.slice(toStart + i4);
                }
            } else if (fromLen > length) {
                if (from2.charCodeAt(fromStart + i4) === 47) {
                    lastCommonSep = i4;
                } else if (i4 === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from2.charCodeAt(fromStart + i4);
        const toCode = to.charCodeAt(toStart + i4);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i4;
    }
    let out = "";
    for(i4 = fromStart + lastCommonSep + 1; i4 <= fromEnd; ++i4){
        if (i4 === fromEnd || from2.charCodeAt(i4) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath4(path1) {
    return path1;
}
function dirname4(path1) {
    assertPath1(path1);
    if (path1.length === 0) return ".";
    const hasRoot = path1.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i4 = path1.length - 1; i4 >= 1; --i4){
        if (path1.charCodeAt(i4) === 47) {
            if (!matchedSlash) {
                end = i4;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path1.slice(0, end);
}
function basename4(path1, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath1(path1);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i4;
    if (ext !== undefined && ext.length > 0 && ext.length <= path1.length) {
        if (ext.length === path1.length && ext === path1) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i4 = path1.length - 1; i4 >= 0; --i4){
            const code = path1.charCodeAt(i4);
            if (code === 47) {
                if (!matchedSlash) {
                    start = i4 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i4 + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if ((--extIdx) === -1) {
                            end = i4;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path1.length;
        return path1.slice(start, end);
    } else {
        for(i4 = path1.length - 1; i4 >= 0; --i4){
            if (path1.charCodeAt(i4) === 47) {
                if (!matchedSlash) {
                    start = i4 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i4 + 1;
            }
        }
        if (end === -1) return "";
        return path1.slice(start, end);
    }
}
function extname4(path1) {
    assertPath1(path1);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i4 = path1.length - 1; i4 >= 0; --i4){
        const code = path1.charCodeAt(i4);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i4 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i4 + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i4;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path1.slice(startDot, end);
}
function format4(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format1("/", pathObject);
}
function parse5(path1) {
    assertPath1(path1);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path1.length === 0) return ret;
    const isAbsolute5 = path1.charCodeAt(0) === 47;
    let start;
    if (isAbsolute5) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i4 = path1.length - 1;
    let preDotState = 0;
    for(; i4 >= start; --i4){
        const code = path1.charCodeAt(i4);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i4 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i4 + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i4;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute5) {
                ret.base = ret.name = path1.slice(1, end);
            } else {
                ret.base = ret.name = path1.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute5) {
            ret.name = path1.slice(1, startDot);
            ret.base = path1.slice(1, end);
        } else {
            ret.name = path1.slice(startPart, startDot);
            ret.base = path1.slice(startPart, end);
        }
        ret.ext = path1.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path1.slice(0, startPart - 1);
    else if (isAbsolute5) ret.dir = "/";
    return ret;
}
function fromFileUrl4(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
const mod3 = function() {
    return {
        sep: sep4,
        delimiter: delimiter4,
        resolve: resolve5,
        normalize: normalize4,
        isAbsolute: isAbsolute4,
        join: join4,
        relative: relative4,
        toNamespacedPath: toNamespacedPath4,
        dirname: dirname4,
        basename: basename4,
        extname: extname4,
        format: format4,
        parse: parse5,
        fromFileUrl: fromFileUrl4
    };
}();
const path1 = isWindows1 ? mod2 : mod3;
const { basename: basename5 , delimiter: delimiter5 , dirname: dirname5 , extname: extname5 , format: format5 , fromFileUrl: fromFileUrl5 , isAbsolute: isAbsolute5 , join: join5 , normalize: normalize5 , parse: parse6 , relative: relative5 , resolve: resolve6 , sep: sep5 , toNamespacedPath: toNamespacedPath5 ,  } = path1;
const EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
const TEXT_TYPE_REGEXP = /^text\//i;
const extensions = new Map();
const types2 = new Map();
function populateMaps(extensions1, types1) {
    const preference = [
        "nginx",
        "apache",
        undefined,
        "iana"
    ];
    for (const type of Object.keys(db)){
        const mime = db[type];
        const exts = mime.extensions;
        if (!exts || !exts.length) {
            continue;
        }
        extensions1.set(type, exts);
        for (const ext of exts){
            const current = types1.get(ext);
            if (current) {
                const from2 = preference.indexOf(db[current].source);
                const to = preference.indexOf(mime.source);
                if (current !== "application/octet-stream" && (from2 > to || from2 === to && current.substr(0, 12) === "application/")) {
                    continue;
                }
            }
            types1.set(ext, type);
        }
    }
}
populateMaps(extensions, types2);
function charset(type) {
    const m = EXTRACT_TYPE_REGEXP.exec(type);
    if (!m) {
        return;
    }
    const [match] = m;
    const mime = db[match.toLowerCase()];
    if (mime && mime.charset) {
        return mime.charset;
    }
    if (TEXT_TYPE_REGEXP.test(match)) {
        return "UTF-8";
    }
}
function lookup(path2) {
    const extension = extname5("x." + path2).toLowerCase().substr(1);
    return types2.get(extension);
}
function contentType(str1) {
    let mime = str1.includes("/") ? str1 : lookup(str1);
    if (!mime) {
        return;
    }
    if (!mime.includes("charset")) {
        const cs = charset(mime);
        if (cs) {
            mime += `; charset=${cs.toLowerCase()}`;
        }
    }
    return mime;
}
class DenoStdInternalError2 extends Error {
    constructor(message3){
        super(message3);
        this.name = "DenoStdInternalError";
    }
}
function assert3(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError2(msg);
    }
}
class Tokenizer1 {
    constructor(rules2 = []){
        this.rules = rules2;
    }
    addRule(test, fn) {
        this.rules.push({
            test,
            fn
        });
        return this;
    }
    tokenize(string, receiver = (token)=>token
    ) {
        function* generator(rules3) {
            let index = 0;
            for (const rule of rules3){
                const result = rule.test(string);
                if (result) {
                    const { value: value2 , length  } = result;
                    index += length;
                    string = string.slice(length);
                    const token = {
                        ...rule.fn(value2),
                        index
                    };
                    yield receiver(token);
                    yield* generator(rules3);
                }
            }
        }
        const tokenGenerator = generator(this.rules);
        const tokens = [];
        for (const token of tokenGenerator){
            tokens.push(token);
        }
        if (string.length) {
            throw new Error(`parser error: string not fully parsed! ${string.slice(0, 25)}`);
        }
        return tokens;
    }
}
function digits1(value2, count = 2) {
    return String(value2).padStart(count, "0");
}
function createLiteralTestFunction1(value2) {
    return (string)=>{
        return string.startsWith(value2) ? {
            value: value2,
            length: value2.length
        } : undefined;
    };
}
function createMatchTestFunction1(match) {
    return (string)=>{
        const result = match.exec(string);
        if (result) return {
            value: result,
            length: result[0].length
        };
    };
}
const defaultRules1 = [
    {
        test: createLiteralTestFunction1("yyyy"),
        fn: ()=>({
                type: "year",
                value: "numeric"
            })
    },
    {
        test: createLiteralTestFunction1("yy"),
        fn: ()=>({
                type: "year",
                value: "2-digit"
            })
    },
    {
        test: createLiteralTestFunction1("MM"),
        fn: ()=>({
                type: "month",
                value: "2-digit"
            })
    },
    {
        test: createLiteralTestFunction1("M"),
        fn: ()=>({
                type: "month",
                value: "numeric"
            })
    },
    {
        test: createLiteralTestFunction1("dd"),
        fn: ()=>({
                type: "day",
                value: "2-digit"
            })
    },
    {
        test: createLiteralTestFunction1("d"),
        fn: ()=>({
                type: "day",
                value: "numeric"
            })
    },
    {
        test: createLiteralTestFunction1("hh"),
        fn: ()=>({
                type: "hour",
                value: "2-digit"
            })
    },
    {
        test: createLiteralTestFunction1("h"),
        fn: ()=>({
                type: "hour",
                value: "numeric"
            })
    },
    {
        test: createLiteralTestFunction1("mm"),
        fn: ()=>({
                type: "minute",
                value: "2-digit"
            })
    },
    {
        test: createLiteralTestFunction1("m"),
        fn: ()=>({
                type: "minute",
                value: "numeric"
            })
    },
    {
        test: createLiteralTestFunction1("ss"),
        fn: ()=>({
                type: "second",
                value: "2-digit"
            })
    },
    {
        test: createLiteralTestFunction1("s"),
        fn: ()=>({
                type: "second",
                value: "numeric"
            })
    },
    {
        test: createLiteralTestFunction1("SSS"),
        fn: ()=>({
                type: "fractionalSecond",
                value: 3
            })
    },
    {
        test: createLiteralTestFunction1("SS"),
        fn: ()=>({
                type: "fractionalSecond",
                value: 2
            })
    },
    {
        test: createLiteralTestFunction1("S"),
        fn: ()=>({
                type: "fractionalSecond",
                value: 1
            })
    },
    {
        test: createLiteralTestFunction1("a"),
        fn: (value2)=>({
                type: "dayPeriod",
                value: value2
            })
    },
    {
        test: createMatchTestFunction1(/^(')(?<value>\\.|[^\']*)\1/),
        fn: (match)=>({
                type: "literal",
                value: match.groups.value
            })
    },
    {
        test: createMatchTestFunction1(/^.+?\s*/),
        fn: (match)=>({
                type: "literal",
                value: match[0]
            })
    }, 
];
class DateTimeFormatter1 {
    #format;
    constructor(formatString1, rules3 = defaultRules1){
        const tokenizer1 = new Tokenizer1(rules3);
        this.#format = tokenizer1.tokenize(formatString1, ({ type , value: value2  })=>({
                type,
                value: value2
            })
        );
    }
    format(date, options = {
    }) {
        let string = "";
        const utc = options.timeZone === "UTC";
        const hour12 = this.#format.find((token)=>token.type === "dayPeriod"
        );
        for (const token of this.#format){
            const type = token.type;
            switch(type){
                case "year":
                    {
                        const value2 = utc ? date.getUTCFullYear() : date.getFullYear();
                        switch(token.value){
                            case "numeric":
                                {
                                    string += value2;
                                    break;
                                }
                            case "2-digit":
                                {
                                    string += digits1(value2, 2).slice(-2);
                                    break;
                                }
                            default:
                                throw Error(`FormatterError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "month":
                    {
                        const value2 = (utc ? date.getUTCMonth() : date.getMonth()) + 1;
                        switch(token.value){
                            case "numeric":
                                {
                                    string += value2;
                                    break;
                                }
                            case "2-digit":
                                {
                                    string += digits1(value2, 2);
                                    break;
                                }
                            default:
                                throw Error(`FormatterError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "day":
                    {
                        const value2 = utc ? date.getUTCDate() : date.getDate();
                        switch(token.value){
                            case "numeric":
                                {
                                    string += value2;
                                    break;
                                }
                            case "2-digit":
                                {
                                    string += digits1(value2, 2);
                                    break;
                                }
                            default:
                                throw Error(`FormatterError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "hour":
                    {
                        let value2 = utc ? date.getUTCHours() : date.getHours();
                        value2 -= hour12 && date.getHours() > 12 ? 12 : 0;
                        switch(token.value){
                            case "numeric":
                                {
                                    string += value2;
                                    break;
                                }
                            case "2-digit":
                                {
                                    string += digits1(value2, 2);
                                    break;
                                }
                            default:
                                throw Error(`FormatterError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "minute":
                    {
                        const value2 = utc ? date.getUTCMinutes() : date.getMinutes();
                        switch(token.value){
                            case "numeric":
                                {
                                    string += value2;
                                    break;
                                }
                            case "2-digit":
                                {
                                    string += digits1(value2, 2);
                                    break;
                                }
                            default:
                                throw Error(`FormatterError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "second":
                    {
                        const value2 = utc ? date.getUTCSeconds() : date.getSeconds();
                        switch(token.value){
                            case "numeric":
                                {
                                    string += value2;
                                    break;
                                }
                            case "2-digit":
                                {
                                    string += digits1(value2, 2);
                                    break;
                                }
                            default:
                                throw Error(`FormatterError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "fractionalSecond":
                    {
                        const value2 = utc ? date.getUTCMilliseconds() : date.getMilliseconds();
                        string += digits1(value2, Number(token.value));
                        break;
                    }
                case "timeZoneName":
                    {
                    }
                case "dayPeriod":
                    {
                        string += hour12 ? date.getHours() >= 12 ? "PM" : "AM" : "";
                        break;
                    }
                case "literal":
                    {
                        string += token.value;
                        break;
                    }
                default:
                    throw Error(`FormatterError: { ${token.type} ${token.value} }`);
            }
        }
        return string;
    }
    parseToParts(string) {
        const parts = [];
        for (const token of this.#format){
            const type = token.type;
            let value2 = "";
            switch(token.type){
                case "year":
                    {
                        switch(token.value){
                            case "numeric":
                                {
                                    value2 = /^\d{1,4}/.exec(string)?.[0];
                                    break;
                                }
                            case "2-digit":
                                {
                                    value2 = /^\d{1,2}/.exec(string)?.[0];
                                    break;
                                }
                        }
                        break;
                    }
                case "month":
                    {
                        switch(token.value){
                            case "numeric":
                                {
                                    value2 = /^\d{1,2}/.exec(string)?.[0];
                                    break;
                                }
                            case "2-digit":
                                {
                                    value2 = /^\d{2}/.exec(string)?.[0];
                                    break;
                                }
                            case "narrow":
                                {
                                    value2 = /^[a-zA-Z]+/.exec(string)?.[0];
                                    break;
                                }
                            case "short":
                                {
                                    value2 = /^[a-zA-Z]+/.exec(string)?.[0];
                                    break;
                                }
                            case "long":
                                {
                                    value2 = /^[a-zA-Z]+/.exec(string)?.[0];
                                    break;
                                }
                            default:
                                throw Error(`ParserError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "day":
                    {
                        switch(token.value){
                            case "numeric":
                                {
                                    value2 = /^\d{1,2}/.exec(string)?.[0];
                                    break;
                                }
                            case "2-digit":
                                {
                                    value2 = /^\d{2}/.exec(string)?.[0];
                                    break;
                                }
                            default:
                                throw Error(`ParserError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "hour":
                    {
                        switch(token.value){
                            case "numeric":
                                {
                                    value2 = /^\d{1,2}/.exec(string)?.[0];
                                    break;
                                }
                            case "2-digit":
                                {
                                    value2 = /^\d{2}/.exec(string)?.[0];
                                    break;
                                }
                            default:
                                throw Error(`ParserError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "minute":
                    {
                        switch(token.value){
                            case "numeric":
                                {
                                    value2 = /^\d{1,2}/.exec(string)?.[0];
                                    break;
                                }
                            case "2-digit":
                                {
                                    value2 = /^\d{2}/.exec(string)?.[0];
                                    break;
                                }
                            default:
                                throw Error(`ParserError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "second":
                    {
                        switch(token.value){
                            case "numeric":
                                {
                                    value2 = /^\d{1,2}/.exec(string)?.[0];
                                    break;
                                }
                            case "2-digit":
                                {
                                    value2 = /^\d{2}/.exec(string)?.[0];
                                    break;
                                }
                            default:
                                throw Error(`ParserError: value "${token.value}" is not supported`);
                        }
                        break;
                    }
                case "fractionalSecond":
                    {
                        value2 = new RegExp(`^\\d{${token.value}}`).exec(string)?.[0];
                        break;
                    }
                case "timeZoneName":
                    {
                        value2 = token.value;
                        break;
                    }
                case "dayPeriod":
                    {
                        value2 = /^(A|P)M/.exec(string)?.[0];
                        break;
                    }
                case "literal":
                    {
                        if (!string.startsWith(token.value)) {
                            throw Error(`Literal "${token.value}" not found "${string.slice(0, 25)}"`);
                        }
                        value2 = token.value;
                        break;
                    }
                default:
                    throw Error(`${token.type} ${token.value}`);
            }
            if (!value2) {
                throw Error(`value not valid for token { ${type} ${value2} } ${string.slice(0, 25)}`);
            }
            parts.push({
                type,
                value: value2
            });
            string = string.slice(value2.length);
        }
        if (string.length) {
            throw Error(`datetime string was not fully parsed! ${string.slice(0, 25)}`);
        }
        return parts;
    }
    partsToDate(parts) {
        const date = new Date();
        const utc = parts.find((part)=>part.type === "timeZoneName" && part.value === "UTC"
        );
        utc ? date.setUTCHours(0, 0, 0, 0) : date.setHours(0, 0, 0, 0);
        for (const part of parts){
            switch(part.type){
                case "year":
                    {
                        const value2 = Number(part.value.padStart(4, "20"));
                        utc ? date.setUTCFullYear(value2) : date.setFullYear(value2);
                        break;
                    }
                case "month":
                    {
                        const value2 = Number(part.value) - 1;
                        utc ? date.setUTCMonth(value2) : date.setMonth(value2);
                        break;
                    }
                case "day":
                    {
                        const value2 = Number(part.value);
                        utc ? date.setUTCDate(value2) : date.setDate(value2);
                        break;
                    }
                case "hour":
                    {
                        let value2 = Number(part.value);
                        const dayPeriod = parts.find((part1)=>part1.type === "dayPeriod"
                        );
                        if (dayPeriod?.value === "PM") value2 += 12;
                        utc ? date.setUTCHours(value2) : date.setHours(value2);
                        break;
                    }
                case "minute":
                    {
                        const value2 = Number(part.value);
                        utc ? date.setUTCMinutes(value2) : date.setMinutes(value2);
                        break;
                    }
                case "second":
                    {
                        const value2 = Number(part.value);
                        utc ? date.setUTCSeconds(value2) : date.setSeconds(value2);
                        break;
                    }
                case "fractionalSecond":
                    {
                        const value2 = Number(part.value);
                        utc ? date.setUTCMilliseconds(value2) : date.setMilliseconds(value2);
                        break;
                    }
            }
        }
        return date;
    }
    parse(string) {
        const parts = this.parseToParts(string);
        return this.partsToDate(parts);
    }
}
var Day1;
(function(Day2) {
    Day2[Day2["Sun"] = 0] = "Sun";
    Day2[Day2["Mon"] = 1] = "Mon";
    Day2[Day2["Tue"] = 2] = "Tue";
    Day2[Day2["Wed"] = 3] = "Wed";
    Day2[Day2["Thu"] = 4] = "Thu";
    Day2[Day2["Fri"] = 5] = "Fri";
    Day2[Day2["Sat"] = 6] = "Sat";
})(Day1 || (Day1 = {
}));
var Status1;
(function(Status2) {
    Status2[Status2["Continue"] = 100] = "Continue";
    Status2[Status2["SwitchingProtocols"] = 101] = "SwitchingProtocols";
    Status2[Status2["Processing"] = 102] = "Processing";
    Status2[Status2["EarlyHints"] = 103] = "EarlyHints";
    Status2[Status2["OK"] = 200] = "OK";
    Status2[Status2["Created"] = 201] = "Created";
    Status2[Status2["Accepted"] = 202] = "Accepted";
    Status2[Status2["NonAuthoritativeInfo"] = 203] = "NonAuthoritativeInfo";
    Status2[Status2["NoContent"] = 204] = "NoContent";
    Status2[Status2["ResetContent"] = 205] = "ResetContent";
    Status2[Status2["PartialContent"] = 206] = "PartialContent";
    Status2[Status2["MultiStatus"] = 207] = "MultiStatus";
    Status2[Status2["AlreadyReported"] = 208] = "AlreadyReported";
    Status2[Status2["IMUsed"] = 226] = "IMUsed";
    Status2[Status2["MultipleChoices"] = 300] = "MultipleChoices";
    Status2[Status2["MovedPermanently"] = 301] = "MovedPermanently";
    Status2[Status2["Found"] = 302] = "Found";
    Status2[Status2["SeeOther"] = 303] = "SeeOther";
    Status2[Status2["NotModified"] = 304] = "NotModified";
    Status2[Status2["UseProxy"] = 305] = "UseProxy";
    Status2[Status2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    Status2[Status2["PermanentRedirect"] = 308] = "PermanentRedirect";
    Status2[Status2["BadRequest"] = 400] = "BadRequest";
    Status2[Status2["Unauthorized"] = 401] = "Unauthorized";
    Status2[Status2["PaymentRequired"] = 402] = "PaymentRequired";
    Status2[Status2["Forbidden"] = 403] = "Forbidden";
    Status2[Status2["NotFound"] = 404] = "NotFound";
    Status2[Status2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    Status2[Status2["NotAcceptable"] = 406] = "NotAcceptable";
    Status2[Status2["ProxyAuthRequired"] = 407] = "ProxyAuthRequired";
    Status2[Status2["RequestTimeout"] = 408] = "RequestTimeout";
    Status2[Status2["Conflict"] = 409] = "Conflict";
    Status2[Status2["Gone"] = 410] = "Gone";
    Status2[Status2["LengthRequired"] = 411] = "LengthRequired";
    Status2[Status2["PreconditionFailed"] = 412] = "PreconditionFailed";
    Status2[Status2["RequestEntityTooLarge"] = 413] = "RequestEntityTooLarge";
    Status2[Status2["RequestURITooLong"] = 414] = "RequestURITooLong";
    Status2[Status2["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
    Status2[Status2["RequestedRangeNotSatisfiable"] = 416] = "RequestedRangeNotSatisfiable";
    Status2[Status2["ExpectationFailed"] = 417] = "ExpectationFailed";
    Status2[Status2["Teapot"] = 418] = "Teapot";
    Status2[Status2["MisdirectedRequest"] = 421] = "MisdirectedRequest";
    Status2[Status2["UnprocessableEntity"] = 422] = "UnprocessableEntity";
    Status2[Status2["Locked"] = 423] = "Locked";
    Status2[Status2["FailedDependency"] = 424] = "FailedDependency";
    Status2[Status2["TooEarly"] = 425] = "TooEarly";
    Status2[Status2["UpgradeRequired"] = 426] = "UpgradeRequired";
    Status2[Status2["PreconditionRequired"] = 428] = "PreconditionRequired";
    Status2[Status2["TooManyRequests"] = 429] = "TooManyRequests";
    Status2[Status2["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
    Status2[Status2["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
    Status2[Status2["InternalServerError"] = 500] = "InternalServerError";
    Status2[Status2["NotImplemented"] = 501] = "NotImplemented";
    Status2[Status2["BadGateway"] = 502] = "BadGateway";
    Status2[Status2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    Status2[Status2["GatewayTimeout"] = 504] = "GatewayTimeout";
    Status2[Status2["HTTPVersionNotSupported"] = 505] = "HTTPVersionNotSupported";
    Status2[Status2["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
    Status2[Status2["InsufficientStorage"] = 507] = "InsufficientStorage";
    Status2[Status2["LoopDetected"] = 508] = "LoopDetected";
    Status2[Status2["NotExtended"] = 510] = "NotExtended";
    Status2[Status2["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";
})(Status1 || (Status1 = {
}));
const STATUS_TEXT1 = new Map([
    [
        Status1.Continue,
        "Continue"
    ],
    [
        Status1.SwitchingProtocols,
        "Switching Protocols"
    ],
    [
        Status1.Processing,
        "Processing"
    ],
    [
        Status1.EarlyHints,
        "Early Hints"
    ],
    [
        Status1.OK,
        "OK"
    ],
    [
        Status1.Created,
        "Created"
    ],
    [
        Status1.Accepted,
        "Accepted"
    ],
    [
        Status1.NonAuthoritativeInfo,
        "Non-Authoritative Information"
    ],
    [
        Status1.NoContent,
        "No Content"
    ],
    [
        Status1.ResetContent,
        "Reset Content"
    ],
    [
        Status1.PartialContent,
        "Partial Content"
    ],
    [
        Status1.MultiStatus,
        "Multi-Status"
    ],
    [
        Status1.AlreadyReported,
        "Already Reported"
    ],
    [
        Status1.IMUsed,
        "IM Used"
    ],
    [
        Status1.MultipleChoices,
        "Multiple Choices"
    ],
    [
        Status1.MovedPermanently,
        "Moved Permanently"
    ],
    [
        Status1.Found,
        "Found"
    ],
    [
        Status1.SeeOther,
        "See Other"
    ],
    [
        Status1.NotModified,
        "Not Modified"
    ],
    [
        Status1.UseProxy,
        "Use Proxy"
    ],
    [
        Status1.TemporaryRedirect,
        "Temporary Redirect"
    ],
    [
        Status1.PermanentRedirect,
        "Permanent Redirect"
    ],
    [
        Status1.BadRequest,
        "Bad Request"
    ],
    [
        Status1.Unauthorized,
        "Unauthorized"
    ],
    [
        Status1.PaymentRequired,
        "Payment Required"
    ],
    [
        Status1.Forbidden,
        "Forbidden"
    ],
    [
        Status1.NotFound,
        "Not Found"
    ],
    [
        Status1.MethodNotAllowed,
        "Method Not Allowed"
    ],
    [
        Status1.NotAcceptable,
        "Not Acceptable"
    ],
    [
        Status1.ProxyAuthRequired,
        "Proxy Authentication Required"
    ],
    [
        Status1.RequestTimeout,
        "Request Timeout"
    ],
    [
        Status1.Conflict,
        "Conflict"
    ],
    [
        Status1.Gone,
        "Gone"
    ],
    [
        Status1.LengthRequired,
        "Length Required"
    ],
    [
        Status1.PreconditionFailed,
        "Precondition Failed"
    ],
    [
        Status1.RequestEntityTooLarge,
        "Request Entity Too Large"
    ],
    [
        Status1.RequestURITooLong,
        "Request URI Too Long"
    ],
    [
        Status1.UnsupportedMediaType,
        "Unsupported Media Type"
    ],
    [
        Status1.RequestedRangeNotSatisfiable,
        "Requested Range Not Satisfiable"
    ],
    [
        Status1.ExpectationFailed,
        "Expectation Failed"
    ],
    [
        Status1.Teapot,
        "I'm a teapot"
    ],
    [
        Status1.MisdirectedRequest,
        "Misdirected Request"
    ],
    [
        Status1.UnprocessableEntity,
        "Unprocessable Entity"
    ],
    [
        Status1.Locked,
        "Locked"
    ],
    [
        Status1.FailedDependency,
        "Failed Dependency"
    ],
    [
        Status1.TooEarly,
        "Too Early"
    ],
    [
        Status1.UpgradeRequired,
        "Upgrade Required"
    ],
    [
        Status1.PreconditionRequired,
        "Precondition Required"
    ],
    [
        Status1.TooManyRequests,
        "Too Many Requests"
    ],
    [
        Status1.RequestHeaderFieldsTooLarge,
        "Request Header Fields Too Large"
    ],
    [
        Status1.UnavailableForLegalReasons,
        "Unavailable For Legal Reasons"
    ],
    [
        Status1.InternalServerError,
        "Internal Server Error"
    ],
    [
        Status1.NotImplemented,
        "Not Implemented"
    ],
    [
        Status1.BadGateway,
        "Bad Gateway"
    ],
    [
        Status1.ServiceUnavailable,
        "Service Unavailable"
    ],
    [
        Status1.GatewayTimeout,
        "Gateway Timeout"
    ],
    [
        Status1.HTTPVersionNotSupported,
        "HTTP Version Not Supported"
    ],
    [
        Status1.VariantAlsoNegotiates,
        "Variant Also Negotiates"
    ],
    [
        Status1.InsufficientStorage,
        "Insufficient Storage"
    ],
    [
        Status1.LoopDetected,
        "Loop Detected"
    ],
    [
        Status1.NotExtended,
        "Not Extended"
    ],
    [
        Status1.NetworkAuthenticationRequired,
        "Network Authentication Required"
    ], 
]);
function concat1(origin, b) {
    const output = new Uint8Array(origin.length + b.length);
    output.set(origin, 0);
    output.set(b, origin.length);
    return output;
}
function copyBytes1(src, dst, off = 0) {
    off = Math.max(0, Math.min(off, dst.byteLength));
    const dstBytesAvailable = dst.byteLength - off;
    if (src.byteLength > dstBytesAvailable) {
        src = src.subarray(0, dstBytesAvailable);
    }
    dst.set(src, off);
    return src.byteLength;
}
const DEFAULT_BUF_SIZE1 = 4096;
const MIN_BUF_SIZE1 = 16;
const CR1 = "\r".charCodeAt(0);
const LF1 = "\n".charCodeAt(0);
class BufferFullError1 extends Error {
    name = "BufferFullError";
    constructor(partial1){
        super("Buffer full");
        this.partial = partial1;
    }
}
class PartialReadError1 extends Deno.errors.UnexpectedEof {
    name = "PartialReadError";
    constructor(){
        super("Encountered UnexpectedEof, data only partially read");
    }
}
class BufReader1 {
    r = 0;
    w = 0;
    eof = false;
    static create(r, size = 4096) {
        return r instanceof BufReader1 ? r : new BufReader1(r, size);
    }
    constructor(rd2, size4 = 4096){
        if (size4 < 16) {
            size4 = MIN_BUF_SIZE1;
        }
        this._reset(new Uint8Array(size4), rd2);
    }
    size() {
        return this.buf.byteLength;
    }
    buffered() {
        return this.w - this.r;
    }
    async _fill() {
        if (this.r > 0) {
            this.buf.copyWithin(0, this.r, this.w);
            this.w -= this.r;
            this.r = 0;
        }
        if (this.w >= this.buf.byteLength) {
            throw Error("bufio: tried to fill full buffer");
        }
        for(let i4 = 100; i4 > 0; i4--){
            const rr = await this.rd.read(this.buf.subarray(this.w));
            if (rr === null) {
                this.eof = true;
                return;
            }
            assert3(rr >= 0, "negative read");
            this.w += rr;
            if (rr > 0) {
                return;
            }
        }
        throw new Error(`No progress after ${100} read() calls`);
    }
    reset(r) {
        this._reset(this.buf, r);
    }
    _reset(buf, rd) {
        this.buf = buf;
        this.rd = rd;
        this.eof = false;
    }
    async read(p) {
        let rr = p.byteLength;
        if (p.byteLength === 0) return rr;
        if (this.r === this.w) {
            if (p.byteLength >= this.buf.byteLength) {
                const rr1 = await this.rd.read(p);
                const nread = rr1 ?? 0;
                assert3(nread >= 0, "negative read");
                return rr1;
            }
            this.r = 0;
            this.w = 0;
            rr = await this.rd.read(this.buf);
            if (rr === 0 || rr === null) return rr;
            assert3(rr >= 0, "negative read");
            this.w += rr;
        }
        const copied = copyBytes1(this.buf.subarray(this.r, this.w), p, 0);
        this.r += copied;
        return copied;
    }
    async readFull(p) {
        let bytesRead = 0;
        while(bytesRead < p.length){
            try {
                const rr = await this.read(p.subarray(bytesRead));
                if (rr === null) {
                    if (bytesRead === 0) {
                        return null;
                    } else {
                        throw new PartialReadError1();
                    }
                }
                bytesRead += rr;
            } catch (err) {
                err.partial = p.subarray(0, bytesRead);
                throw err;
            }
        }
        return p;
    }
    async readByte() {
        while(this.r === this.w){
            if (this.eof) return null;
            await this._fill();
        }
        const c = this.buf[this.r];
        this.r++;
        return c;
    }
    async readString(delim) {
        if (delim.length !== 1) {
            throw new Error("Delimiter should be a single character");
        }
        const buffer = await this.readSlice(delim.charCodeAt(0));
        if (buffer === null) return null;
        return new TextDecoder().decode(buffer);
    }
    async readLine() {
        let line;
        try {
            line = await this.readSlice(LF1);
        } catch (err) {
            let { partial: partial2  } = err;
            assert3(partial2 instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
            if (!(err instanceof BufferFullError1)) {
                throw err;
            }
            if (!this.eof && partial2.byteLength > 0 && partial2[partial2.byteLength - 1] === CR1) {
                assert3(this.r > 0, "bufio: tried to rewind past start of buffer");
                this.r--;
                partial2 = partial2.subarray(0, partial2.byteLength - 1);
            }
            return {
                line: partial2,
                more: !this.eof
            };
        }
        if (line === null) {
            return null;
        }
        if (line.byteLength === 0) {
            return {
                line,
                more: false
            };
        }
        if (line[line.byteLength - 1] == LF1) {
            let drop = 1;
            if (line.byteLength > 1 && line[line.byteLength - 2] === CR1) {
                drop = 2;
            }
            line = line.subarray(0, line.byteLength - drop);
        }
        return {
            line,
            more: false
        };
    }
    async readSlice(delim) {
        let s = 0;
        let slice;
        while(true){
            let i4 = this.buf.subarray(this.r + s, this.w).indexOf(delim);
            if (i4 >= 0) {
                i4 += s;
                slice = this.buf.subarray(this.r, this.r + i4 + 1);
                this.r += i4 + 1;
                break;
            }
            if (this.eof) {
                if (this.r === this.w) {
                    return null;
                }
                slice = this.buf.subarray(this.r, this.w);
                this.r = this.w;
                break;
            }
            if (this.buffered() >= this.buf.byteLength) {
                this.r = this.w;
                const oldbuf = this.buf;
                const newbuf = this.buf.slice(0);
                this.buf = newbuf;
                throw new BufferFullError1(oldbuf);
            }
            s = this.w - this.r;
            try {
                await this._fill();
            } catch (err) {
                err.partial = slice;
                throw err;
            }
        }
        return slice;
    }
    async peek(n) {
        if (n < 0) {
            throw Error("negative count");
        }
        let avail = this.w - this.r;
        while(avail < n && avail < this.buf.byteLength && !this.eof){
            try {
                await this._fill();
            } catch (err) {
                err.partial = this.buf.subarray(this.r, this.w);
                throw err;
            }
            avail = this.w - this.r;
        }
        if (avail === 0 && this.eof) {
            return null;
        } else if (avail < n && this.eof) {
            return this.buf.subarray(this.r, this.r + avail);
        } else if (avail < n) {
            throw new BufferFullError1(this.buf.subarray(this.r, this.w));
        }
        return this.buf.subarray(this.r, this.r + n);
    }
}
class AbstractBufBase1 {
    usedBufferBytes = 0;
    err = null;
    size() {
        return this.buf.byteLength;
    }
    available() {
        return this.buf.byteLength - this.usedBufferBytes;
    }
    buffered() {
        return this.usedBufferBytes;
    }
}
class BufWriter1 extends AbstractBufBase1 {
    static create(writer, size = 4096) {
        return writer instanceof BufWriter1 ? writer : new BufWriter1(writer, size);
    }
    constructor(writer3, size5 = 4096){
        super();
        this.writer = writer3;
        if (size5 <= 0) {
            size5 = DEFAULT_BUF_SIZE1;
        }
        this.buf = new Uint8Array(size5);
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.writer = w;
    }
    async flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            await Deno.writeAll(this.writer, this.buf.subarray(0, this.usedBufferBytes));
        } catch (e) {
            this.err = e;
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    async write(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = await this.writer.write(data);
                } catch (e) {
                    this.err = e;
                    throw e;
                }
            } else {
                numBytesWritten = copyBytes1(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                await this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copyBytes1(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
class BufWriterSync1 extends AbstractBufBase1 {
    static create(writer, size = 4096) {
        return writer instanceof BufWriterSync1 ? writer : new BufWriterSync1(writer, size);
    }
    constructor(writer4, size6 = 4096){
        super();
        this.writer = writer4;
        if (size6 <= 0) {
            size6 = DEFAULT_BUF_SIZE1;
        }
        this.buf = new Uint8Array(size6);
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.writer = w;
    }
    flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            Deno.writeAllSync(this.writer, this.buf.subarray(0, this.usedBufferBytes));
        } catch (e) {
            this.err = e;
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    writeSync(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = this.writer.writeSync(data);
                } catch (e) {
                    this.err = e;
                    throw e;
                }
            } else {
                numBytesWritten = copyBytes1(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copyBytes1(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
const encoder1 = new TextEncoder();
function encode1(input) {
    return encoder1.encode(input);
}
const decoder1 = new TextDecoder();
function decode1(input) {
    return decoder1.decode(input);
}
const invalidHeaderCharRegex1 = /[^\t\x20-\x7e\x80-\xff]/g;
function str1(buf) {
    if (buf == null) {
        return "";
    } else {
        return decode1(buf);
    }
}
function charCode1(s) {
    return s.charCodeAt(0);
}
class TextProtoReader1 {
    constructor(r2){
        this.r = r2;
    }
    async readLine() {
        const s = await this.readLineSlice();
        if (s === null) return null;
        return str1(s);
    }
    async readMIMEHeader() {
        const m = new Headers();
        let line;
        let buf = await this.r.peek(1);
        if (buf === null) {
            return null;
        } else if (buf[0] == charCode1(" ") || buf[0] == charCode1("\t")) {
            line = await this.readLineSlice();
        }
        buf = await this.r.peek(1);
        if (buf === null) {
            throw new Deno.errors.UnexpectedEof();
        } else if (buf[0] == charCode1(" ") || buf[0] == charCode1("\t")) {
            throw new Deno.errors.InvalidData(`malformed MIME header initial line: ${str1(line)}`);
        }
        while(true){
            const kv = await this.readLineSlice();
            if (kv === null) throw new Deno.errors.UnexpectedEof();
            if (kv.byteLength === 0) return m;
            let i4 = kv.indexOf(charCode1(":"));
            if (i4 < 0) {
                throw new Deno.errors.InvalidData(`malformed MIME header line: ${str1(kv)}`);
            }
            const key = str1(kv.subarray(0, i4));
            if (key == "") {
                continue;
            }
            i4++;
            while(i4 < kv.byteLength && (kv[i4] == charCode1(" ") || kv[i4] == charCode1("\t"))){
                i4++;
            }
            const value2 = str1(kv.subarray(i4)).replace(invalidHeaderCharRegex1, encodeURI);
            try {
                m.append(key, value2);
            } catch  {
            }
        }
    }
    async readLineSlice() {
        let line;
        while(true){
            const r3 = await this.r.readLine();
            if (r3 === null) return null;
            const { line: l , more  } = r3;
            if (!line && !more) {
                if (this.skipSpace(l) === 0) {
                    return new Uint8Array(0);
                }
                return l;
            }
            line = line ? concat1(line, l) : l;
            if (!more) {
                break;
            }
        }
        return line;
    }
    skipSpace(l) {
        let n = 0;
        for(let i4 = 0; i4 < l.length; i4++){
            if (l[i4] === charCode1(" ") || l[i4] === charCode1("\t")) {
                continue;
            }
            n++;
        }
        return n;
    }
}
function deferred1() {
    let methods;
    const promise = new Promise((resolve7, reject1)=>{
        methods = {
            resolve: resolve7,
            reject: reject1
        };
    });
    return Object.assign(promise, methods);
}
class MuxAsyncIterator1 {
    iteratorCount = 0;
    yields = [];
    throws = [];
    signal = deferred1();
    add(iterator) {
        ++this.iteratorCount;
        this.callIteratorNext(iterator);
    }
    async callIteratorNext(iterator) {
        try {
            const { value: value2 , done  } = await iterator.next();
            if (done) {
                --this.iteratorCount;
            } else {
                this.yields.push({
                    iterator,
                    value: value2
                });
            }
        } catch (e) {
            this.throws.push(e);
        }
        this.signal.resolve();
    }
    async *iterate() {
        while(this.iteratorCount > 0){
            await this.signal;
            for(let i4 = 0; i4 < this.yields.length; i4++){
                const { iterator , value: value2  } = this.yields[i4];
                yield value2;
                this.callIteratorNext(iterator);
            }
            if (this.throws.length) {
                for (const e of this.throws){
                    throw e;
                }
                this.throws.length = 0;
            }
            this.yields.length = 0;
            this.signal = deferred1();
        }
    }
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
}
function emptyReader1() {
    return {
        read (_) {
            return Promise.resolve(null);
        }
    };
}
function bodyReader1(contentLength, r3) {
    let totalRead = 0;
    let finished = false;
    async function read(buf) {
        if (finished) return null;
        let result;
        const remaining = contentLength - totalRead;
        if (remaining >= buf.byteLength) {
            result = await r3.read(buf);
        } else {
            const readBuf = buf.subarray(0, remaining);
            result = await r3.read(readBuf);
        }
        if (result !== null) {
            totalRead += result;
        }
        finished = totalRead === contentLength;
        return result;
    }
    return {
        read
    };
}
function chunkedBodyReader1(h, r3) {
    const tp = new TextProtoReader1(r3);
    let finished = false;
    const chunks = [];
    async function read(buf) {
        if (finished) return null;
        const [chunk] = chunks;
        if (chunk) {
            const chunkRemaining = chunk.data.byteLength - chunk.offset;
            const readLength = Math.min(chunkRemaining, buf.byteLength);
            for(let i4 = 0; i4 < readLength; i4++){
                buf[i4] = chunk.data[chunk.offset + i4];
            }
            chunk.offset += readLength;
            if (chunk.offset === chunk.data.byteLength) {
                chunks.shift();
                if (await tp.readLine() === null) {
                    throw new Deno.errors.UnexpectedEof();
                }
            }
            return readLength;
        }
        const line = await tp.readLine();
        if (line === null) throw new Deno.errors.UnexpectedEof();
        const [chunkSizeString] = line.split(";");
        const chunkSize = parseInt(chunkSizeString, 16);
        if (Number.isNaN(chunkSize) || chunkSize < 0) {
            throw new Error("Invalid chunk size");
        }
        if (chunkSize > 0) {
            if (chunkSize > buf.byteLength) {
                let eof = await r3.readFull(buf);
                if (eof === null) {
                    throw new Deno.errors.UnexpectedEof();
                }
                const restChunk = new Uint8Array(chunkSize - buf.byteLength);
                eof = await r3.readFull(restChunk);
                if (eof === null) {
                    throw new Deno.errors.UnexpectedEof();
                } else {
                    chunks.push({
                        offset: 0,
                        data: restChunk
                    });
                }
                return buf.byteLength;
            } else {
                const bufToFill = buf.subarray(0, chunkSize);
                const eof = await r3.readFull(bufToFill);
                if (eof === null) {
                    throw new Deno.errors.UnexpectedEof();
                }
                if (await tp.readLine() === null) {
                    throw new Deno.errors.UnexpectedEof();
                }
                return chunkSize;
            }
        } else {
            assert3(chunkSize === 0);
            if (await r3.readLine() === null) {
                throw new Deno.errors.UnexpectedEof();
            }
            await readTrailers2(h, r3);
            finished = true;
            return null;
        }
    }
    return {
        read
    };
}
function isProhibidedForTrailer1(key) {
    const s = new Set([
        "transfer-encoding",
        "content-length",
        "trailer"
    ]);
    return s.has(key.toLowerCase());
}
async function readTrailers2(headers, r3) {
    const trailers = parseTrailer2(headers.get("trailer"));
    if (trailers == null) return;
    const trailerNames = [
        ...trailers.keys()
    ];
    const tp = new TextProtoReader1(r3);
    const result = await tp.readMIMEHeader();
    if (result == null) {
        throw new Deno.errors.InvalidData("Missing trailer header.");
    }
    const undeclared = [
        ...result.keys()
    ].filter((k)=>!trailerNames.includes(k)
    );
    if (undeclared.length > 0) {
        throw new Deno.errors.InvalidData(`Undeclared trailers: ${Deno.inspect(undeclared)}.`);
    }
    for (const [k, v] of result){
        headers.append(k, v);
    }
    const missingTrailers = trailerNames.filter((k1)=>!result.has(k1)
    );
    if (missingTrailers.length > 0) {
        throw new Deno.errors.InvalidData(`Missing trailers: ${Deno.inspect(missingTrailers)}.`);
    }
    headers.delete("trailer");
}
function parseTrailer2(field) {
    if (field == null) {
        return undefined;
    }
    const trailerNames = field.split(",").map((v)=>v.trim().toLowerCase()
    );
    if (trailerNames.length === 0) {
        throw new Deno.errors.InvalidData("Empty trailer header.");
    }
    const prohibited = trailerNames.filter((k)=>isProhibidedForTrailer1(k)
    );
    if (prohibited.length > 0) {
        throw new Deno.errors.InvalidData(`Prohibited trailer names: ${Deno.inspect(prohibited)}.`);
    }
    return new Headers(trailerNames.map((key)=>[
            key,
            ""
        ]
    ));
}
async function writeChunkedBody1(w, r3) {
    const writer5 = BufWriter1.create(w);
    for await (const chunk of Deno.iter(r3)){
        if (chunk.byteLength <= 0) continue;
        const start = encoder1.encode(`${chunk.byteLength.toString(16)}\r\n`);
        const end = encoder1.encode("\r\n");
        await writer5.write(start);
        await writer5.write(chunk);
        await writer5.write(end);
    }
    const endChunk = encoder1.encode("0\r\n\r\n");
    await writer5.write(endChunk);
}
async function writeTrailers1(w, headers, trailers) {
    const trailer = headers.get("trailer");
    if (trailer === null) {
        throw new TypeError("Missing trailer header.");
    }
    const transferEncoding = headers.get("transfer-encoding");
    if (transferEncoding === null || !transferEncoding.match(/^chunked/)) {
        throw new TypeError(`Trailers are only allowed for "transfer-encoding: chunked", got "transfer-encoding: ${transferEncoding}".`);
    }
    const writer5 = BufWriter1.create(w);
    const trailerNames = trailer.split(",").map((s)=>s.trim().toLowerCase()
    );
    const prohibitedTrailers = trailerNames.filter((k)=>isProhibidedForTrailer1(k)
    );
    if (prohibitedTrailers.length > 0) {
        throw new TypeError(`Prohibited trailer names: ${Deno.inspect(prohibitedTrailers)}.`);
    }
    const undeclared = [
        ...trailers.keys()
    ].filter((k)=>!trailerNames.includes(k)
    );
    if (undeclared.length > 0) {
        throw new TypeError(`Undeclared trailers: ${Deno.inspect(undeclared)}.`);
    }
    for (const [key, value2] of trailers){
        await writer5.write(encoder1.encode(`${key}: ${value2}\r\n`));
    }
    await writer5.write(encoder1.encode("\r\n"));
    await writer5.flush();
}
async function writeResponse1(w, r3) {
    const protoMajor = 1;
    const protoMinor = 1;
    const statusCode = r3.status || 200;
    const statusText = STATUS_TEXT1.get(statusCode);
    const writer5 = BufWriter1.create(w);
    if (!statusText) {
        throw new Deno.errors.InvalidData("Bad status code");
    }
    if (!r3.body) {
        r3.body = new Uint8Array();
    }
    if (typeof r3.body === "string") {
        r3.body = encoder1.encode(r3.body);
    }
    let out = `HTTP/${1}.${1} ${statusCode} ${statusText}\r\n`;
    const headers = r3.headers ?? new Headers();
    if (r3.body && !headers.get("content-length")) {
        if (r3.body instanceof Uint8Array) {
            out += `content-length: ${r3.body.byteLength}\r\n`;
        } else if (!headers.get("transfer-encoding")) {
            out += "transfer-encoding: chunked\r\n";
        }
    }
    for (const [key, value2] of headers){
        out += `${key}: ${value2}\r\n`;
    }
    out += `\r\n`;
    const header = encoder1.encode(out);
    const n = await writer5.write(header);
    assert3(n === header.byteLength);
    if (r3.body instanceof Uint8Array) {
        const n1 = await writer5.write(r3.body);
        assert3(n1 === r3.body.byteLength);
    } else if (headers.has("content-length")) {
        const contentLength = headers.get("content-length");
        assert3(contentLength != null);
        const bodyLength = parseInt(contentLength);
        const n1 = await Deno.copy(r3.body, writer5);
        assert3(n1 === bodyLength);
    } else {
        await writeChunkedBody1(writer5, r3.body);
    }
    if (r3.trailers) {
        const t = await r3.trailers();
        await writeTrailers1(writer5, headers, t);
    }
    await writer5.flush();
}
class ServerRequest1 {
    done = deferred1();
    _contentLength = undefined;
    get contentLength() {
        if (this._contentLength === undefined) {
            const cl = this.headers.get("content-length");
            if (cl) {
                this._contentLength = parseInt(cl);
                if (Number.isNaN(this._contentLength)) {
                    this._contentLength = null;
                }
            } else {
                this._contentLength = null;
            }
        }
        return this._contentLength;
    }
    _body = null;
    get body() {
        if (!this._body) {
            if (this.contentLength != null) {
                this._body = bodyReader1(this.contentLength, this.r);
            } else {
                const transferEncoding = this.headers.get("transfer-encoding");
                if (transferEncoding != null) {
                    const parts = transferEncoding.split(",").map((e)=>e.trim().toLowerCase()
                    );
                    assert3(parts.includes("chunked"), 'transfer-encoding must include "chunked" if content-length is not set');
                    this._body = chunkedBodyReader1(this.headers, this.r);
                } else {
                    this._body = emptyReader1();
                }
            }
        }
        return this._body;
    }
    async respond(r) {
        let err;
        try {
            await writeResponse1(this.w, r);
        } catch (e) {
            try {
                this.conn.close();
            } catch  {
            }
            err = e;
        }
        this.done.resolve(err);
        if (err) {
            throw err;
        }
    }
    finalized = false;
    async finalize() {
        if (this.finalized) return;
        const body = this.body;
        const buf = new Uint8Array(1024);
        while(await body.read(buf) !== null){
        }
        this.finalized = true;
    }
}
function parseHTTPVersion1(vers) {
    switch(vers){
        case "HTTP/1.1":
            return [
                1,
                1
            ];
        case "HTTP/1.0":
            return [
                1,
                0
            ];
        default:
            {
                const Big = 1000000;
                if (!vers.startsWith("HTTP/")) {
                    break;
                }
                const dot = vers.indexOf(".");
                if (dot < 0) {
                    break;
                }
                const majorStr = vers.substring(vers.indexOf("/") + 1, dot);
                const major = Number(majorStr);
                if (!Number.isInteger(major) || major < 0 || major > 1000000) {
                    break;
                }
                const minorStr = vers.substring(dot + 1);
                const minor = Number(minorStr);
                if (!Number.isInteger(minor) || minor < 0 || minor > 1000000) {
                    break;
                }
                return [
                    major,
                    minor
                ];
            }
    }
    throw new Error(`malformed HTTP version ${vers}`);
}
async function readRequest1(conn, bufr) {
    const tp = new TextProtoReader1(bufr);
    const firstLine = await tp.readLine();
    if (firstLine === null) return null;
    const headers = await tp.readMIMEHeader();
    if (headers === null) throw new Deno.errors.UnexpectedEof();
    const req = new ServerRequest1();
    req.conn = conn;
    req.r = bufr;
    [req.method, req.url, req.proto] = firstLine.split(" ", 3);
    [req.protoMinor, req.protoMajor] = parseHTTPVersion1(req.proto);
    req.headers = headers;
    fixLength2(req);
    return req;
}
class Server1 {
    closing = false;
    connections = [];
    constructor(listener1){
        this.listener = listener1;
    }
    close() {
        this.closing = true;
        this.listener.close();
        for (const conn of this.connections){
            try {
                conn.close();
            } catch (e) {
                if (!(e instanceof Deno.errors.BadResource)) {
                    throw e;
                }
            }
        }
    }
    async *iterateHttpRequests(conn) {
        const reader = new BufReader1(conn);
        const writer5 = new BufWriter1(conn);
        while(!this.closing){
            let request;
            try {
                request = await readRequest1(conn, reader);
            } catch (error) {
                if (error instanceof Deno.errors.InvalidData || error instanceof Deno.errors.UnexpectedEof) {
                    await writeResponse1(writer5, {
                        status: 400,
                        body: encode1(`${error.message}\r\n\r\n`)
                    });
                }
                break;
            }
            if (request === null) {
                break;
            }
            request.w = writer5;
            yield request;
            const responseError = await request.done;
            if (responseError) {
                this.untrackConnection(request.conn);
                return;
            }
            await request.finalize();
        }
        this.untrackConnection(conn);
        try {
            conn.close();
        } catch (e) {
        }
    }
    trackConnection(conn) {
        this.connections.push(conn);
    }
    untrackConnection(conn) {
        const index = this.connections.indexOf(conn);
        if (index !== -1) {
            this.connections.splice(index, 1);
        }
    }
    async *acceptConnAndIterateHttpRequests(mux) {
        if (this.closing) return;
        let conn;
        try {
            conn = await this.listener.accept();
        } catch (error) {
            if (error instanceof Deno.errors.BadResource || error instanceof Deno.errors.InvalidData || error instanceof Deno.errors.UnexpectedEof) {
                return mux.add(this.acceptConnAndIterateHttpRequests(mux));
            }
            throw error;
        }
        this.trackConnection(conn);
        mux.add(this.acceptConnAndIterateHttpRequests(mux));
        yield* this.iterateHttpRequests(conn);
    }
    [Symbol.asyncIterator]() {
        const mux = new MuxAsyncIterator1();
        mux.add(this.acceptConnAndIterateHttpRequests(mux));
        return mux.iterate();
    }
}
function fixLength2(req) {
    const contentLength = req.headers.get("Content-Length");
    if (contentLength) {
        const arrClen = contentLength.split(",");
        if (arrClen.length > 1) {
            const distinct = [
                ...new Set(arrClen.map((e)=>e.trim()
                ))
            ];
            if (distinct.length > 1) {
                throw Error("cannot contain multiple Content-Length headers");
            } else {
                req.headers.set("Content-Length", distinct[0]);
            }
        }
        const c = req.headers.get("Content-Length");
        if (req.method === "HEAD" && c && c !== "0") {
            throw Error("http: method cannot contain a Content-Length");
        }
        if (c && req.headers.has("transfer-encoding")) {
            throw new Error("http: Transfer-Encoding and Content-Length cannot be send together");
        }
    }
}
class HttpError extends Error {
    expose = false;
    constructor(code1, message4){
        super(message4);
        if (!Status1[code1]) {
            throw TypeError(`Unknown HTTP Status Code \`${code1}\``);
        }
        if (code1 < 400 || code1 >= 600) {
            throw TypeError(`Only 4xx or 5xx status codes allowed, but got \`${code1}\``);
        }
        if (code1 >= 400 && code1 < 500) {
            this.expose = true;
        }
        let className = Status1[code1];
        if (!className.endsWith("Error")) {
            className += "Error";
        }
        const msg = message4 != null ? message4 : STATUS_TEXT1.get(code1);
        this.message = msg;
        this.status = this.statusCode = code1;
        this.name = className;
        Error.captureStackTrace(this, this.constructor);
        Object.setPrototypeOf(this, new.target.prototype);
    }
    toString() {
        return `${this.name} [${this.status}]: ${this.message}`;
    }
    toJSON() {
        return {
            name: this.name,
            status: this.status,
            message: this.message
        };
    }
}
const simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
function parseAcceptCharset(accept) {
    const accepts = accept.split(",");
    const parsedAccepts = [];
    for(let i4 = 0; i4 < accepts.length; i4++){
        const charset1 = parseCharset(accepts[i4].trim(), i4);
        if (charset1) {
            parsedAccepts.push(charset1);
        }
    }
    return parsedAccepts;
}
function parseCharset(str2, i4) {
    const match = simpleCharsetRegExp.exec(str2);
    if (!match) return null;
    const charset1 = match[1];
    let q = 1;
    if (match[2]) {
        const params = match[2].split(";");
        for(let j = 0; j < params.length; j++){
            const p = params[j].trim().split("=");
            if (p[0] === "q") {
                q = parseFloat(p[1]);
                break;
            }
        }
    }
    return {
        charset: charset1,
        q: q,
        i: i4
    };
}
function getCharsetPriority(charset1, accepted, index) {
    let priority = {
        o: -1,
        q: 0,
        s: 0
    };
    for(let i4 = 0; i4 < accepted.length; i4++){
        const spec = specify1(charset1, accepted[i4], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
            priority = spec;
        }
    }
    return priority;
}
function specify1(charset1, spec, index) {
    let s = 0;
    if (spec.charset.toLowerCase() === charset1.toLowerCase()) {
        s |= 1;
    } else if (spec.charset !== "*") {
        return null;
    }
    return {
        i: index,
        o: spec.i,
        q: spec.q,
        s: s
    };
}
function preferredCharsets(accept, provided) {
    const accepts = parseAcceptCharset(accept === null ? "*" : accept || "");
    if (!provided) {
        return accepts.filter(isQuality1).sort(compareSpecs1).map(getFullCharset);
    }
    const priorities = provided.map(function getPriority(type, index) {
        return getCharsetPriority(type, accepts, index);
    });
    return priorities.filter(isQuality1).sort(compareSpecs1).map(function getCharset(priority) {
        return provided[priorities.indexOf(priority)];
    });
}
function compareSpecs1(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
function getFullCharset(spec) {
    return spec.charset;
}
function isQuality1(spec) {
    return spec.q > 0;
}
const simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
function parseAcceptEncoding(accept) {
    const accepts = accept.split(",");
    let hasIdentity = false;
    let minQuality = 1;
    const parsedEncodings = [];
    for(let i4 = 0; i4 < accepts.length; i4++){
        const encoding = parseEncoding(accepts[i4].trim(), i4);
        if (encoding) {
            parsedEncodings.push(encoding);
            hasIdentity = hasIdentity || specify2("identity", encoding);
            minQuality = Math.min(minQuality, encoding.q || 1);
        }
    }
    if (!hasIdentity) {
        parsedEncodings.push({
            encoding: "identity",
            q: minQuality,
            i: accepts.length
        });
    }
    return parsedEncodings;
}
function parseEncoding(str2, i4) {
    const match = simpleEncodingRegExp.exec(str2);
    if (!match) return null;
    const encoding = match[1];
    let q = 1;
    if (match[2]) {
        const params = match[2].split(";");
        for(var j = 0; j < params.length; j++){
            const p = params[j].trim().split("=");
            if (p[0] === "q") {
                q = parseFloat(p[1]);
                break;
            }
        }
    }
    return {
        encoding,
        q: q,
        i: i4
    };
}
function getEncodingPriority(encoding, accepted, index) {
    let priority = {
        o: -1,
        q: 0,
        s: 0
    };
    for(let i4 = 0; i4 < accepted.length; i4++){
        const spec = specify2(encoding, accepted[i4], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
            priority = spec;
        }
    }
    return priority;
}
function specify2(encoding, spec, index) {
    let s = 0;
    if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
        s |= 1;
    } else if (spec.encoding !== "*") {
        return null;
    }
    return {
        i: index,
        o: spec.i,
        q: spec.q,
        s: s
    };
}
function preferredEncodings(accept, provided) {
    const accepts = parseAcceptEncoding(accept || "");
    if (!provided) {
        return accepts.filter(isQuality2).sort(compareSpecs2).map(getFullEncoding);
    }
    const priorities = provided.map(function getPriority(type, index) {
        return getEncodingPriority(type, accepts, index);
    });
    return priorities.filter(isQuality2).sort(compareSpecs2).map(function getEncoding(priority) {
        return provided[priorities.indexOf(priority)];
    });
}
function compareSpecs2(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
function getFullEncoding(spec) {
    return spec.encoding;
}
function isQuality2(spec) {
    return spec.q > 0;
}
const simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
function parseAcceptLanguage(accept) {
    const accepts = accept.split(",");
    const parsedEncodings = [];
    for(let i4 = 0; i4 < accepts.length; i4++){
        const language = parseLanguage(accepts[i4].trim(), i4);
        if (language) {
            parsedEncodings.push(language);
        }
    }
    return parsedEncodings;
}
function parseLanguage(str2, i4) {
    const match = simpleLanguageRegExp.exec(str2);
    if (!match) return null;
    const prefix2 = match[1];
    const suffix = match[2];
    let full = prefix2;
    if (suffix) full += "-" + suffix;
    let q = 1;
    if (match[3]) {
        const params = match[3].split(";");
        for(let j = 0; j < params.length; j++){
            const p = params[j].split("=");
            if (p[0] === "q") q = parseFloat(p[1]);
        }
    }
    return {
        prefix: prefix2,
        suffix,
        q,
        i: i4,
        full
    };
}
function getLanguagePriority(language, accepted, index) {
    let priority = {
        o: -1,
        q: 0,
        s: 0
    };
    for(let i4 = 0; i4 < accepted.length; i4++){
        const spec = specify3(language, accepted[i4], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
            priority = spec;
        }
    }
    return priority;
}
function specify3(language, spec, index) {
    const p = parseLanguage(language);
    if (!p) return null;
    let s = 0;
    if (spec.full.toLowerCase() === p.full.toLowerCase()) {
        s |= 4;
    } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
        s |= 2;
    } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
        s |= 1;
    } else if (spec.full !== "*") {
        return null;
    }
    return {
        i: index,
        o: spec.i,
        q: spec.q,
        s
    };
}
function preferredLanguages(accept, provided) {
    const accepts = parseAcceptLanguage(accept === null ? "*" : accept || "");
    if (!provided) {
        return accepts.filter(isQuality3).sort(compareSpecs3).map(getFullLanguage);
    }
    const priorities = provided.map(function getPriority(type, index) {
        return getLanguagePriority(type, accepts, index);
    });
    return priorities.filter(isQuality3).sort(compareSpecs3).map(function getLanguage(priority) {
        return provided[priorities.indexOf(priority)];
    });
}
function compareSpecs3(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
function getFullLanguage(spec) {
    return spec.full;
}
function isQuality3(spec) {
    return spec.q > 0;
}
const simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
function parseAccept(accept) {
    const accepts = splitMediaTypes(accept);
    const parsedAccepts = [];
    for(let i4 = 0; i4 < accepts.length; i4++){
        const mediaType = parseMediaType(accepts[i4].trim(), i4);
        if (mediaType) {
            parsedAccepts.push(mediaType);
        }
    }
    return parsedAccepts;
}
function parseMediaType(str2, i4) {
    const match = simpleMediaTypeRegExp.exec(str2);
    if (!match) return null;
    const params = Object.create(null);
    let q = 1;
    const subtype = match[2];
    const type = match[1];
    if (match[3]) {
        const kvps = splitParameters(match[3]).map(splitKeyValuePair);
        for(let j = 0; j < kvps.length; j++){
            const pair = kvps[j];
            const key = pair[0].toLowerCase();
            const val = pair[1];
            const value2 = val && val[0] === '"' && val[val.length - 1] === '"' ? val.substr(1, val.length - 2) : val;
            if (key === "q") {
                q = parseFloat(value2);
                break;
            }
            params[key] = value2;
        }
    }
    return {
        type,
        subtype,
        params,
        q,
        i: i4
    };
}
function getMediaTypePriority(type, accepted, index) {
    let priority = {
        o: -1,
        q: 0,
        s: 0
    };
    for(let i4 = 0; i4 < accepted.length; i4++){
        const spec = specify4(type, accepted[i4], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
            priority = spec;
        }
    }
    return priority;
}
function specify4(type, spec, index) {
    const p = parseMediaType(type);
    let s = 0;
    if (!p) {
        return null;
    }
    if (spec.type.toLowerCase() == p.type.toLowerCase()) {
        s |= 4;
    } else if (spec.type != "*") {
        return null;
    }
    if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
        s |= 2;
    } else if (spec.subtype != "*") {
        return null;
    }
    const keys = Object.keys(spec.params);
    if (keys.length > 0) {
        if (keys.every(function(k) {
            return spec.params[k] == "*" || (spec.params[k] || "").toLowerCase() == (p.params[k] || "").toLowerCase();
        })) {
            s |= 1;
        } else {
            return null;
        }
    }
    return {
        i: index,
        o: spec.i,
        q: spec.q,
        s: s
    };
}
function preferredMediaTypes(accept, provided) {
    const accepts = parseAccept(accept === null ? "*/*" : accept || "");
    if (!provided) {
        return accepts.filter(isQuality4).sort(compareSpecs4).map(getFullType);
    }
    const priorities = provided.map(function getPriority(type, index) {
        return getMediaTypePriority(type, accepts, index);
    });
    return priorities.filter(isQuality4).sort(compareSpecs4).map(function getType(priority) {
        return provided[priorities.indexOf(priority)];
    });
}
function compareSpecs4(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
function getFullType(spec) {
    return spec.type + "/" + spec.subtype;
}
function isQuality4(spec) {
    return spec.q > 0;
}
function quoteCount(string) {
    let count = 0;
    let index = 0;
    while((index = string.indexOf('"', index)) !== -1){
        count++;
        index++;
    }
    return count;
}
function splitKeyValuePair(str2) {
    const index = str2.indexOf("=");
    let key;
    let val;
    if (index === -1) {
        key = str2;
    } else {
        key = str2.substr(0, index);
        val = str2.substr(index + 1);
    }
    return [
        key,
        val
    ];
}
function splitMediaTypes(accept) {
    const accepts = accept.split(",");
    let j = 0;
    for(let i4 = 1; i4 < accepts.length; i4++){
        if (quoteCount(accepts[j]) % 2 == 0) {
            accepts[++j] = accepts[i4];
        } else {
            accepts[j] += "," + accepts[i4];
        }
    }
    accepts.length = j + 1;
    return accepts;
}
function splitParameters(str2) {
    const parameters = str2.split(";");
    let j = 0;
    for(let i4 = 1; i4 < parameters.length; i4++){
        if (quoteCount(parameters[j]) % 2 == 0) {
            parameters[++j] = parameters[i4];
        } else {
            parameters[j] += ";" + parameters[i4];
        }
    }
    parameters.length = j + 1;
    for(let i5 = 0; i5 < parameters.length; i5++){
        parameters[i5] = parameters[i5].trim();
    }
    return parameters;
}
class Negotiator {
    constructor(headers2){
        this.headers = headers2;
    }
    charset(available) {
        const set = this.charsets(available);
        return set && set[0];
    }
    charsets(available) {
        return preferredCharsets(this.headers.get("accept-charset"), available);
    }
    encoding(available) {
        const set = this.encodings(available);
        return set && set[0];
    }
    encodings(available) {
        return preferredEncodings(this.headers.get("accept-encoding"), available);
    }
    language(available) {
        const set = this.languages(available);
        return set && set[0];
    }
    languages(available) {
        return preferredLanguages(this.headers.get("accept-language"), available);
    }
    mediaType(available) {
        const set = this.mediaTypes(available);
        return set && set[0];
    }
    mediaTypes(available) {
        return preferredMediaTypes(this.headers.get("accept"), available);
    }
}
const db1 = {
    "application/1d-interleaved-parityfec": {
        source: "iana"
    },
    "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
    },
    "application/a2l": {
        source: "iana"
    },
    "application/activemessage": {
        source: "iana"
    },
    "application/activity+json": {
        source: "iana",
        compressible: true
    },
    "application/alto-costmap+json": {
        source: "iana",
        compressible: true
    },
    "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
    },
    "application/alto-directory+json": {
        source: "iana",
        compressible: true
    },
    "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
    },
    "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
    },
    "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
    },
    "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
    },
    "application/alto-error+json": {
        source: "iana",
        compressible: true
    },
    "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
    },
    "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
    },
    "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
    },
    "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
    },
    "application/aml": {
        source: "iana"
    },
    "application/andrew-inset": {
        source: "iana",
        extensions: [
            "ez"
        ]
    },
    "application/applefile": {
        source: "iana"
    },
    "application/applixware": {
        source: "apache",
        extensions: [
            "aw"
        ]
    },
    "application/atf": {
        source: "iana"
    },
    "application/atfx": {
        source: "iana"
    },
    "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "atom"
        ]
    },
    "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "atomcat"
        ]
    },
    "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "atomdeleted"
        ]
    },
    "application/atomicmail": {
        source: "iana"
    },
    "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "atomsvc"
        ]
    },
    "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "dwd"
        ]
    },
    "application/atsc-dynamic-event-message": {
        source: "iana"
    },
    "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "held"
        ]
    },
    "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
    },
    "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "rsat"
        ]
    },
    "application/atxml": {
        source: "iana"
    },
    "application/auth-policy+xml": {
        source: "iana",
        compressible: true
    },
    "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
    },
    "application/batch-smtp": {
        source: "iana"
    },
    "application/bdoc": {
        compressible: false,
        extensions: [
            "bdoc"
        ]
    },
    "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/calendar+json": {
        source: "iana",
        compressible: true
    },
    "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xcs"
        ]
    },
    "application/call-completion": {
        source: "iana"
    },
    "application/cals-1840": {
        source: "iana"
    },
    "application/cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/cbor": {
        source: "iana"
    },
    "application/cbor-seq": {
        source: "iana"
    },
    "application/cccex": {
        source: "iana"
    },
    "application/ccmp+xml": {
        source: "iana",
        compressible: true
    },
    "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "ccxml"
        ]
    },
    "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "cdfx"
        ]
    },
    "application/cdmi-capability": {
        source: "iana",
        extensions: [
            "cdmia"
        ]
    },
    "application/cdmi-container": {
        source: "iana",
        extensions: [
            "cdmic"
        ]
    },
    "application/cdmi-domain": {
        source: "iana",
        extensions: [
            "cdmid"
        ]
    },
    "application/cdmi-object": {
        source: "iana",
        extensions: [
            "cdmio"
        ]
    },
    "application/cdmi-queue": {
        source: "iana",
        extensions: [
            "cdmiq"
        ]
    },
    "application/cdni": {
        source: "iana"
    },
    "application/cea": {
        source: "iana"
    },
    "application/cea-2018+xml": {
        source: "iana",
        compressible: true
    },
    "application/cellml+xml": {
        source: "iana",
        compressible: true
    },
    "application/cfw": {
        source: "iana"
    },
    "application/clue+xml": {
        source: "iana",
        compressible: true
    },
    "application/clue_info+xml": {
        source: "iana",
        compressible: true
    },
    "application/cms": {
        source: "iana"
    },
    "application/cnrp+xml": {
        source: "iana",
        compressible: true
    },
    "application/coap-group+json": {
        source: "iana",
        compressible: true
    },
    "application/coap-payload": {
        source: "iana"
    },
    "application/commonground": {
        source: "iana"
    },
    "application/conference-info+xml": {
        source: "iana",
        compressible: true
    },
    "application/cose": {
        source: "iana"
    },
    "application/cose-key": {
        source: "iana"
    },
    "application/cose-key-set": {
        source: "iana"
    },
    "application/cpl+xml": {
        source: "iana",
        compressible: true
    },
    "application/csrattrs": {
        source: "iana"
    },
    "application/csta+xml": {
        source: "iana",
        compressible: true
    },
    "application/cstadata+xml": {
        source: "iana",
        compressible: true
    },
    "application/csvm+json": {
        source: "iana",
        compressible: true
    },
    "application/cu-seeme": {
        source: "apache",
        extensions: [
            "cu"
        ]
    },
    "application/cwt": {
        source: "iana"
    },
    "application/cybercash": {
        source: "iana"
    },
    "application/dart": {
        compressible: true
    },
    "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "mpd"
        ]
    },
    "application/dashdelta": {
        source: "iana"
    },
    "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "davmount"
        ]
    },
    "application/dca-rft": {
        source: "iana"
    },
    "application/dcd": {
        source: "iana"
    },
    "application/dec-dx": {
        source: "iana"
    },
    "application/dialog-info+xml": {
        source: "iana",
        compressible: true
    },
    "application/dicom": {
        source: "iana"
    },
    "application/dicom+json": {
        source: "iana",
        compressible: true
    },
    "application/dicom+xml": {
        source: "iana",
        compressible: true
    },
    "application/dii": {
        source: "iana"
    },
    "application/dit": {
        source: "iana"
    },
    "application/dns": {
        source: "iana"
    },
    "application/dns+json": {
        source: "iana",
        compressible: true
    },
    "application/dns-message": {
        source: "iana"
    },
    "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: [
            "dbk"
        ]
    },
    "application/dots+cbor": {
        source: "iana"
    },
    "application/dskpp+xml": {
        source: "iana",
        compressible: true
    },
    "application/dssc+der": {
        source: "iana",
        extensions: [
            "dssc"
        ]
    },
    "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xdssc"
        ]
    },
    "application/dvcs": {
        source: "iana"
    },
    "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: [
            "ecma",
            "es"
        ]
    },
    "application/edi-consent": {
        source: "iana"
    },
    "application/edi-x12": {
        source: "iana",
        compressible: false
    },
    "application/edifact": {
        source: "iana",
        compressible: false
    },
    "application/efi": {
        source: "iana"
    },
    "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
    },
    "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
    },
    "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
    },
    "application/emergencycalldata.ecall.msd": {
        source: "iana"
    },
    "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
    },
    "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
    },
    "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
    },
    "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
    },
    "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "emma"
        ]
    },
    "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "emotionml"
        ]
    },
    "application/encaprtp": {
        source: "iana"
    },
    "application/epp+xml": {
        source: "iana",
        compressible: true
    },
    "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: [
            "epub"
        ]
    },
    "application/eshop": {
        source: "iana"
    },
    "application/exi": {
        source: "iana",
        extensions: [
            "exi"
        ]
    },
    "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
    },
    "application/fastinfoset": {
        source: "iana"
    },
    "application/fastsoap": {
        source: "iana"
    },
    "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "fdt"
        ]
    },
    "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/fido.trusted-apps+json": {
        compressible: true
    },
    "application/fits": {
        source: "iana"
    },
    "application/flexfec": {
        source: "iana"
    },
    "application/font-sfnt": {
        source: "iana"
    },
    "application/font-tdpfr": {
        source: "iana",
        extensions: [
            "pfr"
        ]
    },
    "application/font-woff": {
        source: "iana",
        compressible: false
    },
    "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
    },
    "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: [
            "geojson"
        ]
    },
    "application/geo+json-seq": {
        source: "iana"
    },
    "application/geopackage+sqlite3": {
        source: "iana"
    },
    "application/geoxacml+xml": {
        source: "iana",
        compressible: true
    },
    "application/gltf-buffer": {
        source: "iana"
    },
    "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "gml"
        ]
    },
    "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: [
            "gpx"
        ]
    },
    "application/gxf": {
        source: "apache",
        extensions: [
            "gxf"
        ]
    },
    "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: [
            "gz"
        ]
    },
    "application/h224": {
        source: "iana"
    },
    "application/held+xml": {
        source: "iana",
        compressible: true
    },
    "application/hjson": {
        extensions: [
            "hjson"
        ]
    },
    "application/http": {
        source: "iana"
    },
    "application/hyperstudio": {
        source: "iana",
        extensions: [
            "stk"
        ]
    },
    "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
    },
    "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
    },
    "application/ibe-pp-data": {
        source: "iana"
    },
    "application/iges": {
        source: "iana"
    },
    "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/index": {
        source: "iana"
    },
    "application/index.cmd": {
        source: "iana"
    },
    "application/index.obj": {
        source: "iana"
    },
    "application/index.response": {
        source: "iana"
    },
    "application/index.vnd": {
        source: "iana"
    },
    "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "ink",
            "inkml"
        ]
    },
    "application/iotp": {
        source: "iana"
    },
    "application/ipfix": {
        source: "iana",
        extensions: [
            "ipfix"
        ]
    },
    "application/ipp": {
        source: "iana"
    },
    "application/isup": {
        source: "iana"
    },
    "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "its"
        ]
    },
    "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: [
            "jar",
            "war",
            "ear"
        ]
    },
    "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: [
            "ser"
        ]
    },
    "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: [
            "class"
        ]
    },
    "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
            "js",
            "mjs"
        ]
    },
    "application/jf2feed+json": {
        source: "iana",
        compressible: true
    },
    "application/jose": {
        source: "iana"
    },
    "application/jose+json": {
        source: "iana",
        compressible: true
    },
    "application/jrd+json": {
        source: "iana",
        compressible: true
    },
    "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
            "json",
            "map"
        ]
    },
    "application/json-patch+json": {
        source: "iana",
        compressible: true
    },
    "application/json-seq": {
        source: "iana"
    },
    "application/json5": {
        extensions: [
            "json5"
        ]
    },
    "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: [
            "jsonml"
        ]
    },
    "application/jwk+json": {
        source: "iana",
        compressible: true
    },
    "application/jwk-set+json": {
        source: "iana",
        compressible: true
    },
    "application/jwt": {
        source: "iana"
    },
    "application/kpml-request+xml": {
        source: "iana",
        compressible: true
    },
    "application/kpml-response+xml": {
        source: "iana",
        compressible: true
    },
    "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: [
            "jsonld"
        ]
    },
    "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "lgr"
        ]
    },
    "application/link-format": {
        source: "iana"
    },
    "application/load-control+xml": {
        source: "iana",
        compressible: true
    },
    "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "lostxml"
        ]
    },
    "application/lostsync+xml": {
        source: "iana",
        compressible: true
    },
    "application/lpf+zip": {
        source: "iana",
        compressible: false
    },
    "application/lxf": {
        source: "iana"
    },
    "application/mac-binhex40": {
        source: "iana",
        extensions: [
            "hqx"
        ]
    },
    "application/mac-compactpro": {
        source: "apache",
        extensions: [
            "cpt"
        ]
    },
    "application/macwriteii": {
        source: "iana"
    },
    "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "mads"
        ]
    },
    "application/manifest+json": {
        charset: "UTF-8",
        compressible: true,
        extensions: [
            "webmanifest"
        ]
    },
    "application/marc": {
        source: "iana",
        extensions: [
            "mrc"
        ]
    },
    "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "mrcx"
        ]
    },
    "application/mathematica": {
        source: "iana",
        extensions: [
            "ma",
            "nb",
            "mb"
        ]
    },
    "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "mathml"
        ]
    },
    "application/mathml-content+xml": {
        source: "iana",
        compressible: true
    },
    "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
    },
    "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
    },
    "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
    },
    "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
    },
    "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
    },
    "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
    },
    "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
    },
    "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
    },
    "application/mbms-register+xml": {
        source: "iana",
        compressible: true
    },
    "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
    },
    "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
    },
    "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
    },
    "application/mbox": {
        source: "iana",
        extensions: [
            "mbox"
        ]
    },
    "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true
    },
    "application/media_control+xml": {
        source: "iana",
        compressible: true
    },
    "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "mscml"
        ]
    },
    "application/merge-patch+json": {
        source: "iana",
        compressible: true
    },
    "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: [
            "metalink"
        ]
    },
    "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "meta4"
        ]
    },
    "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "mets"
        ]
    },
    "application/mf4": {
        source: "iana"
    },
    "application/mikey": {
        source: "iana"
    },
    "application/mipc": {
        source: "iana"
    },
    "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "maei"
        ]
    },
    "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "musd"
        ]
    },
    "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "mods"
        ]
    },
    "application/moss-keys": {
        source: "iana"
    },
    "application/moss-signature": {
        source: "iana"
    },
    "application/mosskey-data": {
        source: "iana"
    },
    "application/mosskey-request": {
        source: "iana"
    },
    "application/mp21": {
        source: "iana",
        extensions: [
            "m21",
            "mp21"
        ]
    },
    "application/mp4": {
        source: "iana",
        extensions: [
            "mp4s",
            "m4p"
        ]
    },
    "application/mpeg4-generic": {
        source: "iana"
    },
    "application/mpeg4-iod": {
        source: "iana"
    },
    "application/mpeg4-iod-xmt": {
        source: "iana"
    },
    "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xdf"
        ]
    },
    "application/mrb-publish+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xdf"
        ]
    },
    "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/msword": {
        source: "iana",
        compressible: false,
        extensions: [
            "doc",
            "dot"
        ]
    },
    "application/mud+json": {
        source: "iana",
        compressible: true
    },
    "application/multipart-core": {
        source: "iana"
    },
    "application/mxf": {
        source: "iana",
        extensions: [
            "mxf"
        ]
    },
    "application/n-quads": {
        source: "iana",
        extensions: [
            "nq"
        ]
    },
    "application/n-triples": {
        source: "iana",
        extensions: [
            "nt"
        ]
    },
    "application/nasdata": {
        source: "iana"
    },
    "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
    },
    "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
    },
    "application/news-transmission": {
        source: "iana"
    },
    "application/nlsml+xml": {
        source: "iana",
        compressible: true
    },
    "application/node": {
        source: "iana",
        extensions: [
            "cjs"
        ]
    },
    "application/nss": {
        source: "iana"
    },
    "application/ocsp-request": {
        source: "iana"
    },
    "application/ocsp-response": {
        source: "iana"
    },
    "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: [
            "bin",
            "dms",
            "lrf",
            "mar",
            "so",
            "dist",
            "distz",
            "pkg",
            "bpk",
            "dump",
            "elc",
            "deploy",
            "exe",
            "dll",
            "deb",
            "dmg",
            "iso",
            "img",
            "msi",
            "msp",
            "msm",
            "buffer", 
        ]
    },
    "application/oda": {
        source: "iana",
        extensions: [
            "oda"
        ]
    },
    "application/odm+xml": {
        source: "iana",
        compressible: true
    },
    "application/odx": {
        source: "iana"
    },
    "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "opf"
        ]
    },
    "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: [
            "ogx"
        ]
    },
    "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: [
            "omdoc"
        ]
    },
    "application/onenote": {
        source: "apache",
        extensions: [
            "onetoc",
            "onetoc2",
            "onetmp",
            "onepkg"
        ]
    },
    "application/oscore": {
        source: "iana"
    },
    "application/oxps": {
        source: "iana",
        extensions: [
            "oxps"
        ]
    },
    "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "relo"
        ]
    },
    "application/parityfec": {
        source: "iana"
    },
    "application/passport": {
        source: "iana"
    },
    "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xer"
        ]
    },
    "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: [
            "pdf"
        ]
    },
    "application/pdx": {
        source: "iana"
    },
    "application/pem-certificate-chain": {
        source: "iana"
    },
    "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: [
            "pgp"
        ]
    },
    "application/pgp-keys": {
        source: "iana"
    },
    "application/pgp-signature": {
        source: "iana",
        extensions: [
            "asc",
            "sig"
        ]
    },
    "application/pics-rules": {
        source: "apache",
        extensions: [
            "prf"
        ]
    },
    "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/pkcs10": {
        source: "iana",
        extensions: [
            "p10"
        ]
    },
    "application/pkcs12": {
        source: "iana"
    },
    "application/pkcs7-mime": {
        source: "iana",
        extensions: [
            "p7m",
            "p7c"
        ]
    },
    "application/pkcs7-signature": {
        source: "iana",
        extensions: [
            "p7s"
        ]
    },
    "application/pkcs8": {
        source: "iana",
        extensions: [
            "p8"
        ]
    },
    "application/pkcs8-encrypted": {
        source: "iana"
    },
    "application/pkix-attr-cert": {
        source: "iana",
        extensions: [
            "ac"
        ]
    },
    "application/pkix-cert": {
        source: "iana",
        extensions: [
            "cer"
        ]
    },
    "application/pkix-crl": {
        source: "iana",
        extensions: [
            "crl"
        ]
    },
    "application/pkix-pkipath": {
        source: "iana",
        extensions: [
            "pkipath"
        ]
    },
    "application/pkixcmp": {
        source: "iana",
        extensions: [
            "pki"
        ]
    },
    "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "pls"
        ]
    },
    "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: [
            "ai",
            "eps",
            "ps"
        ]
    },
    "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
    },
    "application/problem+json": {
        source: "iana",
        compressible: true
    },
    "application/problem+xml": {
        source: "iana",
        compressible: true
    },
    "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "provx"
        ]
    },
    "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
    },
    "application/prs.cww": {
        source: "iana",
        extensions: [
            "cww"
        ]
    },
    "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
    },
    "application/prs.nprend": {
        source: "iana"
    },
    "application/prs.plucker": {
        source: "iana"
    },
    "application/prs.rdf-xml-crypt": {
        source: "iana"
    },
    "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
    },
    "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "pskcxml"
        ]
    },
    "application/pvd+json": {
        source: "iana",
        compressible: true
    },
    "application/qsig": {
        source: "iana"
    },
    "application/raml+yaml": {
        compressible: true,
        extensions: [
            "raml"
        ]
    },
    "application/raptorfec": {
        source: "iana"
    },
    "application/rdap+json": {
        source: "iana",
        compressible: true
    },
    "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "rdf",
            "owl"
        ]
    },
    "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "rif"
        ]
    },
    "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: [
            "rnc"
        ]
    },
    "application/remote-printing": {
        source: "iana"
    },
    "application/reputon+json": {
        source: "iana",
        compressible: true
    },
    "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "rl"
        ]
    },
    "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "rld"
        ]
    },
    "application/rfc+xml": {
        source: "iana",
        compressible: true
    },
    "application/riscos": {
        source: "iana"
    },
    "application/rlmi+xml": {
        source: "iana",
        compressible: true
    },
    "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "rs"
        ]
    },
    "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "rapd"
        ]
    },
    "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "sls"
        ]
    },
    "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "rusd"
        ]
    },
    "application/rpki-ghostbusters": {
        source: "iana",
        extensions: [
            "gbr"
        ]
    },
    "application/rpki-manifest": {
        source: "iana",
        extensions: [
            "mft"
        ]
    },
    "application/rpki-publication": {
        source: "iana"
    },
    "application/rpki-roa": {
        source: "iana",
        extensions: [
            "roa"
        ]
    },
    "application/rpki-updown": {
        source: "iana"
    },
    "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: [
            "rsd"
        ]
    },
    "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: [
            "rss"
        ]
    },
    "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: [
            "rtf"
        ]
    },
    "application/rtploopback": {
        source: "iana"
    },
    "application/rtx": {
        source: "iana"
    },
    "application/samlassertion+xml": {
        source: "iana",
        compressible: true
    },
    "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
    },
    "application/sbe": {
        source: "iana"
    },
    "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "sbml"
        ]
    },
    "application/scaip+xml": {
        source: "iana",
        compressible: true
    },
    "application/scim+json": {
        source: "iana",
        compressible: true
    },
    "application/scvp-cv-request": {
        source: "iana",
        extensions: [
            "scq"
        ]
    },
    "application/scvp-cv-response": {
        source: "iana",
        extensions: [
            "scs"
        ]
    },
    "application/scvp-vp-request": {
        source: "iana",
        extensions: [
            "spq"
        ]
    },
    "application/scvp-vp-response": {
        source: "iana",
        extensions: [
            "spp"
        ]
    },
    "application/sdp": {
        source: "iana",
        extensions: [
            "sdp"
        ]
    },
    "application/secevent+jwt": {
        source: "iana"
    },
    "application/senml+cbor": {
        source: "iana"
    },
    "application/senml+json": {
        source: "iana",
        compressible: true
    },
    "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "senmlx"
        ]
    },
    "application/senml-etch+cbor": {
        source: "iana"
    },
    "application/senml-etch+json": {
        source: "iana",
        compressible: true
    },
    "application/senml-exi": {
        source: "iana"
    },
    "application/sensml+cbor": {
        source: "iana"
    },
    "application/sensml+json": {
        source: "iana",
        compressible: true
    },
    "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "sensmlx"
        ]
    },
    "application/sensml-exi": {
        source: "iana"
    },
    "application/sep+xml": {
        source: "iana",
        compressible: true
    },
    "application/sep-exi": {
        source: "iana"
    },
    "application/session-info": {
        source: "iana"
    },
    "application/set-payment": {
        source: "iana"
    },
    "application/set-payment-initiation": {
        source: "iana",
        extensions: [
            "setpay"
        ]
    },
    "application/set-registration": {
        source: "iana"
    },
    "application/set-registration-initiation": {
        source: "iana",
        extensions: [
            "setreg"
        ]
    },
    "application/sgml": {
        source: "iana"
    },
    "application/sgml-open-catalog": {
        source: "iana"
    },
    "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "shf"
        ]
    },
    "application/sieve": {
        source: "iana",
        extensions: [
            "siv",
            "sieve"
        ]
    },
    "application/simple-filter+xml": {
        source: "iana",
        compressible: true
    },
    "application/simple-message-summary": {
        source: "iana"
    },
    "application/simplesymbolcontainer": {
        source: "iana"
    },
    "application/sipc": {
        source: "iana"
    },
    "application/slate": {
        source: "iana"
    },
    "application/smil": {
        source: "iana"
    },
    "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "smi",
            "smil"
        ]
    },
    "application/smpte336m": {
        source: "iana"
    },
    "application/soap+fastinfoset": {
        source: "iana"
    },
    "application/soap+xml": {
        source: "iana",
        compressible: true
    },
    "application/sparql-query": {
        source: "iana",
        extensions: [
            "rq"
        ]
    },
    "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "srx"
        ]
    },
    "application/spirits-event+xml": {
        source: "iana",
        compressible: true
    },
    "application/sql": {
        source: "iana"
    },
    "application/srgs": {
        source: "iana",
        extensions: [
            "gram"
        ]
    },
    "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "grxml"
        ]
    },
    "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "sru"
        ]
    },
    "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: [
            "ssdl"
        ]
    },
    "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "ssml"
        ]
    },
    "application/stix+json": {
        source: "iana",
        compressible: true
    },
    "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "swidtag"
        ]
    },
    "application/tamp-apex-update": {
        source: "iana"
    },
    "application/tamp-apex-update-confirm": {
        source: "iana"
    },
    "application/tamp-community-update": {
        source: "iana"
    },
    "application/tamp-community-update-confirm": {
        source: "iana"
    },
    "application/tamp-error": {
        source: "iana"
    },
    "application/tamp-sequence-adjust": {
        source: "iana"
    },
    "application/tamp-sequence-adjust-confirm": {
        source: "iana"
    },
    "application/tamp-status-query": {
        source: "iana"
    },
    "application/tamp-status-response": {
        source: "iana"
    },
    "application/tamp-update": {
        source: "iana"
    },
    "application/tamp-update-confirm": {
        source: "iana"
    },
    "application/tar": {
        compressible: true
    },
    "application/taxii+json": {
        source: "iana",
        compressible: true
    },
    "application/td+json": {
        source: "iana",
        compressible: true
    },
    "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "tei",
            "teicorpus"
        ]
    },
    "application/tetra_isi": {
        source: "iana"
    },
    "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "tfi"
        ]
    },
    "application/timestamp-query": {
        source: "iana"
    },
    "application/timestamp-reply": {
        source: "iana"
    },
    "application/timestamped-data": {
        source: "iana",
        extensions: [
            "tsd"
        ]
    },
    "application/tlsrpt+gzip": {
        source: "iana"
    },
    "application/tlsrpt+json": {
        source: "iana",
        compressible: true
    },
    "application/tnauthlist": {
        source: "iana"
    },
    "application/toml": {
        compressible: true,
        extensions: [
            "toml"
        ]
    },
    "application/trickle-ice-sdpfrag": {
        source: "iana"
    },
    "application/trig": {
        source: "iana"
    },
    "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "ttml"
        ]
    },
    "application/tve-trigger": {
        source: "iana"
    },
    "application/tzif": {
        source: "iana"
    },
    "application/tzif-leap": {
        source: "iana"
    },
    "application/ulpfec": {
        source: "iana"
    },
    "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
    },
    "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "rsheet"
        ]
    },
    "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true
    },
    "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
    },
    "application/vcard+json": {
        source: "iana",
        compressible: true
    },
    "application/vcard+xml": {
        source: "iana",
        compressible: true
    },
    "application/vemmi": {
        source: "iana"
    },
    "application/vividence.scriptfile": {
        source: "apache"
    },
    "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "1km"
        ]
    },
    "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
    },
    "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
    },
    "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
    },
    "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
    },
    "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: [
            "plb"
        ]
    },
    "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: [
            "psb"
        ]
    },
    "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: [
            "pvb"
        ]
    },
    "application/vnd.3gpp.sms": {
        source: "iana"
    },
    "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.3gpp2.sms": {
        source: "iana"
    },
    "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: [
            "tcap"
        ]
    },
    "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
    },
    "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: [
            "pwn"
        ]
    },
    "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: [
            "aso"
        ]
    },
    "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: [
            "imp"
        ]
    },
    "application/vnd.acucobol": {
        source: "iana",
        extensions: [
            "acu"
        ]
    },
    "application/vnd.acucorp": {
        source: "iana",
        extensions: [
            "atc",
            "acutc"
        ]
    },
    "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: [
            "air"
        ]
    },
    "application/vnd.adobe.flash.movie": {
        source: "iana"
    },
    "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: [
            "fcdt"
        ]
    },
    "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: [
            "fxp",
            "fxpl"
        ]
    },
    "application/vnd.adobe.partial-upload": {
        source: "iana"
    },
    "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xdp"
        ]
    },
    "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: [
            "xfdf"
        ]
    },
    "application/vnd.aether.imp": {
        source: "iana"
    },
    "application/vnd.afpc.afplinedata": {
        source: "iana"
    },
    "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
    },
    "application/vnd.afpc.foca-charset": {
        source: "iana"
    },
    "application/vnd.afpc.foca-codedfont": {
        source: "iana"
    },
    "application/vnd.afpc.foca-codepage": {
        source: "iana"
    },
    "application/vnd.afpc.modca": {
        source: "iana"
    },
    "application/vnd.afpc.modca-formdef": {
        source: "iana"
    },
    "application/vnd.afpc.modca-mediummap": {
        source: "iana"
    },
    "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
    },
    "application/vnd.afpc.modca-overlay": {
        source: "iana"
    },
    "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
    },
    "application/vnd.ah-barcode": {
        source: "iana"
    },
    "application/vnd.ahead.space": {
        source: "iana",
        extensions: [
            "ahead"
        ]
    },
    "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: [
            "azf"
        ]
    },
    "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: [
            "azs"
        ]
    },
    "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: [
            "azw"
        ]
    },
    "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
    },
    "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: [
            "acc"
        ]
    },
    "application/vnd.amiga.ami": {
        source: "iana",
        extensions: [
            "ami"
        ]
    },
    "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.android.ota": {
        source: "iana"
    },
    "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: [
            "apk"
        ]
    },
    "application/vnd.anki": {
        source: "iana"
    },
    "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: [
            "cii"
        ]
    },
    "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: [
            "fti"
        ]
    },
    "application/vnd.antix.game-component": {
        source: "iana",
        extensions: [
            "atx"
        ]
    },
    "application/vnd.apache.thrift.binary": {
        source: "iana"
    },
    "application/vnd.apache.thrift.compact": {
        source: "iana"
    },
    "application/vnd.apache.thrift.json": {
        source: "iana"
    },
    "application/vnd.api+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "mpkg"
        ]
    },
    "application/vnd.apple.keynote": {
        source: "iana",
        extensions: [
            "keynote"
        ]
    },
    "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: [
            "m3u8"
        ]
    },
    "application/vnd.apple.numbers": {
        source: "iana",
        extensions: [
            "numbers"
        ]
    },
    "application/vnd.apple.pages": {
        source: "iana",
        extensions: [
            "pages"
        ]
    },
    "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: [
            "pkpass"
        ]
    },
    "application/vnd.arastra.swi": {
        source: "iana"
    },
    "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: [
            "swi"
        ]
    },
    "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.artsquare": {
        source: "iana"
    },
    "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: [
            "iota"
        ]
    },
    "application/vnd.audiograph": {
        source: "iana",
        extensions: [
            "aep"
        ]
    },
    "application/vnd.autopackage": {
        source: "iana"
    },
    "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "bmml"
        ]
    },
    "application/vnd.balsamiq.bmpr": {
        source: "iana"
    },
    "application/vnd.banana-accounting": {
        source: "iana"
    },
    "application/vnd.bbf.usp.error": {
        source: "iana"
    },
    "application/vnd.bbf.usp.msg": {
        source: "iana"
    },
    "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.bint.med-content": {
        source: "iana"
    },
    "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
    },
    "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: [
            "mpm"
        ]
    },
    "application/vnd.bluetooth.ep.oob": {
        source: "iana"
    },
    "application/vnd.bluetooth.le.oob": {
        source: "iana"
    },
    "application/vnd.bmi": {
        source: "iana",
        extensions: [
            "bmi"
        ]
    },
    "application/vnd.bpf": {
        source: "iana"
    },
    "application/vnd.bpf3": {
        source: "iana"
    },
    "application/vnd.businessobjects": {
        source: "iana",
        extensions: [
            "rep"
        ]
    },
    "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.cab-jscript": {
        source: "iana"
    },
    "application/vnd.canon-cpdl": {
        source: "iana"
    },
    "application/vnd.canon-lips": {
        source: "iana"
    },
    "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
    },
    "application/vnd.century-systems.tcp_stream": {
        source: "iana"
    },
    "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "cdxml"
        ]
    },
    "application/vnd.chess-pgn": {
        source: "iana"
    },
    "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: [
            "mmd"
        ]
    },
    "application/vnd.ciedi": {
        source: "iana"
    },
    "application/vnd.cinderella": {
        source: "iana",
        extensions: [
            "cdy"
        ]
    },
    "application/vnd.cirpack.isdn-ext": {
        source: "iana"
    },
    "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "csl"
        ]
    },
    "application/vnd.claymore": {
        source: "iana",
        extensions: [
            "cla"
        ]
    },
    "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: [
            "rp9"
        ]
    },
    "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: [
            "c4g",
            "c4d",
            "c4f",
            "c4p",
            "c4u"
        ]
    },
    "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: [
            "c11amc"
        ]
    },
    "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: [
            "c11amz"
        ]
    },
    "application/vnd.coffeescript": {
        source: "iana"
    },
    "application/vnd.collabio.xodocuments.document": {
        source: "iana"
    },
    "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
    },
    "application/vnd.collection+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
    },
    "application/vnd.comicbook-rar": {
        source: "iana"
    },
    "application/vnd.commerce-battelle": {
        source: "iana"
    },
    "application/vnd.commonspace": {
        source: "iana",
        extensions: [
            "csp"
        ]
    },
    "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: [
            "cdbcmsg"
        ]
    },
    "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.cosmocaller": {
        source: "iana",
        extensions: [
            "cmc"
        ]
    },
    "application/vnd.crick.clicker": {
        source: "iana",
        extensions: [
            "clkx"
        ]
    },
    "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: [
            "clkk"
        ]
    },
    "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: [
            "clkp"
        ]
    },
    "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: [
            "clkt"
        ]
    },
    "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: [
            "clkw"
        ]
    },
    "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "wbs"
        ]
    },
    "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.crypto-shade-file": {
        source: "iana"
    },
    "application/vnd.ctc-posml": {
        source: "iana",
        extensions: [
            "pml"
        ]
    },
    "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.cups-pdf": {
        source: "iana"
    },
    "application/vnd.cups-postscript": {
        source: "iana"
    },
    "application/vnd.cups-ppd": {
        source: "iana",
        extensions: [
            "ppd"
        ]
    },
    "application/vnd.cups-raster": {
        source: "iana"
    },
    "application/vnd.cups-raw": {
        source: "iana"
    },
    "application/vnd.curl": {
        source: "iana"
    },
    "application/vnd.curl.car": {
        source: "apache",
        extensions: [
            "car"
        ]
    },
    "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: [
            "pcurl"
        ]
    },
    "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.cybank": {
        source: "iana"
    },
    "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
    },
    "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: [
            "dart"
        ]
    },
    "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: [
            "rdz"
        ]
    },
    "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.dbf": {
        source: "iana"
    },
    "application/vnd.debian.binary-package": {
        source: "iana"
    },
    "application/vnd.dece.data": {
        source: "iana",
        extensions: [
            "uvf",
            "uvvf",
            "uvd",
            "uvvd"
        ]
    },
    "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "uvt",
            "uvvt"
        ]
    },
    "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: [
            "uvx",
            "uvvx"
        ]
    },
    "application/vnd.dece.zip": {
        source: "iana",
        extensions: [
            "uvz",
            "uvvz"
        ]
    },
    "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: [
            "fe_launch"
        ]
    },
    "application/vnd.desmume.movie": {
        source: "iana"
    },
    "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
    },
    "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.dna": {
        source: "iana",
        extensions: [
            "dna"
        ]
    },
    "application/vnd.document+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: [
            "mlp"
        ]
    },
    "application/vnd.dolby.mobile.1": {
        source: "iana"
    },
    "application/vnd.dolby.mobile.2": {
        source: "iana"
    },
    "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
    },
    "application/vnd.dpgraph": {
        source: "iana",
        extensions: [
            "dpg"
        ]
    },
    "application/vnd.dreamfactory": {
        source: "iana",
        extensions: [
            "dfac"
        ]
    },
    "application/vnd.drive+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: [
            "kpxx"
        ]
    },
    "application/vnd.dtg.local": {
        source: "iana"
    },
    "application/vnd.dtg.local.flash": {
        source: "iana"
    },
    "application/vnd.dtg.local.html": {
        source: "iana"
    },
    "application/vnd.dvb.ait": {
        source: "iana",
        extensions: [
            "ait"
        ]
    },
    "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.dvb.dvbj": {
        source: "iana"
    },
    "application/vnd.dvb.esgcontainer": {
        source: "iana"
    },
    "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
    },
    "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
    },
    "application/vnd.dvb.ipdcroaming": {
        source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
    },
    "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.dvb.pfr": {
        source: "iana"
    },
    "application/vnd.dvb.service": {
        source: "iana",
        extensions: [
            "svc"
        ]
    },
    "application/vnd.dxr": {
        source: "iana"
    },
    "application/vnd.dynageo": {
        source: "iana",
        extensions: [
            "geo"
        ]
    },
    "application/vnd.dzr": {
        source: "iana"
    },
    "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
    },
    "application/vnd.ecdis-update": {
        source: "iana"
    },
    "application/vnd.ecip.rlp": {
        source: "iana"
    },
    "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: [
            "mag"
        ]
    },
    "application/vnd.ecowin.filerequest": {
        source: "iana"
    },
    "application/vnd.ecowin.fileupdate": {
        source: "iana"
    },
    "application/vnd.ecowin.series": {
        source: "iana"
    },
    "application/vnd.ecowin.seriesrequest": {
        source: "iana"
    },
    "application/vnd.ecowin.seriesupdate": {
        source: "iana"
    },
    "application/vnd.efi.img": {
        source: "iana"
    },
    "application/vnd.efi.iso": {
        source: "iana"
    },
    "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.enliven": {
        source: "iana",
        extensions: [
            "nml"
        ]
    },
    "application/vnd.enphase.envoy": {
        source: "iana"
    },
    "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.epson.esf": {
        source: "iana",
        extensions: [
            "esf"
        ]
    },
    "application/vnd.epson.msf": {
        source: "iana",
        extensions: [
            "msf"
        ]
    },
    "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: [
            "qam"
        ]
    },
    "application/vnd.epson.salt": {
        source: "iana",
        extensions: [
            "slt"
        ]
    },
    "application/vnd.epson.ssf": {
        source: "iana",
        extensions: [
            "ssf"
        ]
    },
    "application/vnd.ericsson.quickcall": {
        source: "iana"
    },
    "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
    },
    "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "es3",
            "et3"
        ]
    },
    "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
    },
    "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
    },
    "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.mheg5": {
        source: "iana"
    },
    "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.timestamp-token": {
        source: "iana"
    },
    "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.etsi.tsl.der": {
        source: "iana"
    },
    "application/vnd.eudora.data": {
        source: "iana"
    },
    "application/vnd.evolv.ecig.profile": {
        source: "iana"
    },
    "application/vnd.evolv.ecig.settings": {
        source: "iana"
    },
    "application/vnd.evolv.ecig.theme": {
        source: "iana"
    },
    "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
    },
    "application/vnd.exstream-package": {
        source: "iana"
    },
    "application/vnd.ezpix-album": {
        source: "iana",
        extensions: [
            "ez2"
        ]
    },
    "application/vnd.ezpix-package": {
        source: "iana",
        extensions: [
            "ez3"
        ]
    },
    "application/vnd.f-secure.mobile": {
        source: "iana"
    },
    "application/vnd.fastcopy-disk-image": {
        source: "iana"
    },
    "application/vnd.fdf": {
        source: "iana",
        extensions: [
            "fdf"
        ]
    },
    "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: [
            "mseed"
        ]
    },
    "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: [
            "seed",
            "dataless"
        ]
    },
    "application/vnd.ffsns": {
        source: "iana"
    },
    "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
    },
    "application/vnd.filmit.zfc": {
        source: "iana"
    },
    "application/vnd.fints": {
        source: "iana"
    },
    "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
    },
    "application/vnd.flographit": {
        source: "iana",
        extensions: [
            "gph"
        ]
    },
    "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: [
            "ftc"
        ]
    },
    "application/vnd.font-fontforge-sfd": {
        source: "iana"
    },
    "application/vnd.framemaker": {
        source: "iana",
        extensions: [
            "fm",
            "frame",
            "maker",
            "book"
        ]
    },
    "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: [
            "fnc"
        ]
    },
    "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: [
            "ltf"
        ]
    },
    "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: [
            "fsc"
        ]
    },
    "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: [
            "oas"
        ]
    },
    "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: [
            "oa2"
        ]
    },
    "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: [
            "oa3"
        ]
    },
    "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: [
            "fg5"
        ]
    },
    "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: [
            "bh2"
        ]
    },
    "application/vnd.fujixerox.art-ex": {
        source: "iana"
    },
    "application/vnd.fujixerox.art4": {
        source: "iana"
    },
    "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: [
            "ddd"
        ]
    },
    "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: [
            "xdw"
        ]
    },
    "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: [
            "xbd"
        ]
    },
    "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
    },
    "application/vnd.fujixerox.hbpl": {
        source: "iana"
    },
    "application/vnd.fut-misnet": {
        source: "iana"
    },
    "application/vnd.futoin+cbor": {
        source: "iana"
    },
    "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: [
            "fzs"
        ]
    },
    "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: [
            "txd"
        ]
    },
    "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.geo+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.geogebra.file": {
        source: "iana",
        extensions: [
            "ggb"
        ]
    },
    "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: [
            "ggt"
        ]
    },
    "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: [
            "gex",
            "gre"
        ]
    },
    "application/vnd.geonext": {
        source: "iana",
        extensions: [
            "gxt"
        ]
    },
    "application/vnd.geoplan": {
        source: "iana",
        extensions: [
            "g2w"
        ]
    },
    "application/vnd.geospace": {
        source: "iana",
        extensions: [
            "g3w"
        ]
    },
    "application/vnd.gerber": {
        source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
    },
    "application/vnd.gmx": {
        source: "iana",
        extensions: [
            "gmx"
        ]
    },
    "application/vnd.google-apps.document": {
        compressible: false,
        extensions: [
            "gdoc"
        ]
    },
    "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: [
            "gslides"
        ]
    },
    "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: [
            "gsheet"
        ]
    },
    "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "kml"
        ]
    },
    "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: [
            "kmz"
        ]
    },
    "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
    },
    "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.grafeq": {
        source: "iana",
        extensions: [
            "gqf",
            "gqs"
        ]
    },
    "application/vnd.gridmp": {
        source: "iana"
    },
    "application/vnd.groove-account": {
        source: "iana",
        extensions: [
            "gac"
        ]
    },
    "application/vnd.groove-help": {
        source: "iana",
        extensions: [
            "ghf"
        ]
    },
    "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: [
            "gim"
        ]
    },
    "application/vnd.groove-injector": {
        source: "iana",
        extensions: [
            "grv"
        ]
    },
    "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: [
            "gtm"
        ]
    },
    "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: [
            "tpl"
        ]
    },
    "application/vnd.groove-vcard": {
        source: "iana",
        extensions: [
            "vcg"
        ]
    },
    "application/vnd.hal+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "hal"
        ]
    },
    "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "zmm"
        ]
    },
    "application/vnd.hbci": {
        source: "iana",
        extensions: [
            "hbci"
        ]
    },
    "application/vnd.hc+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.hcl-bireports": {
        source: "iana"
    },
    "application/vnd.hdt": {
        source: "iana"
    },
    "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: [
            "les"
        ]
    },
    "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: [
            "hpgl"
        ]
    },
    "application/vnd.hp-hpid": {
        source: "iana",
        extensions: [
            "hpid"
        ]
    },
    "application/vnd.hp-hps": {
        source: "iana",
        extensions: [
            "hps"
        ]
    },
    "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: [
            "jlt"
        ]
    },
    "application/vnd.hp-pcl": {
        source: "iana",
        extensions: [
            "pcl"
        ]
    },
    "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: [
            "pclxl"
        ]
    },
    "application/vnd.httphone": {
        source: "iana"
    },
    "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: [
            "sfd-hdstx"
        ]
    },
    "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.hzn-3d-crossword": {
        source: "iana"
    },
    "application/vnd.ibm.afplinedata": {
        source: "iana"
    },
    "application/vnd.ibm.electronic-media": {
        source: "iana"
    },
    "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: [
            "mpy"
        ]
    },
    "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: [
            "afp",
            "listafp",
            "list3820"
        ]
    },
    "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: [
            "irm"
        ]
    },
    "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: [
            "sc"
        ]
    },
    "application/vnd.iccprofile": {
        source: "iana",
        extensions: [
            "icc",
            "icm"
        ]
    },
    "application/vnd.ieee.1905": {
        source: "iana"
    },
    "application/vnd.igloader": {
        source: "iana",
        extensions: [
            "igl"
        ]
    },
    "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
    },
    "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
    },
    "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: [
            "ivp"
        ]
    },
    "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: [
            "ivu"
        ]
    },
    "application/vnd.ims.imsccv1p1": {
        source: "iana"
    },
    "application/vnd.ims.imsccv1p2": {
        source: "iana"
    },
    "application/vnd.ims.imsccv1p3": {
        source: "iana"
    },
    "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.informix-visionary": {
        source: "iana"
    },
    "application/vnd.infotech.project": {
        source: "iana"
    },
    "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.innopath.wamp.notification": {
        source: "iana"
    },
    "application/vnd.insors.igm": {
        source: "iana",
        extensions: [
            "igm"
        ]
    },
    "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: [
            "xpw",
            "xpx"
        ]
    },
    "application/vnd.intergeo": {
        source: "iana",
        extensions: [
            "i2g"
        ]
    },
    "application/vnd.intertrust.digibox": {
        source: "iana"
    },
    "application/vnd.intertrust.nncp": {
        source: "iana"
    },
    "application/vnd.intu.qbo": {
        source: "iana",
        extensions: [
            "qbo"
        ]
    },
    "application/vnd.intu.qfx": {
        source: "iana",
        extensions: [
            "qfx"
        ]
    },
    "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: [
            "rcprofile"
        ]
    },
    "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "irp"
        ]
    },
    "application/vnd.is-xpr": {
        source: "iana",
        extensions: [
            "xpr"
        ]
    },
    "application/vnd.isac.fcs": {
        source: "iana",
        extensions: [
            "fcs"
        ]
    },
    "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
    },
    "application/vnd.jam": {
        source: "iana",
        extensions: [
            "jam"
        ]
    },
    "application/vnd.japannet-directory-service": {
        source: "iana"
    },
    "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
    },
    "application/vnd.japannet-payment-wakeup": {
        source: "iana"
    },
    "application/vnd.japannet-registration": {
        source: "iana"
    },
    "application/vnd.japannet-registration-wakeup": {
        source: "iana"
    },
    "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
    },
    "application/vnd.japannet-verification": {
        source: "iana"
    },
    "application/vnd.japannet-verification-wakeup": {
        source: "iana"
    },
    "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: [
            "rms"
        ]
    },
    "application/vnd.jisp": {
        source: "iana",
        extensions: [
            "jisp"
        ]
    },
    "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: [
            "joda"
        ]
    },
    "application/vnd.jsk.isdn-ngn": {
        source: "iana"
    },
    "application/vnd.kahootz": {
        source: "iana",
        extensions: [
            "ktz",
            "ktr"
        ]
    },
    "application/vnd.kde.karbon": {
        source: "iana",
        extensions: [
            "karbon"
        ]
    },
    "application/vnd.kde.kchart": {
        source: "iana",
        extensions: [
            "chrt"
        ]
    },
    "application/vnd.kde.kformula": {
        source: "iana",
        extensions: [
            "kfo"
        ]
    },
    "application/vnd.kde.kivio": {
        source: "iana",
        extensions: [
            "flw"
        ]
    },
    "application/vnd.kde.kontour": {
        source: "iana",
        extensions: [
            "kon"
        ]
    },
    "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: [
            "kpr",
            "kpt"
        ]
    },
    "application/vnd.kde.kspread": {
        source: "iana",
        extensions: [
            "ksp"
        ]
    },
    "application/vnd.kde.kword": {
        source: "iana",
        extensions: [
            "kwd",
            "kwt"
        ]
    },
    "application/vnd.kenameaapp": {
        source: "iana",
        extensions: [
            "htke"
        ]
    },
    "application/vnd.kidspiration": {
        source: "iana",
        extensions: [
            "kia"
        ]
    },
    "application/vnd.kinar": {
        source: "iana",
        extensions: [
            "kne",
            "knp"
        ]
    },
    "application/vnd.koan": {
        source: "iana",
        extensions: [
            "skp",
            "skd",
            "skt",
            "skm"
        ]
    },
    "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: [
            "sse"
        ]
    },
    "application/vnd.las": {
        source: "iana"
    },
    "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "lasxml"
        ]
    },
    "application/vnd.laszip": {
        source: "iana"
    },
    "application/vnd.leap+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: [
            "lbd"
        ]
    },
    "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "lbe"
        ]
    },
    "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
    },
    "application/vnd.loom": {
        source: "iana"
    },
    "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: [
            "123"
        ]
    },
    "application/vnd.lotus-approach": {
        source: "iana",
        extensions: [
            "apr"
        ]
    },
    "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: [
            "pre"
        ]
    },
    "application/vnd.lotus-notes": {
        source: "iana",
        extensions: [
            "nsf"
        ]
    },
    "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: [
            "org"
        ]
    },
    "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: [
            "scm"
        ]
    },
    "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: [
            "lwp"
        ]
    },
    "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: [
            "portpkg"
        ]
    },
    "application/vnd.mapbox-vector-tile": {
        source: "iana"
    },
    "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.marlin.drm.mdcf": {
        source: "iana"
    },
    "application/vnd.mason+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.maxmind.maxmind-db": {
        source: "iana"
    },
    "application/vnd.mcd": {
        source: "iana",
        extensions: [
            "mcd"
        ]
    },
    "application/vnd.medcalcdata": {
        source: "iana",
        extensions: [
            "mc1"
        ]
    },
    "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: [
            "cdkey"
        ]
    },
    "application/vnd.meridian-slingshot": {
        source: "iana"
    },
    "application/vnd.mfer": {
        source: "iana",
        extensions: [
            "mwf"
        ]
    },
    "application/vnd.mfmp": {
        source: "iana",
        extensions: [
            "mfm"
        ]
    },
    "application/vnd.micro+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: [
            "flo"
        ]
    },
    "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: [
            "igx"
        ]
    },
    "application/vnd.microsoft.portable-executable": {
        source: "iana"
    },
    "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
    },
    "application/vnd.miele+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.mif": {
        source: "iana",
        extensions: [
            "mif"
        ]
    },
    "application/vnd.minisoft-hp3000-save": {
        source: "iana"
    },
    "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
    },
    "application/vnd.mobius.daf": {
        source: "iana",
        extensions: [
            "daf"
        ]
    },
    "application/vnd.mobius.dis": {
        source: "iana",
        extensions: [
            "dis"
        ]
    },
    "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: [
            "mbk"
        ]
    },
    "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: [
            "mqy"
        ]
    },
    "application/vnd.mobius.msl": {
        source: "iana",
        extensions: [
            "msl"
        ]
    },
    "application/vnd.mobius.plc": {
        source: "iana",
        extensions: [
            "plc"
        ]
    },
    "application/vnd.mobius.txf": {
        source: "iana",
        extensions: [
            "txf"
        ]
    },
    "application/vnd.mophun.application": {
        source: "iana",
        extensions: [
            "mpn"
        ]
    },
    "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: [
            "mpc"
        ]
    },
    "application/vnd.motorola.flexsuite": {
        source: "iana"
    },
    "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
    },
    "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
    },
    "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
    },
    "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
    },
    "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
    },
    "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
    },
    "application/vnd.motorola.iprm": {
        source: "iana"
    },
    "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xul"
        ]
    },
    "application/vnd.ms-3mfdocument": {
        source: "iana"
    },
    "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: [
            "cil"
        ]
    },
    "application/vnd.ms-asf": {
        source: "iana"
    },
    "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: [
            "cab"
        ]
    },
    "application/vnd.ms-color.iccprofile": {
        source: "apache"
    },
    "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: [
            "xls",
            "xlm",
            "xla",
            "xlc",
            "xlt",
            "xlw"
        ]
    },
    "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: [
            "xlam"
        ]
    },
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: [
            "xlsb"
        ]
    },
    "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: [
            "xlsm"
        ]
    },
    "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: [
            "xltm"
        ]
    },
    "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: [
            "eot"
        ]
    },
    "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: [
            "chm"
        ]
    },
    "application/vnd.ms-ims": {
        source: "iana",
        extensions: [
            "ims"
        ]
    },
    "application/vnd.ms-lrm": {
        source: "iana",
        extensions: [
            "lrm"
        ]
    },
    "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: [
            "thmx"
        ]
    },
    "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
    },
    "application/vnd.ms-outlook": {
        compressible: false,
        extensions: [
            "msg"
        ]
    },
    "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
    },
    "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: [
            "cat"
        ]
    },
    "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: [
            "stl"
        ]
    },
    "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: [
            "ppt",
            "pps",
            "pot"
        ]
    },
    "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: [
            "ppam"
        ]
    },
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: [
            "pptm"
        ]
    },
    "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: [
            "sldm"
        ]
    },
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: [
            "ppsm"
        ]
    },
    "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: [
            "potm"
        ]
    },
    "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
    },
    "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.ms-project": {
        source: "iana",
        extensions: [
            "mpp",
            "mpt"
        ]
    },
    "application/vnd.ms-tnef": {
        source: "iana"
    },
    "application/vnd.ms-windows.devicepairing": {
        source: "iana"
    },
    "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
    },
    "application/vnd.ms-windows.printerpairing": {
        source: "iana"
    },
    "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
    },
    "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: [
            "docm"
        ]
    },
    "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: [
            "dotm"
        ]
    },
    "application/vnd.ms-works": {
        source: "iana",
        extensions: [
            "wps",
            "wks",
            "wcm",
            "wdb"
        ]
    },
    "application/vnd.ms-wpl": {
        source: "iana",
        extensions: [
            "wpl"
        ]
    },
    "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: [
            "xps"
        ]
    },
    "application/vnd.msa-disk-image": {
        source: "iana"
    },
    "application/vnd.mseq": {
        source: "iana",
        extensions: [
            "mseq"
        ]
    },
    "application/vnd.msign": {
        source: "iana"
    },
    "application/vnd.multiad.creator": {
        source: "iana"
    },
    "application/vnd.multiad.creator.cif": {
        source: "iana"
    },
    "application/vnd.music-niff": {
        source: "iana"
    },
    "application/vnd.musician": {
        source: "iana",
        extensions: [
            "mus"
        ]
    },
    "application/vnd.muvee.style": {
        source: "iana",
        extensions: [
            "msty"
        ]
    },
    "application/vnd.mynfc": {
        source: "iana",
        extensions: [
            "taglet"
        ]
    },
    "application/vnd.ncd.control": {
        source: "iana"
    },
    "application/vnd.ncd.reference": {
        source: "iana"
    },
    "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.nervana": {
        source: "iana"
    },
    "application/vnd.netfpx": {
        source: "iana"
    },
    "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: [
            "nlu"
        ]
    },
    "application/vnd.nimn": {
        source: "iana"
    },
    "application/vnd.nintendo.nitro.rom": {
        source: "iana"
    },
    "application/vnd.nintendo.snes.rom": {
        source: "iana"
    },
    "application/vnd.nitf": {
        source: "iana",
        extensions: [
            "ntf",
            "nitf"
        ]
    },
    "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: [
            "nnd"
        ]
    },
    "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: [
            "nns"
        ]
    },
    "application/vnd.noblenet-web": {
        source: "iana",
        extensions: [
            "nnw"
        ]
    },
    "application/vnd.nokia.catalogs": {
        source: "iana"
    },
    "application/vnd.nokia.conml+wbxml": {
        source: "iana"
    },
    "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
    },
    "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
    },
    "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "ac"
        ]
    },
    "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: [
            "ngdat"
        ]
    },
    "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: [
            "n-gage"
        ]
    },
    "application/vnd.nokia.ncd": {
        source: "iana"
    },
    "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
    },
    "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: [
            "rpst"
        ]
    },
    "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: [
            "rpss"
        ]
    },
    "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: [
            "edm"
        ]
    },
    "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: [
            "edx"
        ]
    },
    "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: [
            "ext"
        ]
    },
    "application/vnd.ntt-local.content-share": {
        source: "iana"
    },
    "application/vnd.ntt-local.file-transfer": {
        source: "iana"
    },
    "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
    },
    "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: [
            "odc"
        ]
    },
    "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: [
            "otc"
        ]
    },
    "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: [
            "odb"
        ]
    },
    "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: [
            "odf"
        ]
    },
    "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: [
            "odft"
        ]
    },
    "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: [
            "odg"
        ]
    },
    "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: [
            "otg"
        ]
    },
    "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: [
            "odi"
        ]
    },
    "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: [
            "oti"
        ]
    },
    "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: [
            "odp"
        ]
    },
    "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: [
            "otp"
        ]
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: [
            "ods"
        ]
    },
    "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: [
            "ots"
        ]
    },
    "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: [
            "odt"
        ]
    },
    "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: [
            "odm"
        ]
    },
    "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: [
            "ott"
        ]
    },
    "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: [
            "oth"
        ]
    },
    "application/vnd.obn": {
        source: "iana"
    },
    "application/vnd.ocf+cbor": {
        source: "iana"
    },
    "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
    },
    "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oipf.pae.gem": {
        source: "iana"
    },
    "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: [
            "xo"
        ]
    },
    "application/vnd.oma-scws-config": {
        source: "iana"
    },
    "application/vnd.oma-scws-http-request": {
        source: "iana"
    },
    "application/vnd.oma-scws-http-response": {
        source: "iana"
    },
    "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.bcast.ltkm": {
        source: "iana"
    },
    "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
    },
    "application/vnd.oma.bcast.sgboot": {
        source: "iana"
    },
    "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.bcast.sgdu": {
        source: "iana"
    },
    "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
    },
    "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.bcast.stkm": {
        source: "iana"
    },
    "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.dcd": {
        source: "iana"
    },
    "application/vnd.oma.dcdc": {
        source: "iana"
    },
    "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "dd2"
        ]
    },
    "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
    },
    "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.push": {
        source: "iana"
    },
    "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/vnd.omaloc-supl-init": {
        source: "iana"
    },
    "application/vnd.onepager": {
        source: "iana"
    },
    "application/vnd.onepagertamp": {
        source: "iana"
    },
    "application/vnd.onepagertamx": {
        source: "iana"
    },
    "application/vnd.onepagertat": {
        source: "iana"
    },
    "application/vnd.onepagertatp": {
        source: "iana"
    },
    "application/vnd.onepagertatx": {
        source: "iana"
    },
    "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "obgx"
        ]
    },
    "application/vnd.openblox.game-binary": {
        source: "iana"
    },
    "application/vnd.openeye.oeb": {
        source: "iana"
    },
    "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: [
            "oxt"
        ]
    },
    "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "osm"
        ]
    },
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: [
            "pptx"
        ]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: [
            "sldx"
        ]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: [
            "ppsx"
        ]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: [
            "potx"
        ]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: [
            "xlsx"
        ]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: [
            "xltx"
        ]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: [
            "docx"
        ]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: [
            "dotx"
        ]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.orange.indata": {
        source: "iana"
    },
    "application/vnd.osa.netdeploy": {
        source: "iana"
    },
    "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: [
            "mgp"
        ]
    },
    "application/vnd.osgi.bundle": {
        source: "iana"
    },
    "application/vnd.osgi.dp": {
        source: "iana",
        extensions: [
            "dp"
        ]
    },
    "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: [
            "esa"
        ]
    },
    "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.oxli.countgraph": {
        source: "iana"
    },
    "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.palm": {
        source: "iana",
        extensions: [
            "pdb",
            "pqa",
            "oprc"
        ]
    },
    "application/vnd.panoply": {
        source: "iana"
    },
    "application/vnd.paos.xml": {
        source: "iana"
    },
    "application/vnd.patentdive": {
        source: "iana"
    },
    "application/vnd.patientecommsdoc": {
        source: "iana"
    },
    "application/vnd.pawaafile": {
        source: "iana",
        extensions: [
            "paw"
        ]
    },
    "application/vnd.pcos": {
        source: "iana"
    },
    "application/vnd.pg.format": {
        source: "iana",
        extensions: [
            "str"
        ]
    },
    "application/vnd.pg.osasli": {
        source: "iana",
        extensions: [
            "ei6"
        ]
    },
    "application/vnd.piaccess.application-licence": {
        source: "iana"
    },
    "application/vnd.picsel": {
        source: "iana",
        extensions: [
            "efif"
        ]
    },
    "application/vnd.pmi.widget": {
        source: "iana",
        extensions: [
            "wg"
        ]
    },
    "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.pocketlearn": {
        source: "iana",
        extensions: [
            "plf"
        ]
    },
    "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: [
            "pbd"
        ]
    },
    "application/vnd.powerbuilder6-s": {
        source: "iana"
    },
    "application/vnd.powerbuilder7": {
        source: "iana"
    },
    "application/vnd.powerbuilder7-s": {
        source: "iana"
    },
    "application/vnd.powerbuilder75": {
        source: "iana"
    },
    "application/vnd.powerbuilder75-s": {
        source: "iana"
    },
    "application/vnd.preminet": {
        source: "iana"
    },
    "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: [
            "box"
        ]
    },
    "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: [
            "mgz"
        ]
    },
    "application/vnd.psfs": {
        source: "iana"
    },
    "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: [
            "qps"
        ]
    },
    "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: [
            "ptid"
        ]
    },
    "application/vnd.pwg-multiplexed": {
        source: "iana"
    },
    "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
    },
    "application/vnd.quarantainenet": {
        source: "iana"
    },
    "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: [
            "qxd",
            "qxt",
            "qwd",
            "qwt",
            "qxl",
            "qxb"
        ]
    },
    "application/vnd.quobject-quoxdocument": {
        source: "iana"
    },
    "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.rainstor.data": {
        source: "iana"
    },
    "application/vnd.rapid": {
        source: "iana"
    },
    "application/vnd.rar": {
        source: "iana"
    },
    "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: [
            "bed"
        ]
    },
    "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: [
            "mxl"
        ]
    },
    "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "musicxml"
        ]
    },
    "application/vnd.renlearn.rlprint": {
        source: "iana"
    },
    "application/vnd.restful+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: [
            "cryptonote"
        ]
    },
    "application/vnd.rim.cod": {
        source: "apache",
        extensions: [
            "cod"
        ]
    },
    "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: [
            "rm"
        ]
    },
    "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: [
            "rmvb"
        ]
    },
    "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "link66"
        ]
    },
    "application/vnd.rs-274x": {
        source: "iana"
    },
    "application/vnd.ruckus.download": {
        source: "iana"
    },
    "application/vnd.s3sms": {
        source: "iana"
    },
    "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: [
            "st"
        ]
    },
    "application/vnd.sar": {
        source: "iana"
    },
    "application/vnd.sbm.cid": {
        source: "iana"
    },
    "application/vnd.sbm.mid2": {
        source: "iana"
    },
    "application/vnd.scribus": {
        source: "iana"
    },
    "application/vnd.sealed.3df": {
        source: "iana"
    },
    "application/vnd.sealed.csf": {
        source: "iana"
    },
    "application/vnd.sealed.doc": {
        source: "iana"
    },
    "application/vnd.sealed.eml": {
        source: "iana"
    },
    "application/vnd.sealed.mht": {
        source: "iana"
    },
    "application/vnd.sealed.net": {
        source: "iana"
    },
    "application/vnd.sealed.ppt": {
        source: "iana"
    },
    "application/vnd.sealed.tiff": {
        source: "iana"
    },
    "application/vnd.sealed.xls": {
        source: "iana"
    },
    "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
    },
    "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
    },
    "application/vnd.seemail": {
        source: "iana",
        extensions: [
            "see"
        ]
    },
    "application/vnd.sema": {
        source: "iana",
        extensions: [
            "sema"
        ]
    },
    "application/vnd.semd": {
        source: "iana",
        extensions: [
            "semd"
        ]
    },
    "application/vnd.semf": {
        source: "iana",
        extensions: [
            "semf"
        ]
    },
    "application/vnd.shade-save-file": {
        source: "iana"
    },
    "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: [
            "ifm"
        ]
    },
    "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: [
            "itp"
        ]
    },
    "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: [
            "iif"
        ]
    },
    "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: [
            "ipk"
        ]
    },
    "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.shp": {
        source: "iana"
    },
    "application/vnd.shx": {
        source: "iana"
    },
    "application/vnd.sigrok.session": {
        source: "iana"
    },
    "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: [
            "twd",
            "twds"
        ]
    },
    "application/vnd.siren+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.smaf": {
        source: "iana",
        extensions: [
            "mmf"
        ]
    },
    "application/vnd.smart.notebook": {
        source: "iana"
    },
    "application/vnd.smart.teacher": {
        source: "iana",
        extensions: [
            "teacher"
        ]
    },
    "application/vnd.snesdev-page-table": {
        source: "iana"
    },
    "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "fo"
        ]
    },
    "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
    },
    "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "sdkm",
            "sdkd"
        ]
    },
    "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: [
            "dxp"
        ]
    },
    "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: [
            "sfs"
        ]
    },
    "application/vnd.sqlite3": {
        source: "iana"
    },
    "application/vnd.sss-cod": {
        source: "iana"
    },
    "application/vnd.sss-dtf": {
        source: "iana"
    },
    "application/vnd.sss-ntf": {
        source: "iana"
    },
    "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: [
            "sdc"
        ]
    },
    "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: [
            "sda"
        ]
    },
    "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: [
            "sdd"
        ]
    },
    "application/vnd.stardivision.math": {
        source: "apache",
        extensions: [
            "smf"
        ]
    },
    "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: [
            "sdw",
            "vor"
        ]
    },
    "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: [
            "sgl"
        ]
    },
    "application/vnd.stepmania.package": {
        source: "iana",
        extensions: [
            "smzip"
        ]
    },
    "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: [
            "sm"
        ]
    },
    "application/vnd.street-stream": {
        source: "iana"
    },
    "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "wadl"
        ]
    },
    "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: [
            "sxc"
        ]
    },
    "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: [
            "stc"
        ]
    },
    "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: [
            "sxd"
        ]
    },
    "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: [
            "std"
        ]
    },
    "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: [
            "sxi"
        ]
    },
    "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: [
            "sti"
        ]
    },
    "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: [
            "sxm"
        ]
    },
    "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: [
            "sxw"
        ]
    },
    "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: [
            "sxg"
        ]
    },
    "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: [
            "stw"
        ]
    },
    "application/vnd.sus-calendar": {
        source: "iana",
        extensions: [
            "sus",
            "susp"
        ]
    },
    "application/vnd.svd": {
        source: "iana",
        extensions: [
            "svd"
        ]
    },
    "application/vnd.swiftview-ics": {
        source: "iana"
    },
    "application/vnd.symbian.install": {
        source: "apache",
        extensions: [
            "sis",
            "sisx"
        ]
    },
    "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
            "xsm"
        ]
    },
    "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: [
            "bdm"
        ]
    },
    "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
            "xdm"
        ]
    },
    "application/vnd.syncml.dm.notification": {
        source: "iana"
    },
    "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
    },
    "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
            "ddf"
        ]
    },
    "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
    },
    "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
    },
    "application/vnd.syncml.ds.notification": {
        source: "iana"
    },
    "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: [
            "tao"
        ]
    },
    "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: [
            "pcap",
            "cap",
            "dmp"
        ]
    },
    "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.tml": {
        source: "iana"
    },
    "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: [
            "tmo"
        ]
    },
    "application/vnd.tri.onesource": {
        source: "iana"
    },
    "application/vnd.trid.tpt": {
        source: "iana",
        extensions: [
            "tpt"
        ]
    },
    "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: [
            "mxs"
        ]
    },
    "application/vnd.trueapp": {
        source: "iana",
        extensions: [
            "tra"
        ]
    },
    "application/vnd.truedoc": {
        source: "iana"
    },
    "application/vnd.ubisoft.webplayer": {
        source: "iana"
    },
    "application/vnd.ufdl": {
        source: "iana",
        extensions: [
            "ufd",
            "ufdl"
        ]
    },
    "application/vnd.uiq.theme": {
        source: "iana",
        extensions: [
            "utz"
        ]
    },
    "application/vnd.umajin": {
        source: "iana",
        extensions: [
            "umj"
        ]
    },
    "application/vnd.unity": {
        source: "iana",
        extensions: [
            "unityweb"
        ]
    },
    "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "uoml"
        ]
    },
    "application/vnd.uplanet.alert": {
        source: "iana"
    },
    "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
    },
    "application/vnd.uplanet.bearer-choice": {
        source: "iana"
    },
    "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
    },
    "application/vnd.uplanet.cacheop": {
        source: "iana"
    },
    "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
    },
    "application/vnd.uplanet.channel": {
        source: "iana"
    },
    "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
    },
    "application/vnd.uplanet.list": {
        source: "iana"
    },
    "application/vnd.uplanet.list-wbxml": {
        source: "iana"
    },
    "application/vnd.uplanet.listcmd": {
        source: "iana"
    },
    "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
    },
    "application/vnd.uplanet.signal": {
        source: "iana"
    },
    "application/vnd.uri-map": {
        source: "iana"
    },
    "application/vnd.valve.source.material": {
        source: "iana"
    },
    "application/vnd.vcx": {
        source: "iana",
        extensions: [
            "vcx"
        ]
    },
    "application/vnd.vd-study": {
        source: "iana"
    },
    "application/vnd.vectorworks": {
        source: "iana"
    },
    "application/vnd.vel+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.verimatrix.vcas": {
        source: "iana"
    },
    "application/vnd.veryant.thin": {
        source: "iana"
    },
    "application/vnd.ves.encrypted": {
        source: "iana"
    },
    "application/vnd.vidsoft.vidconference": {
        source: "iana"
    },
    "application/vnd.visio": {
        source: "iana",
        extensions: [
            "vsd",
            "vst",
            "vss",
            "vsw"
        ]
    },
    "application/vnd.visionary": {
        source: "iana",
        extensions: [
            "vis"
        ]
    },
    "application/vnd.vividence.scriptfile": {
        source: "iana"
    },
    "application/vnd.vsf": {
        source: "iana",
        extensions: [
            "vsf"
        ]
    },
    "application/vnd.wap.sic": {
        source: "iana"
    },
    "application/vnd.wap.slc": {
        source: "iana"
    },
    "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: [
            "wbxml"
        ]
    },
    "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: [
            "wmlc"
        ]
    },
    "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: [
            "wmlsc"
        ]
    },
    "application/vnd.webturbo": {
        source: "iana",
        extensions: [
            "wtb"
        ]
    },
    "application/vnd.wfa.p2p": {
        source: "iana"
    },
    "application/vnd.wfa.wsc": {
        source: "iana"
    },
    "application/vnd.windows.devicepairing": {
        source: "iana"
    },
    "application/vnd.wmc": {
        source: "iana"
    },
    "application/vnd.wmf.bootstrap": {
        source: "iana"
    },
    "application/vnd.wolfram.mathematica": {
        source: "iana"
    },
    "application/vnd.wolfram.mathematica.package": {
        source: "iana"
    },
    "application/vnd.wolfram.player": {
        source: "iana",
        extensions: [
            "nbp"
        ]
    },
    "application/vnd.wordperfect": {
        source: "iana",
        extensions: [
            "wpd"
        ]
    },
    "application/vnd.wqd": {
        source: "iana",
        extensions: [
            "wqd"
        ]
    },
    "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
    },
    "application/vnd.wt.stf": {
        source: "iana",
        extensions: [
            "stf"
        ]
    },
    "application/vnd.wv.csp+wbxml": {
        source: "iana"
    },
    "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
    },
    "application/vnd.xara": {
        source: "iana",
        extensions: [
            "xar"
        ]
    },
    "application/vnd.xfdl": {
        source: "iana",
        extensions: [
            "xfdl"
        ]
    },
    "application/vnd.xfdl.webform": {
        source: "iana"
    },
    "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
    },
    "application/vnd.xmpie.cpkg": {
        source: "iana"
    },
    "application/vnd.xmpie.dpkg": {
        source: "iana"
    },
    "application/vnd.xmpie.plan": {
        source: "iana"
    },
    "application/vnd.xmpie.ppkg": {
        source: "iana"
    },
    "application/vnd.xmpie.xlim": {
        source: "iana"
    },
    "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: [
            "hvd"
        ]
    },
    "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: [
            "hvs"
        ]
    },
    "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: [
            "hvp"
        ]
    },
    "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: [
            "osf"
        ]
    },
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "osfpvg"
        ]
    },
    "application/vnd.yamaha.remote-setup": {
        source: "iana"
    },
    "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: [
            "saf"
        ]
    },
    "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: [
            "spf"
        ]
    },
    "application/vnd.yamaha.through-ngn": {
        source: "iana"
    },
    "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
    },
    "application/vnd.yaoweme": {
        source: "iana"
    },
    "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: [
            "cmp"
        ]
    },
    "application/vnd.youtube.yt": {
        source: "iana"
    },
    "application/vnd.zul": {
        source: "iana",
        extensions: [
            "zir",
            "zirz"
        ]
    },
    "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "zaz"
        ]
    },
    "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "vxml"
        ]
    },
    "application/voucher-cms+json": {
        source: "iana",
        compressible: true
    },
    "application/vq-rtcpxr": {
        source: "iana"
    },
    "application/wasm": {
        compressible: true,
        extensions: [
            "wasm"
        ]
    },
    "application/watcherinfo+xml": {
        source: "iana",
        compressible: true
    },
    "application/webpush-options+json": {
        source: "iana",
        compressible: true
    },
    "application/whoispp-query": {
        source: "iana"
    },
    "application/whoispp-response": {
        source: "iana"
    },
    "application/widget": {
        source: "iana",
        extensions: [
            "wgt"
        ]
    },
    "application/winhlp": {
        source: "apache",
        extensions: [
            "hlp"
        ]
    },
    "application/wita": {
        source: "iana"
    },
    "application/wordperfect5.1": {
        source: "iana"
    },
    "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "wsdl"
        ]
    },
    "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "wspolicy"
        ]
    },
    "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: [
            "7z"
        ]
    },
    "application/x-abiword": {
        source: "apache",
        extensions: [
            "abw"
        ]
    },
    "application/x-ace-compressed": {
        source: "apache",
        extensions: [
            "ace"
        ]
    },
    "application/x-amf": {
        source: "apache"
    },
    "application/x-apple-diskimage": {
        source: "apache",
        extensions: [
            "dmg"
        ]
    },
    "application/x-arj": {
        compressible: false,
        extensions: [
            "arj"
        ]
    },
    "application/x-authorware-bin": {
        source: "apache",
        extensions: [
            "aab",
            "x32",
            "u32",
            "vox"
        ]
    },
    "application/x-authorware-map": {
        source: "apache",
        extensions: [
            "aam"
        ]
    },
    "application/x-authorware-seg": {
        source: "apache",
        extensions: [
            "aas"
        ]
    },
    "application/x-bcpio": {
        source: "apache",
        extensions: [
            "bcpio"
        ]
    },
    "application/x-bdoc": {
        compressible: false,
        extensions: [
            "bdoc"
        ]
    },
    "application/x-bittorrent": {
        source: "apache",
        extensions: [
            "torrent"
        ]
    },
    "application/x-blorb": {
        source: "apache",
        extensions: [
            "blb",
            "blorb"
        ]
    },
    "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: [
            "bz"
        ]
    },
    "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: [
            "bz2",
            "boz"
        ]
    },
    "application/x-cbr": {
        source: "apache",
        extensions: [
            "cbr",
            "cba",
            "cbt",
            "cbz",
            "cb7"
        ]
    },
    "application/x-cdlink": {
        source: "apache",
        extensions: [
            "vcd"
        ]
    },
    "application/x-cfs-compressed": {
        source: "apache",
        extensions: [
            "cfs"
        ]
    },
    "application/x-chat": {
        source: "apache",
        extensions: [
            "chat"
        ]
    },
    "application/x-chess-pgn": {
        source: "apache",
        extensions: [
            "pgn"
        ]
    },
    "application/x-chrome-extension": {
        extensions: [
            "crx"
        ]
    },
    "application/x-cocoa": {
        source: "nginx",
        extensions: [
            "cco"
        ]
    },
    "application/x-compress": {
        source: "apache"
    },
    "application/x-conference": {
        source: "apache",
        extensions: [
            "nsc"
        ]
    },
    "application/x-cpio": {
        source: "apache",
        extensions: [
            "cpio"
        ]
    },
    "application/x-csh": {
        source: "apache",
        extensions: [
            "csh"
        ]
    },
    "application/x-deb": {
        compressible: false
    },
    "application/x-debian-package": {
        source: "apache",
        extensions: [
            "deb",
            "udeb"
        ]
    },
    "application/x-dgc-compressed": {
        source: "apache",
        extensions: [
            "dgc"
        ]
    },
    "application/x-director": {
        source: "apache",
        extensions: [
            "dir",
            "dcr",
            "dxr",
            "cst",
            "cct",
            "cxt",
            "w3d",
            "fgd",
            "swa"
        ]
    },
    "application/x-doom": {
        source: "apache",
        extensions: [
            "wad"
        ]
    },
    "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: [
            "ncx"
        ]
    },
    "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: [
            "dtb"
        ]
    },
    "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: [
            "res"
        ]
    },
    "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: [
            "dvi"
        ]
    },
    "application/x-envoy": {
        source: "apache",
        extensions: [
            "evy"
        ]
    },
    "application/x-eva": {
        source: "apache",
        extensions: [
            "eva"
        ]
    },
    "application/x-font-bdf": {
        source: "apache",
        extensions: [
            "bdf"
        ]
    },
    "application/x-font-dos": {
        source: "apache"
    },
    "application/x-font-framemaker": {
        source: "apache"
    },
    "application/x-font-ghostscript": {
        source: "apache",
        extensions: [
            "gsf"
        ]
    },
    "application/x-font-libgrx": {
        source: "apache"
    },
    "application/x-font-linux-psf": {
        source: "apache",
        extensions: [
            "psf"
        ]
    },
    "application/x-font-pcf": {
        source: "apache",
        extensions: [
            "pcf"
        ]
    },
    "application/x-font-snf": {
        source: "apache",
        extensions: [
            "snf"
        ]
    },
    "application/x-font-speedo": {
        source: "apache"
    },
    "application/x-font-sunos-news": {
        source: "apache"
    },
    "application/x-font-type1": {
        source: "apache",
        extensions: [
            "pfa",
            "pfb",
            "pfm",
            "afm"
        ]
    },
    "application/x-font-vfont": {
        source: "apache"
    },
    "application/x-freearc": {
        source: "apache",
        extensions: [
            "arc"
        ]
    },
    "application/x-futuresplash": {
        source: "apache",
        extensions: [
            "spl"
        ]
    },
    "application/x-gca-compressed": {
        source: "apache",
        extensions: [
            "gca"
        ]
    },
    "application/x-glulx": {
        source: "apache",
        extensions: [
            "ulx"
        ]
    },
    "application/x-gnumeric": {
        source: "apache",
        extensions: [
            "gnumeric"
        ]
    },
    "application/x-gramps-xml": {
        source: "apache",
        extensions: [
            "gramps"
        ]
    },
    "application/x-gtar": {
        source: "apache",
        extensions: [
            "gtar"
        ]
    },
    "application/x-gzip": {
        source: "apache"
    },
    "application/x-hdf": {
        source: "apache",
        extensions: [
            "hdf"
        ]
    },
    "application/x-httpd-php": {
        compressible: true,
        extensions: [
            "php"
        ]
    },
    "application/x-install-instructions": {
        source: "apache",
        extensions: [
            "install"
        ]
    },
    "application/x-iso9660-image": {
        source: "apache",
        extensions: [
            "iso"
        ]
    },
    "application/x-java-archive-diff": {
        source: "nginx",
        extensions: [
            "jardiff"
        ]
    },
    "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: [
            "jnlp"
        ]
    },
    "application/x-javascript": {
        compressible: true
    },
    "application/x-keepass2": {
        extensions: [
            "kdbx"
        ]
    },
    "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: [
            "latex"
        ]
    },
    "application/x-lua-bytecode": {
        extensions: [
            "luac"
        ]
    },
    "application/x-lzh-compressed": {
        source: "apache",
        extensions: [
            "lzh",
            "lha"
        ]
    },
    "application/x-makeself": {
        source: "nginx",
        extensions: [
            "run"
        ]
    },
    "application/x-mie": {
        source: "apache",
        extensions: [
            "mie"
        ]
    },
    "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: [
            "prc",
            "mobi"
        ]
    },
    "application/x-mpegurl": {
        compressible: false
    },
    "application/x-ms-application": {
        source: "apache",
        extensions: [
            "application"
        ]
    },
    "application/x-ms-shortcut": {
        source: "apache",
        extensions: [
            "lnk"
        ]
    },
    "application/x-ms-wmd": {
        source: "apache",
        extensions: [
            "wmd"
        ]
    },
    "application/x-ms-wmz": {
        source: "apache",
        extensions: [
            "wmz"
        ]
    },
    "application/x-ms-xbap": {
        source: "apache",
        extensions: [
            "xbap"
        ]
    },
    "application/x-msaccess": {
        source: "apache",
        extensions: [
            "mdb"
        ]
    },
    "application/x-msbinder": {
        source: "apache",
        extensions: [
            "obd"
        ]
    },
    "application/x-mscardfile": {
        source: "apache",
        extensions: [
            "crd"
        ]
    },
    "application/x-msclip": {
        source: "apache",
        extensions: [
            "clp"
        ]
    },
    "application/x-msdos-program": {
        extensions: [
            "exe"
        ]
    },
    "application/x-msdownload": {
        source: "apache",
        extensions: [
            "exe",
            "dll",
            "com",
            "bat",
            "msi"
        ]
    },
    "application/x-msmediaview": {
        source: "apache",
        extensions: [
            "mvb",
            "m13",
            "m14"
        ]
    },
    "application/x-msmetafile": {
        source: "apache",
        extensions: [
            "wmf",
            "wmz",
            "emf",
            "emz"
        ]
    },
    "application/x-msmoney": {
        source: "apache",
        extensions: [
            "mny"
        ]
    },
    "application/x-mspublisher": {
        source: "apache",
        extensions: [
            "pub"
        ]
    },
    "application/x-msschedule": {
        source: "apache",
        extensions: [
            "scd"
        ]
    },
    "application/x-msterminal": {
        source: "apache",
        extensions: [
            "trm"
        ]
    },
    "application/x-mswrite": {
        source: "apache",
        extensions: [
            "wri"
        ]
    },
    "application/x-netcdf": {
        source: "apache",
        extensions: [
            "nc",
            "cdf"
        ]
    },
    "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: [
            "pac"
        ]
    },
    "application/x-nzb": {
        source: "apache",
        extensions: [
            "nzb"
        ]
    },
    "application/x-perl": {
        source: "nginx",
        extensions: [
            "pl",
            "pm"
        ]
    },
    "application/x-pilot": {
        source: "nginx",
        extensions: [
            "prc",
            "pdb"
        ]
    },
    "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: [
            "p12",
            "pfx"
        ]
    },
    "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: [
            "p7b",
            "spc"
        ]
    },
    "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: [
            "p7r"
        ]
    },
    "application/x-pki-message": {
        source: "iana"
    },
    "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: [
            "rar"
        ]
    },
    "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: [
            "rpm"
        ]
    },
    "application/x-research-info-systems": {
        source: "apache",
        extensions: [
            "ris"
        ]
    },
    "application/x-sea": {
        source: "nginx",
        extensions: [
            "sea"
        ]
    },
    "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: [
            "sh"
        ]
    },
    "application/x-shar": {
        source: "apache",
        extensions: [
            "shar"
        ]
    },
    "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: [
            "swf"
        ]
    },
    "application/x-silverlight-app": {
        source: "apache",
        extensions: [
            "xap"
        ]
    },
    "application/x-sql": {
        source: "apache",
        extensions: [
            "sql"
        ]
    },
    "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: [
            "sit"
        ]
    },
    "application/x-stuffitx": {
        source: "apache",
        extensions: [
            "sitx"
        ]
    },
    "application/x-subrip": {
        source: "apache",
        extensions: [
            "srt"
        ]
    },
    "application/x-sv4cpio": {
        source: "apache",
        extensions: [
            "sv4cpio"
        ]
    },
    "application/x-sv4crc": {
        source: "apache",
        extensions: [
            "sv4crc"
        ]
    },
    "application/x-t3vm-image": {
        source: "apache",
        extensions: [
            "t3"
        ]
    },
    "application/x-tads": {
        source: "apache",
        extensions: [
            "gam"
        ]
    },
    "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: [
            "tar"
        ]
    },
    "application/x-tcl": {
        source: "apache",
        extensions: [
            "tcl",
            "tk"
        ]
    },
    "application/x-tex": {
        source: "apache",
        extensions: [
            "tex"
        ]
    },
    "application/x-tex-tfm": {
        source: "apache",
        extensions: [
            "tfm"
        ]
    },
    "application/x-texinfo": {
        source: "apache",
        extensions: [
            "texinfo",
            "texi"
        ]
    },
    "application/x-tgif": {
        source: "apache",
        extensions: [
            "obj"
        ]
    },
    "application/x-ustar": {
        source: "apache",
        extensions: [
            "ustar"
        ]
    },
    "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: [
            "hdd"
        ]
    },
    "application/x-virtualbox-ova": {
        compressible: true,
        extensions: [
            "ova"
        ]
    },
    "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: [
            "ovf"
        ]
    },
    "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: [
            "vbox"
        ]
    },
    "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: [
            "vbox-extpack"
        ]
    },
    "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: [
            "vdi"
        ]
    },
    "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: [
            "vhd"
        ]
    },
    "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: [
            "vmdk"
        ]
    },
    "application/x-wais-source": {
        source: "apache",
        extensions: [
            "src"
        ]
    },
    "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: [
            "webapp"
        ]
    },
    "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
    },
    "application/x-x509-ca-cert": {
        source: "iana",
        extensions: [
            "der",
            "crt",
            "pem"
        ]
    },
    "application/x-x509-ca-ra-cert": {
        source: "iana"
    },
    "application/x-x509-next-ca-cert": {
        source: "iana"
    },
    "application/x-xfig": {
        source: "apache",
        extensions: [
            "fig"
        ]
    },
    "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: [
            "xlf"
        ]
    },
    "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: [
            "xpi"
        ]
    },
    "application/x-xz": {
        source: "apache",
        extensions: [
            "xz"
        ]
    },
    "application/x-zmachine": {
        source: "apache",
        extensions: [
            "z1",
            "z2",
            "z3",
            "z4",
            "z5",
            "z6",
            "z7",
            "z8"
        ]
    },
    "application/x400-bp": {
        source: "iana"
    },
    "application/xacml+xml": {
        source: "iana",
        compressible: true
    },
    "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: [
            "xaml"
        ]
    },
    "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xav"
        ]
    },
    "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xca"
        ]
    },
    "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xdf"
        ]
    },
    "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xel"
        ]
    },
    "application/xcap-error+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xer"
        ]
    },
    "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xns"
        ]
    },
    "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
    },
    "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
    },
    "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xenc"
        ]
    },
    "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xhtml",
            "xht"
        ]
    },
    "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
    },
    "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xlf"
        ]
    },
    "application/xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xml",
            "xsl",
            "xsd",
            "rng"
        ]
    },
    "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: [
            "dtd"
        ]
    },
    "application/xml-external-parsed-entity": {
        source: "iana"
    },
    "application/xml-patch+xml": {
        source: "iana",
        compressible: true
    },
    "application/xmpp+xml": {
        source: "iana",
        compressible: true
    },
    "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xop"
        ]
    },
    "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: [
            "xpl"
        ]
    },
    "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xslt"
        ]
    },
    "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: [
            "xspf"
        ]
    },
    "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "mxml",
            "xhvml",
            "xvml",
            "xvm"
        ]
    },
    "application/yang": {
        source: "iana",
        extensions: [
            "yang"
        ]
    },
    "application/yang-data+json": {
        source: "iana",
        compressible: true
    },
    "application/yang-data+xml": {
        source: "iana",
        compressible: true
    },
    "application/yang-patch+json": {
        source: "iana",
        compressible: true
    },
    "application/yang-patch+xml": {
        source: "iana",
        compressible: true
    },
    "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "yin"
        ]
    },
    "application/zip": {
        source: "iana",
        compressible: false,
        extensions: [
            "zip"
        ]
    },
    "application/zlib": {
        source: "iana"
    },
    "application/zstd": {
        source: "iana"
    },
    "audio/1d-interleaved-parityfec": {
        source: "iana"
    },
    "audio/32kadpcm": {
        source: "iana"
    },
    "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: [
            "3gpp"
        ]
    },
    "audio/3gpp2": {
        source: "iana"
    },
    "audio/aac": {
        source: "iana"
    },
    "audio/ac3": {
        source: "iana"
    },
    "audio/adpcm": {
        source: "apache",
        extensions: [
            "adp"
        ]
    },
    "audio/amr": {
        source: "iana"
    },
    "audio/amr-wb": {
        source: "iana"
    },
    "audio/amr-wb+": {
        source: "iana"
    },
    "audio/aptx": {
        source: "iana"
    },
    "audio/asc": {
        source: "iana"
    },
    "audio/atrac-advanced-lossless": {
        source: "iana"
    },
    "audio/atrac-x": {
        source: "iana"
    },
    "audio/atrac3": {
        source: "iana"
    },
    "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: [
            "au",
            "snd"
        ]
    },
    "audio/bv16": {
        source: "iana"
    },
    "audio/bv32": {
        source: "iana"
    },
    "audio/clearmode": {
        source: "iana"
    },
    "audio/cn": {
        source: "iana"
    },
    "audio/dat12": {
        source: "iana"
    },
    "audio/dls": {
        source: "iana"
    },
    "audio/dsr-es201108": {
        source: "iana"
    },
    "audio/dsr-es202050": {
        source: "iana"
    },
    "audio/dsr-es202211": {
        source: "iana"
    },
    "audio/dsr-es202212": {
        source: "iana"
    },
    "audio/dv": {
        source: "iana"
    },
    "audio/dvi4": {
        source: "iana"
    },
    "audio/eac3": {
        source: "iana"
    },
    "audio/encaprtp": {
        source: "iana"
    },
    "audio/evrc": {
        source: "iana"
    },
    "audio/evrc-qcp": {
        source: "iana"
    },
    "audio/evrc0": {
        source: "iana"
    },
    "audio/evrc1": {
        source: "iana"
    },
    "audio/evrcb": {
        source: "iana"
    },
    "audio/evrcb0": {
        source: "iana"
    },
    "audio/evrcb1": {
        source: "iana"
    },
    "audio/evrcnw": {
        source: "iana"
    },
    "audio/evrcnw0": {
        source: "iana"
    },
    "audio/evrcnw1": {
        source: "iana"
    },
    "audio/evrcwb": {
        source: "iana"
    },
    "audio/evrcwb0": {
        source: "iana"
    },
    "audio/evrcwb1": {
        source: "iana"
    },
    "audio/evs": {
        source: "iana"
    },
    "audio/flexfec": {
        source: "iana"
    },
    "audio/fwdred": {
        source: "iana"
    },
    "audio/g711-0": {
        source: "iana"
    },
    "audio/g719": {
        source: "iana"
    },
    "audio/g722": {
        source: "iana"
    },
    "audio/g7221": {
        source: "iana"
    },
    "audio/g723": {
        source: "iana"
    },
    "audio/g726-16": {
        source: "iana"
    },
    "audio/g726-24": {
        source: "iana"
    },
    "audio/g726-32": {
        source: "iana"
    },
    "audio/g726-40": {
        source: "iana"
    },
    "audio/g728": {
        source: "iana"
    },
    "audio/g729": {
        source: "iana"
    },
    "audio/g7291": {
        source: "iana"
    },
    "audio/g729d": {
        source: "iana"
    },
    "audio/g729e": {
        source: "iana"
    },
    "audio/gsm": {
        source: "iana"
    },
    "audio/gsm-efr": {
        source: "iana"
    },
    "audio/gsm-hr-08": {
        source: "iana"
    },
    "audio/ilbc": {
        source: "iana"
    },
    "audio/ip-mr_v2.5": {
        source: "iana"
    },
    "audio/isac": {
        source: "apache"
    },
    "audio/l16": {
        source: "iana"
    },
    "audio/l20": {
        source: "iana"
    },
    "audio/l24": {
        source: "iana",
        compressible: false
    },
    "audio/l8": {
        source: "iana"
    },
    "audio/lpc": {
        source: "iana"
    },
    "audio/melp": {
        source: "iana"
    },
    "audio/melp1200": {
        source: "iana"
    },
    "audio/melp2400": {
        source: "iana"
    },
    "audio/melp600": {
        source: "iana"
    },
    "audio/mhas": {
        source: "iana"
    },
    "audio/midi": {
        source: "apache",
        extensions: [
            "mid",
            "midi",
            "kar",
            "rmi"
        ]
    },
    "audio/mobile-xmf": {
        source: "iana",
        extensions: [
            "mxmf"
        ]
    },
    "audio/mp3": {
        compressible: false,
        extensions: [
            "mp3"
        ]
    },
    "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: [
            "m4a",
            "mp4a"
        ]
    },
    "audio/mp4a-latm": {
        source: "iana"
    },
    "audio/mpa": {
        source: "iana"
    },
    "audio/mpa-robust": {
        source: "iana"
    },
    "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: [
            "mpga",
            "mp2",
            "mp2a",
            "mp3",
            "m2a",
            "m3a"
        ]
    },
    "audio/mpeg4-generic": {
        source: "iana"
    },
    "audio/musepack": {
        source: "apache"
    },
    "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: [
            "oga",
            "ogg",
            "spx"
        ]
    },
    "audio/opus": {
        source: "iana"
    },
    "audio/parityfec": {
        source: "iana"
    },
    "audio/pcma": {
        source: "iana"
    },
    "audio/pcma-wb": {
        source: "iana"
    },
    "audio/pcmu": {
        source: "iana"
    },
    "audio/pcmu-wb": {
        source: "iana"
    },
    "audio/prs.sid": {
        source: "iana"
    },
    "audio/qcelp": {
        source: "iana"
    },
    "audio/raptorfec": {
        source: "iana"
    },
    "audio/red": {
        source: "iana"
    },
    "audio/rtp-enc-aescm128": {
        source: "iana"
    },
    "audio/rtp-midi": {
        source: "iana"
    },
    "audio/rtploopback": {
        source: "iana"
    },
    "audio/rtx": {
        source: "iana"
    },
    "audio/s3m": {
        source: "apache",
        extensions: [
            "s3m"
        ]
    },
    "audio/silk": {
        source: "apache",
        extensions: [
            "sil"
        ]
    },
    "audio/smv": {
        source: "iana"
    },
    "audio/smv-qcp": {
        source: "iana"
    },
    "audio/smv0": {
        source: "iana"
    },
    "audio/sp-midi": {
        source: "iana"
    },
    "audio/speex": {
        source: "iana"
    },
    "audio/t140c": {
        source: "iana"
    },
    "audio/t38": {
        source: "iana"
    },
    "audio/telephone-event": {
        source: "iana"
    },
    "audio/tetra_acelp": {
        source: "iana"
    },
    "audio/tetra_acelp_bb": {
        source: "iana"
    },
    "audio/tone": {
        source: "iana"
    },
    "audio/uemclip": {
        source: "iana"
    },
    "audio/ulpfec": {
        source: "iana"
    },
    "audio/usac": {
        source: "iana"
    },
    "audio/vdvi": {
        source: "iana"
    },
    "audio/vmr-wb": {
        source: "iana"
    },
    "audio/vnd.3gpp.iufp": {
        source: "iana"
    },
    "audio/vnd.4sb": {
        source: "iana"
    },
    "audio/vnd.audiokoz": {
        source: "iana"
    },
    "audio/vnd.celp": {
        source: "iana"
    },
    "audio/vnd.cisco.nse": {
        source: "iana"
    },
    "audio/vnd.cmles.radio-events": {
        source: "iana"
    },
    "audio/vnd.cns.anp1": {
        source: "iana"
    },
    "audio/vnd.cns.inf1": {
        source: "iana"
    },
    "audio/vnd.dece.audio": {
        source: "iana",
        extensions: [
            "uva",
            "uvva"
        ]
    },
    "audio/vnd.digital-winds": {
        source: "iana",
        extensions: [
            "eol"
        ]
    },
    "audio/vnd.dlna.adts": {
        source: "iana"
    },
    "audio/vnd.dolby.heaac.1": {
        source: "iana"
    },
    "audio/vnd.dolby.heaac.2": {
        source: "iana"
    },
    "audio/vnd.dolby.mlp": {
        source: "iana"
    },
    "audio/vnd.dolby.mps": {
        source: "iana"
    },
    "audio/vnd.dolby.pl2": {
        source: "iana"
    },
    "audio/vnd.dolby.pl2x": {
        source: "iana"
    },
    "audio/vnd.dolby.pl2z": {
        source: "iana"
    },
    "audio/vnd.dolby.pulse.1": {
        source: "iana"
    },
    "audio/vnd.dra": {
        source: "iana",
        extensions: [
            "dra"
        ]
    },
    "audio/vnd.dts": {
        source: "iana",
        extensions: [
            "dts"
        ]
    },
    "audio/vnd.dts.hd": {
        source: "iana",
        extensions: [
            "dtshd"
        ]
    },
    "audio/vnd.dts.uhd": {
        source: "iana"
    },
    "audio/vnd.dvb.file": {
        source: "iana"
    },
    "audio/vnd.everad.plj": {
        source: "iana"
    },
    "audio/vnd.hns.audio": {
        source: "iana"
    },
    "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: [
            "lvp"
        ]
    },
    "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: [
            "pya"
        ]
    },
    "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
    },
    "audio/vnd.nortel.vbk": {
        source: "iana"
    },
    "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: [
            "ecelp4800"
        ]
    },
    "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: [
            "ecelp7470"
        ]
    },
    "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: [
            "ecelp9600"
        ]
    },
    "audio/vnd.octel.sbc": {
        source: "iana"
    },
    "audio/vnd.presonus.multitrack": {
        source: "iana"
    },
    "audio/vnd.qcelp": {
        source: "iana"
    },
    "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
    },
    "audio/vnd.rip": {
        source: "iana",
        extensions: [
            "rip"
        ]
    },
    "audio/vnd.rn-realaudio": {
        compressible: false
    },
    "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
    },
    "audio/vnd.vmx.cvsd": {
        source: "iana"
    },
    "audio/vnd.wave": {
        compressible: false
    },
    "audio/vorbis": {
        source: "iana",
        compressible: false
    },
    "audio/vorbis-config": {
        source: "iana"
    },
    "audio/wav": {
        compressible: false,
        extensions: [
            "wav"
        ]
    },
    "audio/wave": {
        compressible: false,
        extensions: [
            "wav"
        ]
    },
    "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: [
            "weba"
        ]
    },
    "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: [
            "aac"
        ]
    },
    "audio/x-aiff": {
        source: "apache",
        extensions: [
            "aif",
            "aiff",
            "aifc"
        ]
    },
    "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: [
            "caf"
        ]
    },
    "audio/x-flac": {
        source: "apache",
        extensions: [
            "flac"
        ]
    },
    "audio/x-m4a": {
        source: "nginx",
        extensions: [
            "m4a"
        ]
    },
    "audio/x-matroska": {
        source: "apache",
        extensions: [
            "mka"
        ]
    },
    "audio/x-mpegurl": {
        source: "apache",
        extensions: [
            "m3u"
        ]
    },
    "audio/x-ms-wax": {
        source: "apache",
        extensions: [
            "wax"
        ]
    },
    "audio/x-ms-wma": {
        source: "apache",
        extensions: [
            "wma"
        ]
    },
    "audio/x-pn-realaudio": {
        source: "apache",
        extensions: [
            "ram",
            "ra"
        ]
    },
    "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: [
            "rmp"
        ]
    },
    "audio/x-realaudio": {
        source: "nginx",
        extensions: [
            "ra"
        ]
    },
    "audio/x-tta": {
        source: "apache"
    },
    "audio/x-wav": {
        source: "apache",
        extensions: [
            "wav"
        ]
    },
    "audio/xm": {
        source: "apache",
        extensions: [
            "xm"
        ]
    },
    "chemical/x-cdx": {
        source: "apache",
        extensions: [
            "cdx"
        ]
    },
    "chemical/x-cif": {
        source: "apache",
        extensions: [
            "cif"
        ]
    },
    "chemical/x-cmdf": {
        source: "apache",
        extensions: [
            "cmdf"
        ]
    },
    "chemical/x-cml": {
        source: "apache",
        extensions: [
            "cml"
        ]
    },
    "chemical/x-csml": {
        source: "apache",
        extensions: [
            "csml"
        ]
    },
    "chemical/x-pdb": {
        source: "apache"
    },
    "chemical/x-xyz": {
        source: "apache",
        extensions: [
            "xyz"
        ]
    },
    "font/collection": {
        source: "iana",
        extensions: [
            "ttc"
        ]
    },
    "font/otf": {
        source: "iana",
        compressible: true,
        extensions: [
            "otf"
        ]
    },
    "font/sfnt": {
        source: "iana"
    },
    "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: [
            "ttf"
        ]
    },
    "font/woff": {
        source: "iana",
        extensions: [
            "woff"
        ]
    },
    "font/woff2": {
        source: "iana",
        extensions: [
            "woff2"
        ]
    },
    "image/aces": {
        source: "iana",
        extensions: [
            "exr"
        ]
    },
    "image/apng": {
        compressible: false,
        extensions: [
            "apng"
        ]
    },
    "image/avci": {
        source: "iana"
    },
    "image/avcs": {
        source: "iana"
    },
    "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: [
            "bmp"
        ]
    },
    "image/cgm": {
        source: "iana",
        extensions: [
            "cgm"
        ]
    },
    "image/dicom-rle": {
        source: "iana",
        extensions: [
            "drle"
        ]
    },
    "image/emf": {
        source: "iana",
        extensions: [
            "emf"
        ]
    },
    "image/fits": {
        source: "iana",
        extensions: [
            "fits"
        ]
    },
    "image/g3fax": {
        source: "iana",
        extensions: [
            "g3"
        ]
    },
    "image/gif": {
        source: "iana",
        compressible: false,
        extensions: [
            "gif"
        ]
    },
    "image/heic": {
        source: "iana",
        extensions: [
            "heic"
        ]
    },
    "image/heic-sequence": {
        source: "iana",
        extensions: [
            "heics"
        ]
    },
    "image/heif": {
        source: "iana",
        extensions: [
            "heif"
        ]
    },
    "image/heif-sequence": {
        source: "iana",
        extensions: [
            "heifs"
        ]
    },
    "image/hej2k": {
        source: "iana",
        extensions: [
            "hej2"
        ]
    },
    "image/hsj2": {
        source: "iana",
        extensions: [
            "hsj2"
        ]
    },
    "image/ief": {
        source: "iana",
        extensions: [
            "ief"
        ]
    },
    "image/jls": {
        source: "iana",
        extensions: [
            "jls"
        ]
    },
    "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: [
            "jp2",
            "jpg2"
        ]
    },
    "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: [
            "jpeg",
            "jpg",
            "jpe"
        ]
    },
    "image/jph": {
        source: "iana",
        extensions: [
            "jph"
        ]
    },
    "image/jphc": {
        source: "iana",
        extensions: [
            "jhc"
        ]
    },
    "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: [
            "jpm"
        ]
    },
    "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: [
            "jpx",
            "jpf"
        ]
    },
    "image/jxr": {
        source: "iana",
        extensions: [
            "jxr"
        ]
    },
    "image/jxra": {
        source: "iana",
        extensions: [
            "jxra"
        ]
    },
    "image/jxrs": {
        source: "iana",
        extensions: [
            "jxrs"
        ]
    },
    "image/jxs": {
        source: "iana",
        extensions: [
            "jxs"
        ]
    },
    "image/jxsc": {
        source: "iana",
        extensions: [
            "jxsc"
        ]
    },
    "image/jxsi": {
        source: "iana",
        extensions: [
            "jxsi"
        ]
    },
    "image/jxss": {
        source: "iana",
        extensions: [
            "jxss"
        ]
    },
    "image/ktx": {
        source: "iana",
        extensions: [
            "ktx"
        ]
    },
    "image/naplps": {
        source: "iana"
    },
    "image/pjpeg": {
        compressible: false
    },
    "image/png": {
        source: "iana",
        compressible: false,
        extensions: [
            "png"
        ]
    },
    "image/prs.btif": {
        source: "iana",
        extensions: [
            "btif"
        ]
    },
    "image/prs.pti": {
        source: "iana",
        extensions: [
            "pti"
        ]
    },
    "image/pwg-raster": {
        source: "iana"
    },
    "image/sgi": {
        source: "apache",
        extensions: [
            "sgi"
        ]
    },
    "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "svg",
            "svgz"
        ]
    },
    "image/t38": {
        source: "iana",
        extensions: [
            "t38"
        ]
    },
    "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: [
            "tif",
            "tiff"
        ]
    },
    "image/tiff-fx": {
        source: "iana",
        extensions: [
            "tfx"
        ]
    },
    "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: [
            "psd"
        ]
    },
    "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: [
            "azv"
        ]
    },
    "image/vnd.cns.inf2": {
        source: "iana"
    },
    "image/vnd.dece.graphic": {
        source: "iana",
        extensions: [
            "uvi",
            "uvvi",
            "uvg",
            "uvvg"
        ]
    },
    "image/vnd.djvu": {
        source: "iana",
        extensions: [
            "djvu",
            "djv"
        ]
    },
    "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: [
            "sub"
        ]
    },
    "image/vnd.dwg": {
        source: "iana",
        extensions: [
            "dwg"
        ]
    },
    "image/vnd.dxf": {
        source: "iana",
        extensions: [
            "dxf"
        ]
    },
    "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: [
            "fbs"
        ]
    },
    "image/vnd.fpx": {
        source: "iana",
        extensions: [
            "fpx"
        ]
    },
    "image/vnd.fst": {
        source: "iana",
        extensions: [
            "fst"
        ]
    },
    "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: [
            "mmr"
        ]
    },
    "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: [
            "rlc"
        ]
    },
    "image/vnd.globalgraphics.pgb": {
        source: "iana"
    },
    "image/vnd.microsoft.icon": {
        source: "iana",
        extensions: [
            "ico"
        ]
    },
    "image/vnd.mix": {
        source: "iana"
    },
    "image/vnd.mozilla.apng": {
        source: "iana"
    },
    "image/vnd.ms-dds": {
        extensions: [
            "dds"
        ]
    },
    "image/vnd.ms-modi": {
        source: "iana",
        extensions: [
            "mdi"
        ]
    },
    "image/vnd.ms-photo": {
        source: "apache",
        extensions: [
            "wdp"
        ]
    },
    "image/vnd.net-fpx": {
        source: "iana",
        extensions: [
            "npx"
        ]
    },
    "image/vnd.radiance": {
        source: "iana"
    },
    "image/vnd.sealed.png": {
        source: "iana"
    },
    "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
    },
    "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
    },
    "image/vnd.svf": {
        source: "iana"
    },
    "image/vnd.tencent.tap": {
        source: "iana",
        extensions: [
            "tap"
        ]
    },
    "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: [
            "vtf"
        ]
    },
    "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: [
            "wbmp"
        ]
    },
    "image/vnd.xiff": {
        source: "iana",
        extensions: [
            "xif"
        ]
    },
    "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: [
            "pcx"
        ]
    },
    "image/webp": {
        source: "apache",
        extensions: [
            "webp"
        ]
    },
    "image/wmf": {
        source: "iana",
        extensions: [
            "wmf"
        ]
    },
    "image/x-3ds": {
        source: "apache",
        extensions: [
            "3ds"
        ]
    },
    "image/x-cmu-raster": {
        source: "apache",
        extensions: [
            "ras"
        ]
    },
    "image/x-cmx": {
        source: "apache",
        extensions: [
            "cmx"
        ]
    },
    "image/x-freehand": {
        source: "apache",
        extensions: [
            "fh",
            "fhc",
            "fh4",
            "fh5",
            "fh7"
        ]
    },
    "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: [
            "ico"
        ]
    },
    "image/x-jng": {
        source: "nginx",
        extensions: [
            "jng"
        ]
    },
    "image/x-mrsid-image": {
        source: "apache",
        extensions: [
            "sid"
        ]
    },
    "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: [
            "bmp"
        ]
    },
    "image/x-pcx": {
        source: "apache",
        extensions: [
            "pcx"
        ]
    },
    "image/x-pict": {
        source: "apache",
        extensions: [
            "pic",
            "pct"
        ]
    },
    "image/x-portable-anymap": {
        source: "apache",
        extensions: [
            "pnm"
        ]
    },
    "image/x-portable-bitmap": {
        source: "apache",
        extensions: [
            "pbm"
        ]
    },
    "image/x-portable-graymap": {
        source: "apache",
        extensions: [
            "pgm"
        ]
    },
    "image/x-portable-pixmap": {
        source: "apache",
        extensions: [
            "ppm"
        ]
    },
    "image/x-rgb": {
        source: "apache",
        extensions: [
            "rgb"
        ]
    },
    "image/x-tga": {
        source: "apache",
        extensions: [
            "tga"
        ]
    },
    "image/x-xbitmap": {
        source: "apache",
        extensions: [
            "xbm"
        ]
    },
    "image/x-xcf": {
        compressible: false
    },
    "image/x-xpixmap": {
        source: "apache",
        extensions: [
            "xpm"
        ]
    },
    "image/x-xwindowdump": {
        source: "apache",
        extensions: [
            "xwd"
        ]
    },
    "message/cpim": {
        source: "iana"
    },
    "message/delivery-status": {
        source: "iana"
    },
    "message/disposition-notification": {
        source: "iana",
        extensions: [
            "disposition-notification"
        ]
    },
    "message/external-body": {
        source: "iana"
    },
    "message/feedback-report": {
        source: "iana"
    },
    "message/global": {
        source: "iana",
        extensions: [
            "u8msg"
        ]
    },
    "message/global-delivery-status": {
        source: "iana",
        extensions: [
            "u8dsn"
        ]
    },
    "message/global-disposition-notification": {
        source: "iana",
        extensions: [
            "u8mdn"
        ]
    },
    "message/global-headers": {
        source: "iana",
        extensions: [
            "u8hdr"
        ]
    },
    "message/http": {
        source: "iana",
        compressible: false
    },
    "message/imdn+xml": {
        source: "iana",
        compressible: true
    },
    "message/news": {
        source: "iana"
    },
    "message/partial": {
        source: "iana",
        compressible: false
    },
    "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: [
            "eml",
            "mime"
        ]
    },
    "message/s-http": {
        source: "iana"
    },
    "message/sip": {
        source: "iana"
    },
    "message/sipfrag": {
        source: "iana"
    },
    "message/tracking-status": {
        source: "iana"
    },
    "message/vnd.si.simp": {
        source: "iana"
    },
    "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: [
            "wsc"
        ]
    },
    "model/3mf": {
        source: "iana",
        extensions: [
            "3mf"
        ]
    },
    "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: [
            "gltf"
        ]
    },
    "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: [
            "glb"
        ]
    },
    "model/iges": {
        source: "iana",
        compressible: false,
        extensions: [
            "igs",
            "iges"
        ]
    },
    "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: [
            "msh",
            "mesh",
            "silo"
        ]
    },
    "model/mtl": {
        source: "iana",
        extensions: [
            "mtl"
        ]
    },
    "model/obj": {
        source: "iana",
        extensions: [
            "obj"
        ]
    },
    "model/stl": {
        source: "iana",
        extensions: [
            "stl"
        ]
    },
    "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "dae"
        ]
    },
    "model/vnd.dwf": {
        source: "iana",
        extensions: [
            "dwf"
        ]
    },
    "model/vnd.flatland.3dml": {
        source: "iana"
    },
    "model/vnd.gdl": {
        source: "iana",
        extensions: [
            "gdl"
        ]
    },
    "model/vnd.gs-gdl": {
        source: "apache"
    },
    "model/vnd.gs.gdl": {
        source: "iana"
    },
    "model/vnd.gtw": {
        source: "iana",
        extensions: [
            "gtw"
        ]
    },
    "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
    },
    "model/vnd.mts": {
        source: "iana",
        extensions: [
            "mts"
        ]
    },
    "model/vnd.opengex": {
        source: "iana",
        extensions: [
            "ogex"
        ]
    },
    "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: [
            "x_b"
        ]
    },
    "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: [
            "x_t"
        ]
    },
    "model/vnd.rosette.annotated-data-model": {
        source: "iana"
    },
    "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: [
            "usdz"
        ]
    },
    "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: [
            "bsp"
        ]
    },
    "model/vnd.vtu": {
        source: "iana",
        extensions: [
            "vtu"
        ]
    },
    "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: [
            "wrl",
            "vrml"
        ]
    },
    "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: [
            "x3db",
            "x3dbz"
        ]
    },
    "model/x3d+fastinfoset": {
        source: "iana",
        extensions: [
            "x3db"
        ]
    },
    "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: [
            "x3dv",
            "x3dvz"
        ]
    },
    "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "x3d",
            "x3dz"
        ]
    },
    "model/x3d-vrml": {
        source: "iana",
        extensions: [
            "x3dv"
        ]
    },
    "multipart/alternative": {
        source: "iana",
        compressible: false
    },
    "multipart/appledouble": {
        source: "iana"
    },
    "multipart/byteranges": {
        source: "iana"
    },
    "multipart/digest": {
        source: "iana"
    },
    "multipart/encrypted": {
        source: "iana",
        compressible: false
    },
    "multipart/form-data": {
        source: "iana",
        compressible: false
    },
    "multipart/header-set": {
        source: "iana"
    },
    "multipart/mixed": {
        source: "iana"
    },
    "multipart/multilingual": {
        source: "iana"
    },
    "multipart/parallel": {
        source: "iana"
    },
    "multipart/related": {
        source: "iana",
        compressible: false
    },
    "multipart/report": {
        source: "iana"
    },
    "multipart/signed": {
        source: "iana",
        compressible: false
    },
    "multipart/vnd.bint.med-plus": {
        source: "iana"
    },
    "multipart/voice-message": {
        source: "iana"
    },
    "multipart/x-mixed-replace": {
        source: "iana"
    },
    "text/1d-interleaved-parityfec": {
        source: "iana"
    },
    "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: [
            "appcache",
            "manifest"
        ]
    },
    "text/calendar": {
        source: "iana",
        extensions: [
            "ics",
            "ifb"
        ]
    },
    "text/calender": {
        compressible: true
    },
    "text/cmd": {
        compressible: true
    },
    "text/coffeescript": {
        extensions: [
            "coffee",
            "litcoffee"
        ]
    },
    "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
            "css"
        ]
    },
    "text/csv": {
        source: "iana",
        compressible: true,
        extensions: [
            "csv"
        ]
    },
    "text/csv-schema": {
        source: "iana"
    },
    "text/directory": {
        source: "iana"
    },
    "text/dns": {
        source: "iana"
    },
    "text/ecmascript": {
        source: "iana"
    },
    "text/encaprtp": {
        source: "iana"
    },
    "text/enriched": {
        source: "iana"
    },
    "text/flexfec": {
        source: "iana"
    },
    "text/fwdred": {
        source: "iana"
    },
    "text/grammar-ref-list": {
        source: "iana"
    },
    "text/html": {
        source: "iana",
        compressible: true,
        extensions: [
            "html",
            "htm",
            "shtml"
        ]
    },
    "text/jade": {
        extensions: [
            "jade"
        ]
    },
    "text/javascript": {
        source: "iana",
        compressible: true
    },
    "text/jcr-cnd": {
        source: "iana"
    },
    "text/jsx": {
        compressible: true,
        extensions: [
            "jsx"
        ]
    },
    "text/less": {
        compressible: true,
        extensions: [
            "less"
        ]
    },
    "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: [
            "markdown",
            "md"
        ]
    },
    "text/mathml": {
        source: "nginx",
        extensions: [
            "mml"
        ]
    },
    "text/mdx": {
        compressible: true,
        extensions: [
            "mdx"
        ]
    },
    "text/mizar": {
        source: "iana"
    },
    "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
            "n3"
        ]
    },
    "text/parameters": {
        source: "iana",
        charset: "UTF-8"
    },
    "text/parityfec": {
        source: "iana"
    },
    "text/plain": {
        source: "iana",
        compressible: true,
        extensions: [
            "txt",
            "text",
            "conf",
            "def",
            "list",
            "log",
            "in",
            "ini"
        ]
    },
    "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
    },
    "text/prs.fallenstein.rst": {
        source: "iana"
    },
    "text/prs.lines.tag": {
        source: "iana",
        extensions: [
            "dsc"
        ]
    },
    "text/prs.prop.logic": {
        source: "iana"
    },
    "text/raptorfec": {
        source: "iana"
    },
    "text/red": {
        source: "iana"
    },
    "text/rfc822-headers": {
        source: "iana"
    },
    "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: [
            "rtx"
        ]
    },
    "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: [
            "rtf"
        ]
    },
    "text/rtp-enc-aescm128": {
        source: "iana"
    },
    "text/rtploopback": {
        source: "iana"
    },
    "text/rtx": {
        source: "iana"
    },
    "text/sgml": {
        source: "iana",
        extensions: [
            "sgml",
            "sgm"
        ]
    },
    "text/shex": {
        extensions: [
            "shex"
        ]
    },
    "text/slim": {
        extensions: [
            "slim",
            "slm"
        ]
    },
    "text/strings": {
        source: "iana"
    },
    "text/stylus": {
        extensions: [
            "stylus",
            "styl"
        ]
    },
    "text/t140": {
        source: "iana"
    },
    "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: [
            "tsv"
        ]
    },
    "text/troff": {
        source: "iana",
        extensions: [
            "t",
            "tr",
            "roff",
            "man",
            "me",
            "ms"
        ]
    },
    "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: [
            "ttl"
        ]
    },
    "text/ulpfec": {
        source: "iana"
    },
    "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: [
            "uri",
            "uris",
            "urls"
        ]
    },
    "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: [
            "vcard"
        ]
    },
    "text/vnd.a": {
        source: "iana"
    },
    "text/vnd.abc": {
        source: "iana"
    },
    "text/vnd.ascii-art": {
        source: "iana"
    },
    "text/vnd.curl": {
        source: "iana",
        extensions: [
            "curl"
        ]
    },
    "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: [
            "dcurl"
        ]
    },
    "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: [
            "mcurl"
        ]
    },
    "text/vnd.curl.scurl": {
        source: "apache",
        extensions: [
            "scurl"
        ]
    },
    "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
    },
    "text/vnd.dmclientscript": {
        source: "iana"
    },
    "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: [
            "sub"
        ]
    },
    "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
    },
    "text/vnd.ficlab.flt": {
        source: "iana"
    },
    "text/vnd.fly": {
        source: "iana",
        extensions: [
            "fly"
        ]
    },
    "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: [
            "flx"
        ]
    },
    "text/vnd.gml": {
        source: "iana"
    },
    "text/vnd.graphviz": {
        source: "iana",
        extensions: [
            "gv"
        ]
    },
    "text/vnd.hgl": {
        source: "iana"
    },
    "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: [
            "3dml"
        ]
    },
    "text/vnd.in3d.spot": {
        source: "iana",
        extensions: [
            "spot"
        ]
    },
    "text/vnd.iptc.newsml": {
        source: "iana"
    },
    "text/vnd.iptc.nitf": {
        source: "iana"
    },
    "text/vnd.latex-z": {
        source: "iana"
    },
    "text/vnd.motorola.reflex": {
        source: "iana"
    },
    "text/vnd.ms-mediapackage": {
        source: "iana"
    },
    "text/vnd.net2phone.commcenter.command": {
        source: "iana"
    },
    "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
    },
    "text/vnd.senx.warpscript": {
        source: "iana"
    },
    "text/vnd.si.uricatalogue": {
        source: "iana"
    },
    "text/vnd.sosi": {
        source: "iana"
    },
    "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: [
            "jad"
        ]
    },
    "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
    },
    "text/vnd.wap.si": {
        source: "iana"
    },
    "text/vnd.wap.sl": {
        source: "iana"
    },
    "text/vnd.wap.wml": {
        source: "iana",
        extensions: [
            "wml"
        ]
    },
    "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: [
            "wmls"
        ]
    },
    "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
            "vtt"
        ]
    },
    "text/x-asm": {
        source: "apache",
        extensions: [
            "s",
            "asm"
        ]
    },
    "text/x-c": {
        source: "apache",
        extensions: [
            "c",
            "cc",
            "cxx",
            "cpp",
            "h",
            "hh",
            "dic"
        ]
    },
    "text/x-component": {
        source: "nginx",
        extensions: [
            "htc"
        ]
    },
    "text/x-fortran": {
        source: "apache",
        extensions: [
            "f",
            "for",
            "f77",
            "f90"
        ]
    },
    "text/x-gwt-rpc": {
        compressible: true
    },
    "text/x-handlebars-template": {
        extensions: [
            "hbs"
        ]
    },
    "text/x-java-source": {
        source: "apache",
        extensions: [
            "java"
        ]
    },
    "text/x-jquery-tmpl": {
        compressible: true
    },
    "text/x-lua": {
        extensions: [
            "lua"
        ]
    },
    "text/x-markdown": {
        compressible: true,
        extensions: [
            "mkd"
        ]
    },
    "text/x-nfo": {
        source: "apache",
        extensions: [
            "nfo"
        ]
    },
    "text/x-opml": {
        source: "apache",
        extensions: [
            "opml"
        ]
    },
    "text/x-org": {
        compressible: true,
        extensions: [
            "org"
        ]
    },
    "text/x-pascal": {
        source: "apache",
        extensions: [
            "p",
            "pas"
        ]
    },
    "text/x-processing": {
        compressible: true,
        extensions: [
            "pde"
        ]
    },
    "text/x-sass": {
        extensions: [
            "sass"
        ]
    },
    "text/x-scss": {
        extensions: [
            "scss"
        ]
    },
    "text/x-setext": {
        source: "apache",
        extensions: [
            "etx"
        ]
    },
    "text/x-sfv": {
        source: "apache",
        extensions: [
            "sfv"
        ]
    },
    "text/x-suse-ymp": {
        compressible: true,
        extensions: [
            "ymp"
        ]
    },
    "text/x-uuencode": {
        source: "apache",
        extensions: [
            "uu"
        ]
    },
    "text/x-vcalendar": {
        source: "apache",
        extensions: [
            "vcs"
        ]
    },
    "text/x-vcard": {
        source: "apache",
        extensions: [
            "vcf"
        ]
    },
    "text/xml": {
        source: "iana",
        compressible: true,
        extensions: [
            "xml"
        ]
    },
    "text/xml-external-parsed-entity": {
        source: "iana"
    },
    "text/yaml": {
        extensions: [
            "yaml",
            "yml"
        ]
    },
    "video/1d-interleaved-parityfec": {
        source: "iana"
    },
    "video/3gpp": {
        source: "iana",
        extensions: [
            "3gp",
            "3gpp"
        ]
    },
    "video/3gpp-tt": {
        source: "iana"
    },
    "video/3gpp2": {
        source: "iana",
        extensions: [
            "3g2"
        ]
    },
    "video/bmpeg": {
        source: "iana"
    },
    "video/bt656": {
        source: "iana"
    },
    "video/celb": {
        source: "iana"
    },
    "video/dv": {
        source: "iana"
    },
    "video/encaprtp": {
        source: "iana"
    },
    "video/flexfec": {
        source: "iana"
    },
    "video/h261": {
        source: "iana",
        extensions: [
            "h261"
        ]
    },
    "video/h263": {
        source: "iana",
        extensions: [
            "h263"
        ]
    },
    "video/h263-1998": {
        source: "iana"
    },
    "video/h263-2000": {
        source: "iana"
    },
    "video/h264": {
        source: "iana",
        extensions: [
            "h264"
        ]
    },
    "video/h264-rcdo": {
        source: "iana"
    },
    "video/h264-svc": {
        source: "iana"
    },
    "video/h265": {
        source: "iana"
    },
    "video/iso.segment": {
        source: "iana"
    },
    "video/jpeg": {
        source: "iana",
        extensions: [
            "jpgv"
        ]
    },
    "video/jpeg2000": {
        source: "iana"
    },
    "video/jpm": {
        source: "apache",
        extensions: [
            "jpm",
            "jpgm"
        ]
    },
    "video/mj2": {
        source: "iana",
        extensions: [
            "mj2",
            "mjp2"
        ]
    },
    "video/mp1s": {
        source: "iana"
    },
    "video/mp2p": {
        source: "iana"
    },
    "video/mp2t": {
        source: "iana",
        extensions: [
            "ts"
        ]
    },
    "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: [
            "mp4",
            "mp4v",
            "mpg4"
        ]
    },
    "video/mp4v-es": {
        source: "iana"
    },
    "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: [
            "mpeg",
            "mpg",
            "mpe",
            "m1v",
            "m2v"
        ]
    },
    "video/mpeg4-generic": {
        source: "iana"
    },
    "video/mpv": {
        source: "iana"
    },
    "video/nv": {
        source: "iana"
    },
    "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: [
            "ogv"
        ]
    },
    "video/parityfec": {
        source: "iana"
    },
    "video/pointer": {
        source: "iana"
    },
    "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: [
            "qt",
            "mov"
        ]
    },
    "video/raptorfec": {
        source: "iana"
    },
    "video/raw": {
        source: "iana"
    },
    "video/rtp-enc-aescm128": {
        source: "iana"
    },
    "video/rtploopback": {
        source: "iana"
    },
    "video/rtx": {
        source: "iana"
    },
    "video/smpte291": {
        source: "iana"
    },
    "video/smpte292m": {
        source: "iana"
    },
    "video/ulpfec": {
        source: "iana"
    },
    "video/vc1": {
        source: "iana"
    },
    "video/vc2": {
        source: "iana"
    },
    "video/vnd.cctv": {
        source: "iana"
    },
    "video/vnd.dece.hd": {
        source: "iana",
        extensions: [
            "uvh",
            "uvvh"
        ]
    },
    "video/vnd.dece.mobile": {
        source: "iana",
        extensions: [
            "uvm",
            "uvvm"
        ]
    },
    "video/vnd.dece.mp4": {
        source: "iana"
    },
    "video/vnd.dece.pd": {
        source: "iana",
        extensions: [
            "uvp",
            "uvvp"
        ]
    },
    "video/vnd.dece.sd": {
        source: "iana",
        extensions: [
            "uvs",
            "uvvs"
        ]
    },
    "video/vnd.dece.video": {
        source: "iana",
        extensions: [
            "uvv",
            "uvvv"
        ]
    },
    "video/vnd.directv.mpeg": {
        source: "iana"
    },
    "video/vnd.directv.mpeg-tts": {
        source: "iana"
    },
    "video/vnd.dlna.mpeg-tts": {
        source: "iana"
    },
    "video/vnd.dvb.file": {
        source: "iana",
        extensions: [
            "dvb"
        ]
    },
    "video/vnd.fvt": {
        source: "iana",
        extensions: [
            "fvt"
        ]
    },
    "video/vnd.hns.video": {
        source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
    },
    "video/vnd.iptvforum.ttsavc": {
        source: "iana"
    },
    "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
    },
    "video/vnd.motorola.video": {
        source: "iana"
    },
    "video/vnd.motorola.videop": {
        source: "iana"
    },
    "video/vnd.mpegurl": {
        source: "iana",
        extensions: [
            "mxu",
            "m4u"
        ]
    },
    "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: [
            "pyv"
        ]
    },
    "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
    },
    "video/vnd.nokia.mp4vr": {
        source: "iana"
    },
    "video/vnd.nokia.videovoip": {
        source: "iana"
    },
    "video/vnd.objectvideo": {
        source: "iana"
    },
    "video/vnd.radgamettools.bink": {
        source: "iana"
    },
    "video/vnd.radgamettools.smacker": {
        source: "iana"
    },
    "video/vnd.sealed.mpeg1": {
        source: "iana"
    },
    "video/vnd.sealed.mpeg4": {
        source: "iana"
    },
    "video/vnd.sealed.swf": {
        source: "iana"
    },
    "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
    },
    "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: [
            "uvu",
            "uvvu"
        ]
    },
    "video/vnd.vivo": {
        source: "iana",
        extensions: [
            "viv"
        ]
    },
    "video/vnd.youtube.yt": {
        source: "iana"
    },
    "video/vp8": {
        source: "iana"
    },
    "video/webm": {
        source: "apache",
        compressible: false,
        extensions: [
            "webm"
        ]
    },
    "video/x-f4v": {
        source: "apache",
        extensions: [
            "f4v"
        ]
    },
    "video/x-fli": {
        source: "apache",
        extensions: [
            "fli"
        ]
    },
    "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: [
            "flv"
        ]
    },
    "video/x-m4v": {
        source: "apache",
        extensions: [
            "m4v"
        ]
    },
    "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: [
            "mkv",
            "mk3d",
            "mks"
        ]
    },
    "video/x-mng": {
        source: "apache",
        extensions: [
            "mng"
        ]
    },
    "video/x-ms-asf": {
        source: "apache",
        extensions: [
            "asf",
            "asx"
        ]
    },
    "video/x-ms-vob": {
        source: "apache",
        extensions: [
            "vob"
        ]
    },
    "video/x-ms-wm": {
        source: "apache",
        extensions: [
            "wm"
        ]
    },
    "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: [
            "wmv"
        ]
    },
    "video/x-ms-wmx": {
        source: "apache",
        extensions: [
            "wmx"
        ]
    },
    "video/x-ms-wvx": {
        source: "apache",
        extensions: [
            "wvx"
        ]
    },
    "video/x-msvideo": {
        source: "apache",
        extensions: [
            "avi"
        ]
    },
    "video/x-sgi-movie": {
        source: "apache",
        extensions: [
            "movie"
        ]
    },
    "video/x-smv": {
        source: "apache",
        extensions: [
            "smv"
        ]
    },
    "x-conference/x-cooltalk": {
        source: "apache",
        extensions: [
            "ice"
        ]
    },
    "x-shader/x-fragment": {
        compressible: true
    },
    "x-shader/x-vertex": {
        compressible: true
    }
};
const CHAR_FORWARD_SLASH2 = 47;
let NATIVE_OS2 = "linux";
const navigator2 = globalThis.navigator;
if (globalThis.Deno != null) {
    NATIVE_OS2 = Deno.build.os;
} else if (navigator2?.appVersion?.includes?.("Win") ?? false) {
    NATIVE_OS2 = "windows";
}
const isWindows2 = NATIVE_OS2 == "windows";
function assertPath2(path2) {
    if (typeof path2 !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
    }
}
function isPosixPathSeparator2(code1) {
    return code1 === 47;
}
function isPathSeparator2(code1) {
    return isPosixPathSeparator2(code1) || code1 === 92;
}
function isWindowsDeviceRoot2(code1) {
    return code1 >= 97 && code1 <= 122 || code1 >= 65 && code1 <= 90;
}
function normalizeString2(path2, allowAboveRoot, separator, isPathSeparator3) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code1;
    for(let i4 = 0, len = path2.length; i4 <= len; ++i4){
        if (i4 < len) code1 = path2.charCodeAt(i4);
        else if (isPathSeparator3(code1)) break;
        else code1 = CHAR_FORWARD_SLASH2;
        if (isPathSeparator3(code1)) {
            if (lastSlash === i4 - 1 || dots === 1) {
            } else if (lastSlash !== i4 - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i4;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i4;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path2.slice(lastSlash + 1, i4);
                else res = path2.slice(lastSlash + 1, i4);
                lastSegmentLength = i4 - lastSlash - 1;
            }
            lastSlash = i4;
            dots = 0;
        } else if (code1 === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format2(sep6, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep6 + base;
}
const sep6 = "\\";
const delimiter6 = ";";
function resolve7(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i4 = pathSegments.length - 1; i4 >= -1; i4--){
        let path2;
        if (i4 >= 0) {
            path2 = pathSegments[i4];
        } else if (!resolvedDevice) {
            if (globalThis.Deno == null) {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path2 = Deno.cwd();
        } else {
            if (globalThis.Deno == null) {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path2 = Deno.env.get(`=${resolvedDevice}`) || Deno.cwd();
            if (path2 === undefined || path2.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path2 = `${resolvedDevice}\\`;
            }
        }
        assertPath2(path2);
        const len = path2.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute6 = false;
        const code1 = path2.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator2(code1)) {
                isAbsolute6 = true;
                if (isPathSeparator2(path2.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator2(path2.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path2.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator2(path2.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator2(path2.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path2.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path2.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot2(code1)) {
                if (path2.charCodeAt(1) === 58) {
                    device = path2.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator2(path2.charCodeAt(2))) {
                            isAbsolute6 = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator2(code1)) {
            rootEnd = 1;
            isAbsolute6 = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path2.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute6;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString2(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator2);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize6(path2) {
    assertPath2(path2);
    const len = path2.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute6 = false;
    const code1 = path2.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator2(code1)) {
            isAbsolute6 = true;
            if (isPathSeparator2(path2.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator2(path2.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path2.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator2(path2.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator2(path2.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path2.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path2.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot2(code1)) {
            if (path2.charCodeAt(1) === 58) {
                device = path2.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator2(path2.charCodeAt(2))) {
                        isAbsolute6 = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator2(code1)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString2(path2.slice(rootEnd), !isAbsolute6, "\\", isPathSeparator2);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute6) tail = ".";
    if (tail.length > 0 && isPathSeparator2(path2.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute6) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute6) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute6(path2) {
    assertPath2(path2);
    const len = path2.length;
    if (len === 0) return false;
    const code1 = path2.charCodeAt(0);
    if (isPathSeparator2(code1)) {
        return true;
    } else if (isWindowsDeviceRoot2(code1)) {
        if (len > 2 && path2.charCodeAt(1) === 58) {
            if (isPathSeparator2(path2.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join6(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i4 = 0; i4 < pathsCount; ++i4){
        const path2 = paths[i4];
        assertPath2(path2);
        if (path2.length > 0) {
            if (joined === undefined) joined = firstPart = path2;
            else joined += `\\${path2}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert3(firstPart != null);
    if (isPathSeparator2(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator2(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator2(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator2(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize6(joined);
}
function relative6(from2, to) {
    assertPath2(from2);
    assertPath2(to);
    if (from2 === to) return "";
    const fromOrig = resolve7(from2);
    const toOrig = resolve7(to);
    if (fromOrig === toOrig) return "";
    from2 = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from2 === to) return "";
    let fromStart = 0;
    let fromEnd = from2.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from2.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from2.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i4 = 0;
    for(; i4 <= length; ++i4){
        if (i4 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i4) === 92) {
                    return toOrig.slice(toStart + i4 + 1);
                } else if (i4 === 2) {
                    return toOrig.slice(toStart + i4);
                }
            }
            if (fromLen > length) {
                if (from2.charCodeAt(fromStart + i4) === 92) {
                    lastCommonSep = i4;
                } else if (i4 === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from2.charCodeAt(fromStart + i4);
        const toCode = to.charCodeAt(toStart + i4);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i4;
    }
    if (i4 !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i4 = fromStart + lastCommonSep + 1; i4 <= fromEnd; ++i4){
        if (i4 === fromEnd || from2.charCodeAt(i4) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath6(path2) {
    if (typeof path2 !== "string") return path2;
    if (path2.length === 0) return "";
    const resolvedPath = resolve7(path2);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code1 = resolvedPath.charCodeAt(2);
                if (code1 !== 63 && code1 !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot2(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path2;
}
function dirname6(path2) {
    assertPath2(path2);
    const len = path2.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code1 = path2.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator2(code1)) {
            rootEnd = offset = 1;
            if (isPathSeparator2(path2.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator2(path2.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator2(path2.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator2(path2.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path2;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot2(code1)) {
            if (path2.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator2(path2.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator2(code1)) {
        return path2;
    }
    for(let i4 = len - 1; i4 >= offset; --i4){
        if (isPathSeparator2(path2.charCodeAt(i4))) {
            if (!matchedSlash) {
                end = i4;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path2.slice(0, end);
}
function basename6(path2, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath2(path2);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i4;
    if (path2.length >= 2) {
        const drive = path2.charCodeAt(0);
        if (isWindowsDeviceRoot2(drive)) {
            if (path2.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path2.length) {
        if (ext.length === path2.length && ext === path2) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i4 = path2.length - 1; i4 >= start; --i4){
            const code1 = path2.charCodeAt(i4);
            if (isPathSeparator2(code1)) {
                if (!matchedSlash) {
                    start = i4 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i4 + 1;
                }
                if (extIdx >= 0) {
                    if (code1 === ext.charCodeAt(extIdx)) {
                        if ((--extIdx) === -1) {
                            end = i4;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path2.length;
        return path2.slice(start, end);
    } else {
        for(i4 = path2.length - 1; i4 >= start; --i4){
            if (isPathSeparator2(path2.charCodeAt(i4))) {
                if (!matchedSlash) {
                    start = i4 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i4 + 1;
            }
        }
        if (end === -1) return "";
        return path2.slice(start, end);
    }
}
function extname6(path2) {
    assertPath2(path2);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path2.length >= 2 && path2.charCodeAt(1) === 58 && isWindowsDeviceRoot2(path2.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i4 = path2.length - 1; i4 >= start; --i4){
        const code1 = path2.charCodeAt(i4);
        if (isPathSeparator2(code1)) {
            if (!matchedSlash) {
                startPart = i4 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i4 + 1;
        }
        if (code1 === 46) {
            if (startDot === -1) startDot = i4;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path2.slice(startDot, end);
}
function format6(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format2("\\", pathObject);
}
function parse7(path2) {
    assertPath2(path2);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path2.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code1 = path2.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator2(code1)) {
            rootEnd = 1;
            if (isPathSeparator2(path2.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator2(path2.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator2(path2.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator2(path2.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot2(code1)) {
            if (path2.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator2(path2.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path2;
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path2;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator2(code1)) {
        ret.root = ret.dir = path2;
        return ret;
    }
    if (rootEnd > 0) ret.root = path2.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i4 = path2.length - 1;
    let preDotState = 0;
    for(; i4 >= rootEnd; --i4){
        code1 = path2.charCodeAt(i4);
        if (isPathSeparator2(code1)) {
            if (!matchedSlash) {
                startPart = i4 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i4 + 1;
        }
        if (code1 === 46) {
            if (startDot === -1) startDot = i4;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path2.slice(startPart, end);
        }
    } else {
        ret.name = path2.slice(startPart, startDot);
        ret.base = path2.slice(startPart, end);
        ret.ext = path2.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path2.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl6(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path2 = decodeURIComponent(url.pathname.replace(/^\/*([A-Za-z]:)(\/|$)/, "$1/").replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
    if (url.hostname != "") {
        path2 = `\\\\${url.hostname}${path2}`;
    }
    return path2;
}
const mod4 = function() {
    return {
        sep: sep6,
        delimiter: delimiter6,
        resolve: resolve7,
        normalize: normalize6,
        isAbsolute: isAbsolute6,
        join: join6,
        relative: relative6,
        toNamespacedPath: toNamespacedPath6,
        dirname: dirname6,
        basename: basename6,
        extname: extname6,
        format: format6,
        parse: parse7,
        fromFileUrl: fromFileUrl6
    };
}();
const sep7 = "/";
const delimiter7 = ":";
function resolve8(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i4 = pathSegments.length - 1; i4 >= -1 && !resolvedAbsolute; i4--){
        let path2;
        if (i4 >= 0) path2 = pathSegments[i4];
        else {
            if (globalThis.Deno == null) {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path2 = Deno.cwd();
        }
        assertPath2(path2);
        if (path2.length === 0) {
            continue;
        }
        resolvedPath = `${path2}/${resolvedPath}`;
        resolvedAbsolute = path2.charCodeAt(0) === CHAR_FORWARD_SLASH2;
    }
    resolvedPath = normalizeString2(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator2);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize7(path2) {
    assertPath2(path2);
    if (path2.length === 0) return ".";
    const isAbsolute7 = path2.charCodeAt(0) === 47;
    const trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
    path2 = normalizeString2(path2, !isAbsolute7, "/", isPosixPathSeparator2);
    if (path2.length === 0 && !isAbsolute7) path2 = ".";
    if (path2.length > 0 && trailingSeparator) path2 += "/";
    if (isAbsolute7) return `/${path2}`;
    return path2;
}
function isAbsolute7(path2) {
    assertPath2(path2);
    return path2.length > 0 && path2.charCodeAt(0) === 47;
}
function join7(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i4 = 0, len = paths.length; i4 < len; ++i4){
        const path2 = paths[i4];
        assertPath2(path2);
        if (path2.length > 0) {
            if (!joined) joined = path2;
            else joined += `/${path2}`;
        }
    }
    if (!joined) return ".";
    return normalize7(joined);
}
function relative7(from2, to) {
    assertPath2(from2);
    assertPath2(to);
    if (from2 === to) return "";
    from2 = resolve8(from2);
    to = resolve8(to);
    if (from2 === to) return "";
    let fromStart = 1;
    const fromEnd = from2.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from2.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i4 = 0;
    for(; i4 <= length; ++i4){
        if (i4 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i4) === 47) {
                    return to.slice(toStart + i4 + 1);
                } else if (i4 === 0) {
                    return to.slice(toStart + i4);
                }
            } else if (fromLen > length) {
                if (from2.charCodeAt(fromStart + i4) === 47) {
                    lastCommonSep = i4;
                } else if (i4 === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from2.charCodeAt(fromStart + i4);
        const toCode = to.charCodeAt(toStart + i4);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i4;
    }
    let out = "";
    for(i4 = fromStart + lastCommonSep + 1; i4 <= fromEnd; ++i4){
        if (i4 === fromEnd || from2.charCodeAt(i4) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath7(path2) {
    return path2;
}
function dirname7(path2) {
    assertPath2(path2);
    if (path2.length === 0) return ".";
    const hasRoot = path2.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i4 = path2.length - 1; i4 >= 1; --i4){
        if (path2.charCodeAt(i4) === 47) {
            if (!matchedSlash) {
                end = i4;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path2.slice(0, end);
}
function basename7(path2, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath2(path2);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i4;
    if (ext !== undefined && ext.length > 0 && ext.length <= path2.length) {
        if (ext.length === path2.length && ext === path2) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i4 = path2.length - 1; i4 >= 0; --i4){
            const code1 = path2.charCodeAt(i4);
            if (code1 === 47) {
                if (!matchedSlash) {
                    start = i4 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i4 + 1;
                }
                if (extIdx >= 0) {
                    if (code1 === ext.charCodeAt(extIdx)) {
                        if ((--extIdx) === -1) {
                            end = i4;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path2.length;
        return path2.slice(start, end);
    } else {
        for(i4 = path2.length - 1; i4 >= 0; --i4){
            if (path2.charCodeAt(i4) === 47) {
                if (!matchedSlash) {
                    start = i4 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i4 + 1;
            }
        }
        if (end === -1) return "";
        return path2.slice(start, end);
    }
}
function extname7(path2) {
    assertPath2(path2);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i4 = path2.length - 1; i4 >= 0; --i4){
        const code1 = path2.charCodeAt(i4);
        if (code1 === 47) {
            if (!matchedSlash) {
                startPart = i4 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i4 + 1;
        }
        if (code1 === 46) {
            if (startDot === -1) startDot = i4;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path2.slice(startDot, end);
}
function format7(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format2("/", pathObject);
}
function parse8(path2) {
    assertPath2(path2);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path2.length === 0) return ret;
    const isAbsolute8 = path2.charCodeAt(0) === 47;
    let start;
    if (isAbsolute8) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i4 = path2.length - 1;
    let preDotState = 0;
    for(; i4 >= start; --i4){
        const code1 = path2.charCodeAt(i4);
        if (code1 === 47) {
            if (!matchedSlash) {
                startPart = i4 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i4 + 1;
        }
        if (code1 === 46) {
            if (startDot === -1) startDot = i4;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute8) {
                ret.base = ret.name = path2.slice(1, end);
            } else {
                ret.base = ret.name = path2.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute8) {
            ret.name = path2.slice(1, startDot);
            ret.base = path2.slice(1, end);
        } else {
            ret.name = path2.slice(startPart, startDot);
            ret.base = path2.slice(startPart, end);
        }
        ret.ext = path2.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path2.slice(0, startPart - 1);
    else if (isAbsolute8) ret.dir = "/";
    return ret;
}
function fromFileUrl7(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
const mod5 = function() {
    return {
        sep: sep7,
        delimiter: delimiter7,
        resolve: resolve8,
        normalize: normalize7,
        isAbsolute: isAbsolute7,
        join: join7,
        relative: relative7,
        toNamespacedPath: toNamespacedPath7,
        dirname: dirname7,
        basename: basename7,
        extname: extname7,
        format: format7,
        parse: parse8,
        fromFileUrl: fromFileUrl7
    };
}();
const path2 = isWindows2 ? mod4 : mod5;
const { basename: basename8 , delimiter: delimiter8 , dirname: dirname8 , extname: extname8 , format: format8 , fromFileUrl: fromFileUrl8 , isAbsolute: isAbsolute8 , join: join8 , normalize: normalize8 , parse: parse9 , relative: relative8 , resolve: resolve9 , sep: sep8 , toNamespacedPath: toNamespacedPath8 ,  } = path2;
const extensions1 = new Map();
const types1 = new Map();
function populateMaps1(extensions2, types2) {
    const preference = [
        "nginx",
        "apache",
        undefined,
        "iana"
    ];
    for (const type of Object.keys(db1)){
        const mime = db1[type];
        const exts = mime.extensions;
        if (!exts || !exts.length) {
            continue;
        }
        extensions2.set(type, exts);
        for (const ext of exts){
            const current = types2.get(ext);
            if (current) {
                const from2 = preference.indexOf(db1[current].source);
                const to = preference.indexOf(mime.source);
                if (current !== "application/octet-stream" && (from2 > to || from2 === to && current.substr(0, 12) === "application/")) {
                    continue;
                }
            }
            types2.set(ext, type);
        }
    }
}
populateMaps1(extensions1, types1);
function lookup1(path3) {
    const extension = extname8("x." + path3).toLowerCase().substr(1);
    return types1.get(extension);
}
class Accepts {
    constructor(headers1){
        this.headers = headers1;
        this.negotiator = new Negotiator(headers1);
    }
    types(types) {
        if (!types || types.length === 0) {
            return this.negotiator.mediaTypes();
        }
        if (!this.headers.get("accept")) {
            return types[0];
        }
        const mimes = types.map(extToMime);
        const accepts = this.negotiator.mediaTypes(mimes.filter((t)=>t && validMime(t)
        ));
        const first = accepts[0];
        return first ? types[mimes.indexOf(first)] : false;
    }
    encodings(encodings) {
        if (!encodings || encodings.length === 0) {
            return this.negotiator.encodings();
        }
        return this.negotiator.encodings(encodings)[0] || false;
    }
    charsets(charsets) {
        if (!charsets || charsets.length === 0) {
            return this.negotiator.charsets();
        }
        return this.negotiator.charsets(charsets)[0] || false;
    }
    languages(languages) {
        if (!languages || languages.length === 0) {
            return this.negotiator.languages();
        }
        return this.negotiator.languages(languages)[0] || false;
    }
}
function extToMime(type) {
    return type.indexOf("/") === -1 ? lookup1(type) : type;
}
function validMime(type) {
    return typeof type === "string";
}
const db2 = JSON.parse(`{\n  "application/1d-interleaved-parityfec": {\n    "source": "iana"\n  },\n  "application/3gpdash-qoe-report+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/3gpp-ims+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/a2l": {\n    "source": "iana"\n  },\n  "application/activemessage": {\n    "source": "iana"\n  },\n  "application/activity+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-costmap+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-costmapfilter+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-directory+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-endpointcost+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-endpointcostparams+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-endpointprop+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-endpointpropparams+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-error+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-networkmap+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-networkmapfilter+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-updatestreamcontrol+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/alto-updatestreamparams+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/aml": {\n    "source": "iana"\n  },\n  "application/andrew-inset": {\n    "source": "iana",\n    "extensions": ["ez"]\n  },\n  "application/applefile": {\n    "source": "iana"\n  },\n  "application/applixware": {\n    "source": "apache",\n    "extensions": ["aw"]\n  },\n  "application/atf": {\n    "source": "iana"\n  },\n  "application/atfx": {\n    "source": "iana"\n  },\n  "application/atom+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["atom"]\n  },\n  "application/atomcat+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["atomcat"]\n  },\n  "application/atomdeleted+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["atomdeleted"]\n  },\n  "application/atomicmail": {\n    "source": "iana"\n  },\n  "application/atomsvc+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["atomsvc"]\n  },\n  "application/atsc-dwd+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["dwd"]\n  },\n  "application/atsc-dynamic-event-message": {\n    "source": "iana"\n  },\n  "application/atsc-held+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["held"]\n  },\n  "application/atsc-rdt+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/atsc-rsat+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rsat"]\n  },\n  "application/atxml": {\n    "source": "iana"\n  },\n  "application/auth-policy+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/bacnet-xdd+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/batch-smtp": {\n    "source": "iana"\n  },\n  "application/bdoc": {\n    "compressible": false,\n    "extensions": ["bdoc"]\n  },\n  "application/beep+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/calendar+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/calendar+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xcs"]\n  },\n  "application/call-completion": {\n    "source": "iana"\n  },\n  "application/cals-1840": {\n    "source": "iana"\n  },\n  "application/captive+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/cbor": {\n    "source": "iana"\n  },\n  "application/cbor-seq": {\n    "source": "iana"\n  },\n  "application/cccex": {\n    "source": "iana"\n  },\n  "application/ccmp+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/ccxml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ccxml"]\n  },\n  "application/cdfx+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["cdfx"]\n  },\n  "application/cdmi-capability": {\n    "source": "iana",\n    "extensions": ["cdmia"]\n  },\n  "application/cdmi-container": {\n    "source": "iana",\n    "extensions": ["cdmic"]\n  },\n  "application/cdmi-domain": {\n    "source": "iana",\n    "extensions": ["cdmid"]\n  },\n  "application/cdmi-object": {\n    "source": "iana",\n    "extensions": ["cdmio"]\n  },\n  "application/cdmi-queue": {\n    "source": "iana",\n    "extensions": ["cdmiq"]\n  },\n  "application/cdni": {\n    "source": "iana"\n  },\n  "application/cea": {\n    "source": "iana"\n  },\n  "application/cea-2018+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/cellml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/cfw": {\n    "source": "iana"\n  },\n  "application/clr": {\n    "source": "iana"\n  },\n  "application/clue+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/clue_info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/cms": {\n    "source": "iana"\n  },\n  "application/cnrp+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/coap-group+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/coap-payload": {\n    "source": "iana"\n  },\n  "application/commonground": {\n    "source": "iana"\n  },\n  "application/conference-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/cose": {\n    "source": "iana"\n  },\n  "application/cose-key": {\n    "source": "iana"\n  },\n  "application/cose-key-set": {\n    "source": "iana"\n  },\n  "application/cpl+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/csrattrs": {\n    "source": "iana"\n  },\n  "application/csta+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/cstadata+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/csvm+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/cu-seeme": {\n    "source": "apache",\n    "extensions": ["cu"]\n  },\n  "application/cwt": {\n    "source": "iana"\n  },\n  "application/cybercash": {\n    "source": "iana"\n  },\n  "application/dart": {\n    "compressible": true\n  },\n  "application/dash+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mpd"]\n  },\n  "application/dashdelta": {\n    "source": "iana"\n  },\n  "application/davmount+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["davmount"]\n  },\n  "application/dca-rft": {\n    "source": "iana"\n  },\n  "application/dcd": {\n    "source": "iana"\n  },\n  "application/dec-dx": {\n    "source": "iana"\n  },\n  "application/dialog-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/dicom": {\n    "source": "iana"\n  },\n  "application/dicom+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/dicom+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/dii": {\n    "source": "iana"\n  },\n  "application/dit": {\n    "source": "iana"\n  },\n  "application/dns": {\n    "source": "iana"\n  },\n  "application/dns+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/dns-message": {\n    "source": "iana"\n  },\n  "application/docbook+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["dbk"]\n  },\n  "application/dots+cbor": {\n    "source": "iana"\n  },\n  "application/dskpp+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/dssc+der": {\n    "source": "iana",\n    "extensions": ["dssc"]\n  },\n  "application/dssc+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xdssc"]\n  },\n  "application/dvcs": {\n    "source": "iana"\n  },\n  "application/ecmascript": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ecma","es"]\n  },\n  "application/edi-consent": {\n    "source": "iana"\n  },\n  "application/edi-x12": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/edifact": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/efi": {\n    "source": "iana"\n  },\n  "application/elm+json": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/elm+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emergencycalldata.cap+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/emergencycalldata.comment+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emergencycalldata.control+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emergencycalldata.deviceinfo+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emergencycalldata.ecall.msd": {\n    "source": "iana"\n  },\n  "application/emergencycalldata.providerinfo+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emergencycalldata.serviceinfo+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emergencycalldata.subscriberinfo+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emergencycalldata.veds+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/emma+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["emma"]\n  },\n  "application/emotionml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["emotionml"]\n  },\n  "application/encaprtp": {\n    "source": "iana"\n  },\n  "application/epp+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/epub+zip": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["epub"]\n  },\n  "application/eshop": {\n    "source": "iana"\n  },\n  "application/exi": {\n    "source": "iana",\n    "extensions": ["exi"]\n  },\n  "application/expect-ct-report+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/fastinfoset": {\n    "source": "iana"\n  },\n  "application/fastsoap": {\n    "source": "iana"\n  },\n  "application/fdt+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["fdt"]\n  },\n  "application/fhir+json": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/fhir+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/fido.trusted-apps+json": {\n    "compressible": true\n  },\n  "application/fits": {\n    "source": "iana"\n  },\n  "application/flexfec": {\n    "source": "iana"\n  },\n  "application/font-sfnt": {\n    "source": "iana"\n  },\n  "application/font-tdpfr": {\n    "source": "iana",\n    "extensions": ["pfr"]\n  },\n  "application/font-woff": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/framework-attributes+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/geo+json": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["geojson"]\n  },\n  "application/geo+json-seq": {\n    "source": "iana"\n  },\n  "application/geopackage+sqlite3": {\n    "source": "iana"\n  },\n  "application/geoxacml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/gltf-buffer": {\n    "source": "iana"\n  },\n  "application/gml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["gml"]\n  },\n  "application/gpx+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["gpx"]\n  },\n  "application/gxf": {\n    "source": "apache",\n    "extensions": ["gxf"]\n  },\n  "application/gzip": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["gz"]\n  },\n  "application/h224": {\n    "source": "iana"\n  },\n  "application/held+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/hjson": {\n    "extensions": ["hjson"]\n  },\n  "application/http": {\n    "source": "iana"\n  },\n  "application/hyperstudio": {\n    "source": "iana",\n    "extensions": ["stk"]\n  },\n  "application/ibe-key-request+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/ibe-pkg-reply+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/ibe-pp-data": {\n    "source": "iana"\n  },\n  "application/iges": {\n    "source": "iana"\n  },\n  "application/im-iscomposing+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/index": {\n    "source": "iana"\n  },\n  "application/index.cmd": {\n    "source": "iana"\n  },\n  "application/index.obj": {\n    "source": "iana"\n  },\n  "application/index.response": {\n    "source": "iana"\n  },\n  "application/index.vnd": {\n    "source": "iana"\n  },\n  "application/inkml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ink","inkml"]\n  },\n  "application/iotp": {\n    "source": "iana"\n  },\n  "application/ipfix": {\n    "source": "iana",\n    "extensions": ["ipfix"]\n  },\n  "application/ipp": {\n    "source": "iana"\n  },\n  "application/isup": {\n    "source": "iana"\n  },\n  "application/its+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["its"]\n  },\n  "application/java-archive": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["jar","war","ear"]\n  },\n  "application/java-serialized-object": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["ser"]\n  },\n  "application/java-vm": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["class"]\n  },\n  "application/javascript": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["js","mjs"]\n  },\n  "application/jf2feed+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/jose": {\n    "source": "iana"\n  },\n  "application/jose+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/jrd+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/jscalendar+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/json": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["json","map"]\n  },\n  "application/json-patch+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/json-seq": {\n    "source": "iana"\n  },\n  "application/json5": {\n    "extensions": ["json5"]\n  },\n  "application/jsonml+json": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["jsonml"]\n  },\n  "application/jwk+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/jwk-set+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/jwt": {\n    "source": "iana"\n  },\n  "application/kpml-request+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/kpml-response+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/ld+json": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["jsonld"]\n  },\n  "application/lgr+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["lgr"]\n  },\n  "application/link-format": {\n    "source": "iana"\n  },\n  "application/load-control+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/lost+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["lostxml"]\n  },\n  "application/lostsync+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/lpf+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/lxf": {\n    "source": "iana"\n  },\n  "application/mac-binhex40": {\n    "source": "iana",\n    "extensions": ["hqx"]\n  },\n  "application/mac-compactpro": {\n    "source": "apache",\n    "extensions": ["cpt"]\n  },\n  "application/macwriteii": {\n    "source": "iana"\n  },\n  "application/mads+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mads"]\n  },\n  "application/manifest+json": {\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["webmanifest"]\n  },\n  "application/marc": {\n    "source": "iana",\n    "extensions": ["mrc"]\n  },\n  "application/marcxml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mrcx"]\n  },\n  "application/mathematica": {\n    "source": "iana",\n    "extensions": ["ma","nb","mb"]\n  },\n  "application/mathml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mathml"]\n  },\n  "application/mathml-content+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mathml-presentation+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-associated-procedure-description+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-deregister+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-envelope+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-msk+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-msk-response+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-protection-description+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-reception-report+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-register+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-register-response+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-schedule+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbms-user-service-description+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mbox": {\n    "source": "iana",\n    "extensions": ["mbox"]\n  },\n  "application/media-policy-dataset+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/media_control+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/mediaservercontrol+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mscml"]\n  },\n  "application/merge-patch+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/metalink+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["metalink"]\n  },\n  "application/metalink4+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["meta4"]\n  },\n  "application/mets+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mets"]\n  },\n  "application/mf4": {\n    "source": "iana"\n  },\n  "application/mikey": {\n    "source": "iana"\n  },\n  "application/mipc": {\n    "source": "iana"\n  },\n  "application/mmt-aei+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["maei"]\n  },\n  "application/mmt-usd+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["musd"]\n  },\n  "application/mods+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mods"]\n  },\n  "application/moss-keys": {\n    "source": "iana"\n  },\n  "application/moss-signature": {\n    "source": "iana"\n  },\n  "application/mosskey-data": {\n    "source": "iana"\n  },\n  "application/mosskey-request": {\n    "source": "iana"\n  },\n  "application/mp21": {\n    "source": "iana",\n    "extensions": ["m21","mp21"]\n  },\n  "application/mp4": {\n    "source": "iana",\n    "extensions": ["mp4s","m4p"]\n  },\n  "application/mpeg4-generic": {\n    "source": "iana"\n  },\n  "application/mpeg4-iod": {\n    "source": "iana"\n  },\n  "application/mpeg4-iod-xmt": {\n    "source": "iana"\n  },\n  "application/mrb-consumer+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xdf"]\n  },\n  "application/mrb-publish+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xdf"]\n  },\n  "application/msc-ivr+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/msc-mixer+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/msword": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["doc","dot"]\n  },\n  "application/mud+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/multipart-core": {\n    "source": "iana"\n  },\n  "application/mxf": {\n    "source": "iana",\n    "extensions": ["mxf"]\n  },\n  "application/n-quads": {\n    "source": "iana",\n    "extensions": ["nq"]\n  },\n  "application/n-triples": {\n    "source": "iana",\n    "extensions": ["nt"]\n  },\n  "application/nasdata": {\n    "source": "iana"\n  },\n  "application/news-checkgroups": {\n    "source": "iana",\n    "charset": "US-ASCII"\n  },\n  "application/news-groupinfo": {\n    "source": "iana",\n    "charset": "US-ASCII"\n  },\n  "application/news-transmission": {\n    "source": "iana"\n  },\n  "application/nlsml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/node": {\n    "source": "iana",\n    "extensions": ["cjs"]\n  },\n  "application/nss": {\n    "source": "iana"\n  },\n  "application/ocsp-request": {\n    "source": "iana"\n  },\n  "application/ocsp-response": {\n    "source": "iana"\n  },\n  "application/octet-stream": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]\n  },\n  "application/oda": {\n    "source": "iana",\n    "extensions": ["oda"]\n  },\n  "application/odm+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/odx": {\n    "source": "iana"\n  },\n  "application/oebps-package+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["opf"]\n  },\n  "application/ogg": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["ogx"]\n  },\n  "application/omdoc+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["omdoc"]\n  },\n  "application/onenote": {\n    "source": "apache",\n    "extensions": ["onetoc","onetoc2","onetmp","onepkg"]\n  },\n  "application/opc-nodeset+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/oscore": {\n    "source": "iana"\n  },\n  "application/oxps": {\n    "source": "iana",\n    "extensions": ["oxps"]\n  },\n  "application/p2p-overlay+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["relo"]\n  },\n  "application/parityfec": {\n    "source": "iana"\n  },\n  "application/passport": {\n    "source": "iana"\n  },\n  "application/patch-ops-error+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xer"]\n  },\n  "application/pdf": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["pdf"]\n  },\n  "application/pdx": {\n    "source": "iana"\n  },\n  "application/pem-certificate-chain": {\n    "source": "iana"\n  },\n  "application/pgp-encrypted": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["pgp"]\n  },\n  "application/pgp-keys": {\n    "source": "iana"\n  },\n  "application/pgp-signature": {\n    "source": "iana",\n    "extensions": ["asc","sig"]\n  },\n  "application/pics-rules": {\n    "source": "apache",\n    "extensions": ["prf"]\n  },\n  "application/pidf+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/pidf-diff+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/pkcs10": {\n    "source": "iana",\n    "extensions": ["p10"]\n  },\n  "application/pkcs12": {\n    "source": "iana"\n  },\n  "application/pkcs7-mime": {\n    "source": "iana",\n    "extensions": ["p7m","p7c"]\n  },\n  "application/pkcs7-signature": {\n    "source": "iana",\n    "extensions": ["p7s"]\n  },\n  "application/pkcs8": {\n    "source": "iana",\n    "extensions": ["p8"]\n  },\n  "application/pkcs8-encrypted": {\n    "source": "iana"\n  },\n  "application/pkix-attr-cert": {\n    "source": "iana",\n    "extensions": ["ac"]\n  },\n  "application/pkix-cert": {\n    "source": "iana",\n    "extensions": ["cer"]\n  },\n  "application/pkix-crl": {\n    "source": "iana",\n    "extensions": ["crl"]\n  },\n  "application/pkix-pkipath": {\n    "source": "iana",\n    "extensions": ["pkipath"]\n  },\n  "application/pkixcmp": {\n    "source": "iana",\n    "extensions": ["pki"]\n  },\n  "application/pls+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["pls"]\n  },\n  "application/poc-settings+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/postscript": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ai","eps","ps"]\n  },\n  "application/ppsp-tracker+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/problem+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/problem+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/provenance+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["provx"]\n  },\n  "application/prs.alvestrand.titrax-sheet": {\n    "source": "iana"\n  },\n  "application/prs.cww": {\n    "source": "iana",\n    "extensions": ["cww"]\n  },\n  "application/prs.cyn": {\n    "source": "iana",\n    "charset": "7-BIT"\n  },\n  "application/prs.hpub+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/prs.nprend": {\n    "source": "iana"\n  },\n  "application/prs.plucker": {\n    "source": "iana"\n  },\n  "application/prs.rdf-xml-crypt": {\n    "source": "iana"\n  },\n  "application/prs.xsf+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/pskc+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["pskcxml"]\n  },\n  "application/pvd+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/qsig": {\n    "source": "iana"\n  },\n  "application/raml+yaml": {\n    "compressible": true,\n    "extensions": ["raml"]\n  },\n  "application/raptorfec": {\n    "source": "iana"\n  },\n  "application/rdap+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/rdf+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rdf","owl"]\n  },\n  "application/reginfo+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rif"]\n  },\n  "application/relax-ng-compact-syntax": {\n    "source": "iana",\n    "extensions": ["rnc"]\n  },\n  "application/remote-printing": {\n    "source": "iana"\n  },\n  "application/reputon+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/resource-lists+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rl"]\n  },\n  "application/resource-lists-diff+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rld"]\n  },\n  "application/rfc+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/riscos": {\n    "source": "iana"\n  },\n  "application/rlmi+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/rls-services+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rs"]\n  },\n  "application/route-apd+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rapd"]\n  },\n  "application/route-s-tsid+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["sls"]\n  },\n  "application/route-usd+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rusd"]\n  },\n  "application/rpki-ghostbusters": {\n    "source": "iana",\n    "extensions": ["gbr"]\n  },\n  "application/rpki-manifest": {\n    "source": "iana",\n    "extensions": ["mft"]\n  },\n  "application/rpki-publication": {\n    "source": "iana"\n  },\n  "application/rpki-roa": {\n    "source": "iana",\n    "extensions": ["roa"]\n  },\n  "application/rpki-updown": {\n    "source": "iana"\n  },\n  "application/rsd+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["rsd"]\n  },\n  "application/rss+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["rss"]\n  },\n  "application/rtf": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rtf"]\n  },\n  "application/rtploopback": {\n    "source": "iana"\n  },\n  "application/rtx": {\n    "source": "iana"\n  },\n  "application/samlassertion+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/samlmetadata+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/sarif+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/sbe": {\n    "source": "iana"\n  },\n  "application/sbml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["sbml"]\n  },\n  "application/scaip+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/scim+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/scvp-cv-request": {\n    "source": "iana",\n    "extensions": ["scq"]\n  },\n  "application/scvp-cv-response": {\n    "source": "iana",\n    "extensions": ["scs"]\n  },\n  "application/scvp-vp-request": {\n    "source": "iana",\n    "extensions": ["spq"]\n  },\n  "application/scvp-vp-response": {\n    "source": "iana",\n    "extensions": ["spp"]\n  },\n  "application/sdp": {\n    "source": "iana",\n    "extensions": ["sdp"]\n  },\n  "application/secevent+jwt": {\n    "source": "iana"\n  },\n  "application/senml+cbor": {\n    "source": "iana"\n  },\n  "application/senml+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/senml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["senmlx"]\n  },\n  "application/senml-etch+cbor": {\n    "source": "iana"\n  },\n  "application/senml-etch+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/senml-exi": {\n    "source": "iana"\n  },\n  "application/sensml+cbor": {\n    "source": "iana"\n  },\n  "application/sensml+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/sensml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["sensmlx"]\n  },\n  "application/sensml-exi": {\n    "source": "iana"\n  },\n  "application/sep+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/sep-exi": {\n    "source": "iana"\n  },\n  "application/session-info": {\n    "source": "iana"\n  },\n  "application/set-payment": {\n    "source": "iana"\n  },\n  "application/set-payment-initiation": {\n    "source": "iana",\n    "extensions": ["setpay"]\n  },\n  "application/set-registration": {\n    "source": "iana"\n  },\n  "application/set-registration-initiation": {\n    "source": "iana",\n    "extensions": ["setreg"]\n  },\n  "application/sgml": {\n    "source": "iana"\n  },\n  "application/sgml-open-catalog": {\n    "source": "iana"\n  },\n  "application/shf+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["shf"]\n  },\n  "application/sieve": {\n    "source": "iana",\n    "extensions": ["siv","sieve"]\n  },\n  "application/simple-filter+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/simple-message-summary": {\n    "source": "iana"\n  },\n  "application/simplesymbolcontainer": {\n    "source": "iana"\n  },\n  "application/sipc": {\n    "source": "iana"\n  },\n  "application/slate": {\n    "source": "iana"\n  },\n  "application/smil": {\n    "source": "iana"\n  },\n  "application/smil+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["smi","smil"]\n  },\n  "application/smpte336m": {\n    "source": "iana"\n  },\n  "application/soap+fastinfoset": {\n    "source": "iana"\n  },\n  "application/soap+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/sparql-query": {\n    "source": "iana",\n    "extensions": ["rq"]\n  },\n  "application/sparql-results+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["srx"]\n  },\n  "application/spirits-event+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/sql": {\n    "source": "iana"\n  },\n  "application/srgs": {\n    "source": "iana",\n    "extensions": ["gram"]\n  },\n  "application/srgs+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["grxml"]\n  },\n  "application/sru+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["sru"]\n  },\n  "application/ssdl+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["ssdl"]\n  },\n  "application/ssml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ssml"]\n  },\n  "application/stix+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/swid+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["swidtag"]\n  },\n  "application/tamp-apex-update": {\n    "source": "iana"\n  },\n  "application/tamp-apex-update-confirm": {\n    "source": "iana"\n  },\n  "application/tamp-community-update": {\n    "source": "iana"\n  },\n  "application/tamp-community-update-confirm": {\n    "source": "iana"\n  },\n  "application/tamp-error": {\n    "source": "iana"\n  },\n  "application/tamp-sequence-adjust": {\n    "source": "iana"\n  },\n  "application/tamp-sequence-adjust-confirm": {\n    "source": "iana"\n  },\n  "application/tamp-status-query": {\n    "source": "iana"\n  },\n  "application/tamp-status-response": {\n    "source": "iana"\n  },\n  "application/tamp-update": {\n    "source": "iana"\n  },\n  "application/tamp-update-confirm": {\n    "source": "iana"\n  },\n  "application/tar": {\n    "compressible": true\n  },\n  "application/taxii+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/td+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/tei+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["tei","teicorpus"]\n  },\n  "application/tetra_isi": {\n    "source": "iana"\n  },\n  "application/thraud+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["tfi"]\n  },\n  "application/timestamp-query": {\n    "source": "iana"\n  },\n  "application/timestamp-reply": {\n    "source": "iana"\n  },\n  "application/timestamped-data": {\n    "source": "iana",\n    "extensions": ["tsd"]\n  },\n  "application/tlsrpt+gzip": {\n    "source": "iana"\n  },\n  "application/tlsrpt+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/tnauthlist": {\n    "source": "iana"\n  },\n  "application/toml": {\n    "compressible": true,\n    "extensions": ["toml"]\n  },\n  "application/trickle-ice-sdpfrag": {\n    "source": "iana"\n  },\n  "application/trig": {\n    "source": "iana"\n  },\n  "application/ttml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ttml"]\n  },\n  "application/tve-trigger": {\n    "source": "iana"\n  },\n  "application/tzif": {\n    "source": "iana"\n  },\n  "application/tzif-leap": {\n    "source": "iana"\n  },\n  "application/ubjson": {\n    "compressible": false,\n    "extensions": ["ubj"]\n  },\n  "application/ulpfec": {\n    "source": "iana"\n  },\n  "application/urc-grpsheet+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/urc-ressheet+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rsheet"]\n  },\n  "application/urc-targetdesc+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["td"]\n  },\n  "application/urc-uisocketdesc+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vcard+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vcard+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vemmi": {\n    "source": "iana"\n  },\n  "application/vividence.scriptfile": {\n    "source": "apache"\n  },\n  "application/vnd.1000minds.decision-model+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["1km"]\n  },\n  "application/vnd.3gpp-prose+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp-prose-pc3ch+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp-v2x-local-service-information": {\n    "source": "iana"\n  },\n  "application/vnd.3gpp.access-transfer-events+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.bsf+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.gmop+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.interworking-data": {\n    "source": "iana"\n  },\n  "application/vnd.3gpp.mc-signalling-ear": {\n    "source": "iana"\n  },\n  "application/vnd.3gpp.mcdata-affiliation-command+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcdata-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcdata-payload": {\n    "source": "iana"\n  },\n  "application/vnd.3gpp.mcdata-service-config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcdata-signalling": {\n    "source": "iana"\n  },\n  "application/vnd.3gpp.mcdata-ue-config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcdata-user-profile+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-affiliation-command+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-floor-request+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-location-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-service-config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-signed+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-ue-config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-ue-init-config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcptt-user-profile+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-affiliation-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-location-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-service-config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-transmission-request+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-ue-config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mcvideo-user-profile+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.mid-call+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.pic-bw-large": {\n    "source": "iana",\n    "extensions": ["plb"]\n  },\n  "application/vnd.3gpp.pic-bw-small": {\n    "source": "iana",\n    "extensions": ["psb"]\n  },\n  "application/vnd.3gpp.pic-bw-var": {\n    "source": "iana",\n    "extensions": ["pvb"]\n  },\n  "application/vnd.3gpp.sms": {\n    "source": "iana"\n  },\n  "application/vnd.3gpp.sms+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.srvcc-ext+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.srvcc-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.state-and-event-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp.ussd+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp2.bcmcsinfo+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.3gpp2.sms": {\n    "source": "iana"\n  },\n  "application/vnd.3gpp2.tcap": {\n    "source": "iana",\n    "extensions": ["tcap"]\n  },\n  "application/vnd.3lightssoftware.imagescal": {\n    "source": "iana"\n  },\n  "application/vnd.3m.post-it-notes": {\n    "source": "iana",\n    "extensions": ["pwn"]\n  },\n  "application/vnd.accpac.simply.aso": {\n    "source": "iana",\n    "extensions": ["aso"]\n  },\n  "application/vnd.accpac.simply.imp": {\n    "source": "iana",\n    "extensions": ["imp"]\n  },\n  "application/vnd.acucobol": {\n    "source": "iana",\n    "extensions": ["acu"]\n  },\n  "application/vnd.acucorp": {\n    "source": "iana",\n    "extensions": ["atc","acutc"]\n  },\n  "application/vnd.adobe.air-application-installer-package+zip": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["air"]\n  },\n  "application/vnd.adobe.flash.movie": {\n    "source": "iana"\n  },\n  "application/vnd.adobe.formscentral.fcdt": {\n    "source": "iana",\n    "extensions": ["fcdt"]\n  },\n  "application/vnd.adobe.fxp": {\n    "source": "iana",\n    "extensions": ["fxp","fxpl"]\n  },\n  "application/vnd.adobe.partial-upload": {\n    "source": "iana"\n  },\n  "application/vnd.adobe.xdp+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xdp"]\n  },\n  "application/vnd.adobe.xfdf": {\n    "source": "iana",\n    "extensions": ["xfdf"]\n  },\n  "application/vnd.aether.imp": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.afplinedata": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.afplinedata-pagedef": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.cmoca-cmresource": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.foca-charset": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.foca-codedfont": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.foca-codepage": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.modca": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.modca-cmtable": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.modca-formdef": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.modca-mediummap": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.modca-objectcontainer": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.modca-overlay": {\n    "source": "iana"\n  },\n  "application/vnd.afpc.modca-pagesegment": {\n    "source": "iana"\n  },\n  "application/vnd.ah-barcode": {\n    "source": "iana"\n  },\n  "application/vnd.ahead.space": {\n    "source": "iana",\n    "extensions": ["ahead"]\n  },\n  "application/vnd.airzip.filesecure.azf": {\n    "source": "iana",\n    "extensions": ["azf"]\n  },\n  "application/vnd.airzip.filesecure.azs": {\n    "source": "iana",\n    "extensions": ["azs"]\n  },\n  "application/vnd.amadeus+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.amazon.ebook": {\n    "source": "apache",\n    "extensions": ["azw"]\n  },\n  "application/vnd.amazon.mobi8-ebook": {\n    "source": "iana"\n  },\n  "application/vnd.americandynamics.acc": {\n    "source": "iana",\n    "extensions": ["acc"]\n  },\n  "application/vnd.amiga.ami": {\n    "source": "iana",\n    "extensions": ["ami"]\n  },\n  "application/vnd.amundsen.maze+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.android.ota": {\n    "source": "iana"\n  },\n  "application/vnd.android.package-archive": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["apk"]\n  },\n  "application/vnd.anki": {\n    "source": "iana"\n  },\n  "application/vnd.anser-web-certificate-issue-initiation": {\n    "source": "iana",\n    "extensions": ["cii"]\n  },\n  "application/vnd.anser-web-funds-transfer-initiation": {\n    "source": "apache",\n    "extensions": ["fti"]\n  },\n  "application/vnd.antix.game-component": {\n    "source": "iana",\n    "extensions": ["atx"]\n  },\n  "application/vnd.apache.thrift.binary": {\n    "source": "iana"\n  },\n  "application/vnd.apache.thrift.compact": {\n    "source": "iana"\n  },\n  "application/vnd.apache.thrift.json": {\n    "source": "iana"\n  },\n  "application/vnd.api+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.aplextor.warrp+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.apothekende.reservation+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.apple.installer+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mpkg"]\n  },\n  "application/vnd.apple.keynote": {\n    "source": "iana",\n    "extensions": ["key"]\n  },\n  "application/vnd.apple.mpegurl": {\n    "source": "iana",\n    "extensions": ["m3u8"]\n  },\n  "application/vnd.apple.numbers": {\n    "source": "iana",\n    "extensions": ["numbers"]\n  },\n  "application/vnd.apple.pages": {\n    "source": "iana",\n    "extensions": ["pages"]\n  },\n  "application/vnd.apple.pkpass": {\n    "compressible": false,\n    "extensions": ["pkpass"]\n  },\n  "application/vnd.arastra.swi": {\n    "source": "iana"\n  },\n  "application/vnd.aristanetworks.swi": {\n    "source": "iana",\n    "extensions": ["swi"]\n  },\n  "application/vnd.artisan+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.artsquare": {\n    "source": "iana"\n  },\n  "application/vnd.astraea-software.iota": {\n    "source": "iana",\n    "extensions": ["iota"]\n  },\n  "application/vnd.audiograph": {\n    "source": "iana",\n    "extensions": ["aep"]\n  },\n  "application/vnd.autopackage": {\n    "source": "iana"\n  },\n  "application/vnd.avalon+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.avistar+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.balsamiq.bmml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["bmml"]\n  },\n  "application/vnd.balsamiq.bmpr": {\n    "source": "iana"\n  },\n  "application/vnd.banana-accounting": {\n    "source": "iana"\n  },\n  "application/vnd.bbf.usp.error": {\n    "source": "iana"\n  },\n  "application/vnd.bbf.usp.msg": {\n    "source": "iana"\n  },\n  "application/vnd.bbf.usp.msg+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.bekitzur-stech+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.bint.med-content": {\n    "source": "iana"\n  },\n  "application/vnd.biopax.rdf+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.blink-idb-value-wrapper": {\n    "source": "iana"\n  },\n  "application/vnd.blueice.multipass": {\n    "source": "iana",\n    "extensions": ["mpm"]\n  },\n  "application/vnd.bluetooth.ep.oob": {\n    "source": "iana"\n  },\n  "application/vnd.bluetooth.le.oob": {\n    "source": "iana"\n  },\n  "application/vnd.bmi": {\n    "source": "iana",\n    "extensions": ["bmi"]\n  },\n  "application/vnd.bpf": {\n    "source": "iana"\n  },\n  "application/vnd.bpf3": {\n    "source": "iana"\n  },\n  "application/vnd.businessobjects": {\n    "source": "iana",\n    "extensions": ["rep"]\n  },\n  "application/vnd.byu.uapi+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.cab-jscript": {\n    "source": "iana"\n  },\n  "application/vnd.canon-cpdl": {\n    "source": "iana"\n  },\n  "application/vnd.canon-lips": {\n    "source": "iana"\n  },\n  "application/vnd.capasystems-pg+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.cendio.thinlinc.clientconf": {\n    "source": "iana"\n  },\n  "application/vnd.century-systems.tcp_stream": {\n    "source": "iana"\n  },\n  "application/vnd.chemdraw+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["cdxml"]\n  },\n  "application/vnd.chess-pgn": {\n    "source": "iana"\n  },\n  "application/vnd.chipnuts.karaoke-mmd": {\n    "source": "iana",\n    "extensions": ["mmd"]\n  },\n  "application/vnd.ciedi": {\n    "source": "iana"\n  },\n  "application/vnd.cinderella": {\n    "source": "iana",\n    "extensions": ["cdy"]\n  },\n  "application/vnd.cirpack.isdn-ext": {\n    "source": "iana"\n  },\n  "application/vnd.citationstyles.style+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["csl"]\n  },\n  "application/vnd.claymore": {\n    "source": "iana",\n    "extensions": ["cla"]\n  },\n  "application/vnd.cloanto.rp9": {\n    "source": "iana",\n    "extensions": ["rp9"]\n  },\n  "application/vnd.clonk.c4group": {\n    "source": "iana",\n    "extensions": ["c4g","c4d","c4f","c4p","c4u"]\n  },\n  "application/vnd.cluetrust.cartomobile-config": {\n    "source": "iana",\n    "extensions": ["c11amc"]\n  },\n  "application/vnd.cluetrust.cartomobile-config-pkg": {\n    "source": "iana",\n    "extensions": ["c11amz"]\n  },\n  "application/vnd.coffeescript": {\n    "source": "iana"\n  },\n  "application/vnd.collabio.xodocuments.document": {\n    "source": "iana"\n  },\n  "application/vnd.collabio.xodocuments.document-template": {\n    "source": "iana"\n  },\n  "application/vnd.collabio.xodocuments.presentation": {\n    "source": "iana"\n  },\n  "application/vnd.collabio.xodocuments.presentation-template": {\n    "source": "iana"\n  },\n  "application/vnd.collabio.xodocuments.spreadsheet": {\n    "source": "iana"\n  },\n  "application/vnd.collabio.xodocuments.spreadsheet-template": {\n    "source": "iana"\n  },\n  "application/vnd.collection+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.collection.doc+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.collection.next+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.comicbook+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.comicbook-rar": {\n    "source": "iana"\n  },\n  "application/vnd.commerce-battelle": {\n    "source": "iana"\n  },\n  "application/vnd.commonspace": {\n    "source": "iana",\n    "extensions": ["csp"]\n  },\n  "application/vnd.contact.cmsg": {\n    "source": "iana",\n    "extensions": ["cdbcmsg"]\n  },\n  "application/vnd.coreos.ignition+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.cosmocaller": {\n    "source": "iana",\n    "extensions": ["cmc"]\n  },\n  "application/vnd.crick.clicker": {\n    "source": "iana",\n    "extensions": ["clkx"]\n  },\n  "application/vnd.crick.clicker.keyboard": {\n    "source": "iana",\n    "extensions": ["clkk"]\n  },\n  "application/vnd.crick.clicker.palette": {\n    "source": "iana",\n    "extensions": ["clkp"]\n  },\n  "application/vnd.crick.clicker.template": {\n    "source": "iana",\n    "extensions": ["clkt"]\n  },\n  "application/vnd.crick.clicker.wordbank": {\n    "source": "iana",\n    "extensions": ["clkw"]\n  },\n  "application/vnd.criticaltools.wbs+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["wbs"]\n  },\n  "application/vnd.cryptii.pipe+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.crypto-shade-file": {\n    "source": "iana"\n  },\n  "application/vnd.ctc-posml": {\n    "source": "iana",\n    "extensions": ["pml"]\n  },\n  "application/vnd.ctct.ws+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.cups-pdf": {\n    "source": "iana"\n  },\n  "application/vnd.cups-postscript": {\n    "source": "iana"\n  },\n  "application/vnd.cups-ppd": {\n    "source": "iana",\n    "extensions": ["ppd"]\n  },\n  "application/vnd.cups-raster": {\n    "source": "iana"\n  },\n  "application/vnd.cups-raw": {\n    "source": "iana"\n  },\n  "application/vnd.curl": {\n    "source": "iana"\n  },\n  "application/vnd.curl.car": {\n    "source": "apache",\n    "extensions": ["car"]\n  },\n  "application/vnd.curl.pcurl": {\n    "source": "apache",\n    "extensions": ["pcurl"]\n  },\n  "application/vnd.cyan.dean.root+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.cybank": {\n    "source": "iana"\n  },\n  "application/vnd.d2l.coursepackage1p0+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.d3m-dataset": {\n    "source": "iana"\n  },\n  "application/vnd.d3m-problem": {\n    "source": "iana"\n  },\n  "application/vnd.dart": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["dart"]\n  },\n  "application/vnd.data-vision.rdz": {\n    "source": "iana",\n    "extensions": ["rdz"]\n  },\n  "application/vnd.datapackage+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dataresource+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dbf": {\n    "source": "iana",\n    "extensions": ["dbf"]\n  },\n  "application/vnd.debian.binary-package": {\n    "source": "iana"\n  },\n  "application/vnd.dece.data": {\n    "source": "iana",\n    "extensions": ["uvf","uvvf","uvd","uvvd"]\n  },\n  "application/vnd.dece.ttml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["uvt","uvvt"]\n  },\n  "application/vnd.dece.unspecified": {\n    "source": "iana",\n    "extensions": ["uvx","uvvx"]\n  },\n  "application/vnd.dece.zip": {\n    "source": "iana",\n    "extensions": ["uvz","uvvz"]\n  },\n  "application/vnd.denovo.fcselayout-link": {\n    "source": "iana",\n    "extensions": ["fe_launch"]\n  },\n  "application/vnd.desmume.movie": {\n    "source": "iana"\n  },\n  "application/vnd.dir-bi.plate-dl-nosuffix": {\n    "source": "iana"\n  },\n  "application/vnd.dm.delegation+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dna": {\n    "source": "iana",\n    "extensions": ["dna"]\n  },\n  "application/vnd.document+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dolby.mlp": {\n    "source": "apache",\n    "extensions": ["mlp"]\n  },\n  "application/vnd.dolby.mobile.1": {\n    "source": "iana"\n  },\n  "application/vnd.dolby.mobile.2": {\n    "source": "iana"\n  },\n  "application/vnd.doremir.scorecloud-binary-document": {\n    "source": "iana"\n  },\n  "application/vnd.dpgraph": {\n    "source": "iana",\n    "extensions": ["dpg"]\n  },\n  "application/vnd.dreamfactory": {\n    "source": "iana",\n    "extensions": ["dfac"]\n  },\n  "application/vnd.drive+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ds-keypoint": {\n    "source": "apache",\n    "extensions": ["kpxx"]\n  },\n  "application/vnd.dtg.local": {\n    "source": "iana"\n  },\n  "application/vnd.dtg.local.flash": {\n    "source": "iana"\n  },\n  "application/vnd.dtg.local.html": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.ait": {\n    "source": "iana",\n    "extensions": ["ait"]\n  },\n  "application/vnd.dvb.dvbisl+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.dvbj": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.esgcontainer": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.ipdcdftnotifaccess": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.ipdcesgaccess": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.ipdcesgaccess2": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.ipdcesgpdd": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.ipdcroaming": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.iptv.alfec-base": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.iptv.alfec-enhancement": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.notif-aggregate-root+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.notif-container+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.notif-generic+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.notif-ia-msglist+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.notif-ia-registration-request+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.notif-ia-registration-response+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.notif-init+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.dvb.pfr": {\n    "source": "iana"\n  },\n  "application/vnd.dvb.service": {\n    "source": "iana",\n    "extensions": ["svc"]\n  },\n  "application/vnd.dxr": {\n    "source": "iana"\n  },\n  "application/vnd.dynageo": {\n    "source": "iana",\n    "extensions": ["geo"]\n  },\n  "application/vnd.dzr": {\n    "source": "iana"\n  },\n  "application/vnd.easykaraoke.cdgdownload": {\n    "source": "iana"\n  },\n  "application/vnd.ecdis-update": {\n    "source": "iana"\n  },\n  "application/vnd.ecip.rlp": {\n    "source": "iana"\n  },\n  "application/vnd.ecowin.chart": {\n    "source": "iana",\n    "extensions": ["mag"]\n  },\n  "application/vnd.ecowin.filerequest": {\n    "source": "iana"\n  },\n  "application/vnd.ecowin.fileupdate": {\n    "source": "iana"\n  },\n  "application/vnd.ecowin.series": {\n    "source": "iana"\n  },\n  "application/vnd.ecowin.seriesrequest": {\n    "source": "iana"\n  },\n  "application/vnd.ecowin.seriesupdate": {\n    "source": "iana"\n  },\n  "application/vnd.efi.img": {\n    "source": "iana"\n  },\n  "application/vnd.efi.iso": {\n    "source": "iana"\n  },\n  "application/vnd.emclient.accessrequest+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.enliven": {\n    "source": "iana",\n    "extensions": ["nml"]\n  },\n  "application/vnd.enphase.envoy": {\n    "source": "iana"\n  },\n  "application/vnd.eprints.data+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.epson.esf": {\n    "source": "iana",\n    "extensions": ["esf"]\n  },\n  "application/vnd.epson.msf": {\n    "source": "iana",\n    "extensions": ["msf"]\n  },\n  "application/vnd.epson.quickanime": {\n    "source": "iana",\n    "extensions": ["qam"]\n  },\n  "application/vnd.epson.salt": {\n    "source": "iana",\n    "extensions": ["slt"]\n  },\n  "application/vnd.epson.ssf": {\n    "source": "iana",\n    "extensions": ["ssf"]\n  },\n  "application/vnd.ericsson.quickcall": {\n    "source": "iana"\n  },\n  "application/vnd.espass-espass+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.eszigno3+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["es3","et3"]\n  },\n  "application/vnd.etsi.aoc+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.asic-e+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.etsi.asic-s+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.etsi.cug+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvcommand+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvdiscovery+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvprofile+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvsad-bc+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvsad-cod+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvsad-npvr+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvservice+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvsync+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.iptvueprofile+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.mcid+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.mheg5": {\n    "source": "iana"\n  },\n  "application/vnd.etsi.overload-control-policy-dataset+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.pstn+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.sci+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.simservs+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.timestamp-token": {\n    "source": "iana"\n  },\n  "application/vnd.etsi.tsl+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.etsi.tsl.der": {\n    "source": "iana"\n  },\n  "application/vnd.eudora.data": {\n    "source": "iana"\n  },\n  "application/vnd.evolv.ecig.profile": {\n    "source": "iana"\n  },\n  "application/vnd.evolv.ecig.settings": {\n    "source": "iana"\n  },\n  "application/vnd.evolv.ecig.theme": {\n    "source": "iana"\n  },\n  "application/vnd.exstream-empower+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.exstream-package": {\n    "source": "iana"\n  },\n  "application/vnd.ezpix-album": {\n    "source": "iana",\n    "extensions": ["ez2"]\n  },\n  "application/vnd.ezpix-package": {\n    "source": "iana",\n    "extensions": ["ez3"]\n  },\n  "application/vnd.f-secure.mobile": {\n    "source": "iana"\n  },\n  "application/vnd.fastcopy-disk-image": {\n    "source": "iana"\n  },\n  "application/vnd.fdf": {\n    "source": "iana",\n    "extensions": ["fdf"]\n  },\n  "application/vnd.fdsn.mseed": {\n    "source": "iana",\n    "extensions": ["mseed"]\n  },\n  "application/vnd.fdsn.seed": {\n    "source": "iana",\n    "extensions": ["seed","dataless"]\n  },\n  "application/vnd.ffsns": {\n    "source": "iana"\n  },\n  "application/vnd.ficlab.flb+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.filmit.zfc": {\n    "source": "iana"\n  },\n  "application/vnd.fints": {\n    "source": "iana"\n  },\n  "application/vnd.firemonkeys.cloudcell": {\n    "source": "iana"\n  },\n  "application/vnd.flographit": {\n    "source": "iana",\n    "extensions": ["gph"]\n  },\n  "application/vnd.fluxtime.clip": {\n    "source": "iana",\n    "extensions": ["ftc"]\n  },\n  "application/vnd.font-fontforge-sfd": {\n    "source": "iana"\n  },\n  "application/vnd.framemaker": {\n    "source": "iana",\n    "extensions": ["fm","frame","maker","book"]\n  },\n  "application/vnd.frogans.fnc": {\n    "source": "iana",\n    "extensions": ["fnc"]\n  },\n  "application/vnd.frogans.ltf": {\n    "source": "iana",\n    "extensions": ["ltf"]\n  },\n  "application/vnd.fsc.weblaunch": {\n    "source": "iana",\n    "extensions": ["fsc"]\n  },\n  "application/vnd.fujitsu.oasys": {\n    "source": "iana",\n    "extensions": ["oas"]\n  },\n  "application/vnd.fujitsu.oasys2": {\n    "source": "iana",\n    "extensions": ["oa2"]\n  },\n  "application/vnd.fujitsu.oasys3": {\n    "source": "iana",\n    "extensions": ["oa3"]\n  },\n  "application/vnd.fujitsu.oasysgp": {\n    "source": "iana",\n    "extensions": ["fg5"]\n  },\n  "application/vnd.fujitsu.oasysprs": {\n    "source": "iana",\n    "extensions": ["bh2"]\n  },\n  "application/vnd.fujixerox.art-ex": {\n    "source": "iana"\n  },\n  "application/vnd.fujixerox.art4": {\n    "source": "iana"\n  },\n  "application/vnd.fujixerox.ddd": {\n    "source": "iana",\n    "extensions": ["ddd"]\n  },\n  "application/vnd.fujixerox.docuworks": {\n    "source": "iana",\n    "extensions": ["xdw"]\n  },\n  "application/vnd.fujixerox.docuworks.binder": {\n    "source": "iana",\n    "extensions": ["xbd"]\n  },\n  "application/vnd.fujixerox.docuworks.container": {\n    "source": "iana"\n  },\n  "application/vnd.fujixerox.hbpl": {\n    "source": "iana"\n  },\n  "application/vnd.fut-misnet": {\n    "source": "iana"\n  },\n  "application/vnd.futoin+cbor": {\n    "source": "iana"\n  },\n  "application/vnd.futoin+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.fuzzysheet": {\n    "source": "iana",\n    "extensions": ["fzs"]\n  },\n  "application/vnd.genomatix.tuxedo": {\n    "source": "iana",\n    "extensions": ["txd"]\n  },\n  "application/vnd.gentics.grd+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.geo+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.geocube+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.geogebra.file": {\n    "source": "iana",\n    "extensions": ["ggb"]\n  },\n  "application/vnd.geogebra.slides": {\n    "source": "iana"\n  },\n  "application/vnd.geogebra.tool": {\n    "source": "iana",\n    "extensions": ["ggt"]\n  },\n  "application/vnd.geometry-explorer": {\n    "source": "iana",\n    "extensions": ["gex","gre"]\n  },\n  "application/vnd.geonext": {\n    "source": "iana",\n    "extensions": ["gxt"]\n  },\n  "application/vnd.geoplan": {\n    "source": "iana",\n    "extensions": ["g2w"]\n  },\n  "application/vnd.geospace": {\n    "source": "iana",\n    "extensions": ["g3w"]\n  },\n  "application/vnd.gerber": {\n    "source": "iana"\n  },\n  "application/vnd.globalplatform.card-content-mgt": {\n    "source": "iana"\n  },\n  "application/vnd.globalplatform.card-content-mgt-response": {\n    "source": "iana"\n  },\n  "application/vnd.gmx": {\n    "source": "iana",\n    "extensions": ["gmx"]\n  },\n  "application/vnd.google-apps.document": {\n    "compressible": false,\n    "extensions": ["gdoc"]\n  },\n  "application/vnd.google-apps.presentation": {\n    "compressible": false,\n    "extensions": ["gslides"]\n  },\n  "application/vnd.google-apps.spreadsheet": {\n    "compressible": false,\n    "extensions": ["gsheet"]\n  },\n  "application/vnd.google-earth.kml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["kml"]\n  },\n  "application/vnd.google-earth.kmz": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["kmz"]\n  },\n  "application/vnd.gov.sk.e-form+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.gov.sk.e-form+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.gov.sk.xmldatacontainer+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.grafeq": {\n    "source": "iana",\n    "extensions": ["gqf","gqs"]\n  },\n  "application/vnd.gridmp": {\n    "source": "iana"\n  },\n  "application/vnd.groove-account": {\n    "source": "iana",\n    "extensions": ["gac"]\n  },\n  "application/vnd.groove-help": {\n    "source": "iana",\n    "extensions": ["ghf"]\n  },\n  "application/vnd.groove-identity-message": {\n    "source": "iana",\n    "extensions": ["gim"]\n  },\n  "application/vnd.groove-injector": {\n    "source": "iana",\n    "extensions": ["grv"]\n  },\n  "application/vnd.groove-tool-message": {\n    "source": "iana",\n    "extensions": ["gtm"]\n  },\n  "application/vnd.groove-tool-template": {\n    "source": "iana",\n    "extensions": ["tpl"]\n  },\n  "application/vnd.groove-vcard": {\n    "source": "iana",\n    "extensions": ["vcg"]\n  },\n  "application/vnd.hal+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.hal+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["hal"]\n  },\n  "application/vnd.handheld-entertainment+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["zmm"]\n  },\n  "application/vnd.hbci": {\n    "source": "iana",\n    "extensions": ["hbci"]\n  },\n  "application/vnd.hc+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.hcl-bireports": {\n    "source": "iana"\n  },\n  "application/vnd.hdt": {\n    "source": "iana"\n  },\n  "application/vnd.heroku+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.hhe.lesson-player": {\n    "source": "iana",\n    "extensions": ["les"]\n  },\n  "application/vnd.hp-hpgl": {\n    "source": "iana",\n    "extensions": ["hpgl"]\n  },\n  "application/vnd.hp-hpid": {\n    "source": "iana",\n    "extensions": ["hpid"]\n  },\n  "application/vnd.hp-hps": {\n    "source": "iana",\n    "extensions": ["hps"]\n  },\n  "application/vnd.hp-jlyt": {\n    "source": "iana",\n    "extensions": ["jlt"]\n  },\n  "application/vnd.hp-pcl": {\n    "source": "iana",\n    "extensions": ["pcl"]\n  },\n  "application/vnd.hp-pclxl": {\n    "source": "iana",\n    "extensions": ["pclxl"]\n  },\n  "application/vnd.httphone": {\n    "source": "iana"\n  },\n  "application/vnd.hydrostatix.sof-data": {\n    "source": "iana",\n    "extensions": ["sfd-hdstx"]\n  },\n  "application/vnd.hyper+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.hyper-item+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.hyperdrive+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.hzn-3d-crossword": {\n    "source": "iana"\n  },\n  "application/vnd.ibm.afplinedata": {\n    "source": "iana"\n  },\n  "application/vnd.ibm.electronic-media": {\n    "source": "iana"\n  },\n  "application/vnd.ibm.minipay": {\n    "source": "iana",\n    "extensions": ["mpy"]\n  },\n  "application/vnd.ibm.modcap": {\n    "source": "iana",\n    "extensions": ["afp","listafp","list3820"]\n  },\n  "application/vnd.ibm.rights-management": {\n    "source": "iana",\n    "extensions": ["irm"]\n  },\n  "application/vnd.ibm.secure-container": {\n    "source": "iana",\n    "extensions": ["sc"]\n  },\n  "application/vnd.iccprofile": {\n    "source": "iana",\n    "extensions": ["icc","icm"]\n  },\n  "application/vnd.ieee.1905": {\n    "source": "iana"\n  },\n  "application/vnd.igloader": {\n    "source": "iana",\n    "extensions": ["igl"]\n  },\n  "application/vnd.imagemeter.folder+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.imagemeter.image+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.immervision-ivp": {\n    "source": "iana",\n    "extensions": ["ivp"]\n  },\n  "application/vnd.immervision-ivu": {\n    "source": "iana",\n    "extensions": ["ivu"]\n  },\n  "application/vnd.ims.imsccv1p1": {\n    "source": "iana"\n  },\n  "application/vnd.ims.imsccv1p2": {\n    "source": "iana"\n  },\n  "application/vnd.ims.imsccv1p3": {\n    "source": "iana"\n  },\n  "application/vnd.ims.lis.v2.result+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ims.lti.v2.toolproxy+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ims.lti.v2.toolproxy.id+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ims.lti.v2.toolsettings+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ims.lti.v2.toolsettings.simple+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.informedcontrol.rms+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.informix-visionary": {\n    "source": "iana"\n  },\n  "application/vnd.infotech.project": {\n    "source": "iana"\n  },\n  "application/vnd.infotech.project+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.innopath.wamp.notification": {\n    "source": "iana"\n  },\n  "application/vnd.insors.igm": {\n    "source": "iana",\n    "extensions": ["igm"]\n  },\n  "application/vnd.intercon.formnet": {\n    "source": "iana",\n    "extensions": ["xpw","xpx"]\n  },\n  "application/vnd.intergeo": {\n    "source": "iana",\n    "extensions": ["i2g"]\n  },\n  "application/vnd.intertrust.digibox": {\n    "source": "iana"\n  },\n  "application/vnd.intertrust.nncp": {\n    "source": "iana"\n  },\n  "application/vnd.intu.qbo": {\n    "source": "iana",\n    "extensions": ["qbo"]\n  },\n  "application/vnd.intu.qfx": {\n    "source": "iana",\n    "extensions": ["qfx"]\n  },\n  "application/vnd.iptc.g2.catalogitem+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.iptc.g2.conceptitem+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.iptc.g2.knowledgeitem+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.iptc.g2.newsitem+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.iptc.g2.newsmessage+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.iptc.g2.packageitem+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.iptc.g2.planningitem+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ipunplugged.rcprofile": {\n    "source": "iana",\n    "extensions": ["rcprofile"]\n  },\n  "application/vnd.irepository.package+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["irp"]\n  },\n  "application/vnd.is-xpr": {\n    "source": "iana",\n    "extensions": ["xpr"]\n  },\n  "application/vnd.isac.fcs": {\n    "source": "iana",\n    "extensions": ["fcs"]\n  },\n  "application/vnd.iso11783-10+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.jam": {\n    "source": "iana",\n    "extensions": ["jam"]\n  },\n  "application/vnd.japannet-directory-service": {\n    "source": "iana"\n  },\n  "application/vnd.japannet-jpnstore-wakeup": {\n    "source": "iana"\n  },\n  "application/vnd.japannet-payment-wakeup": {\n    "source": "iana"\n  },\n  "application/vnd.japannet-registration": {\n    "source": "iana"\n  },\n  "application/vnd.japannet-registration-wakeup": {\n    "source": "iana"\n  },\n  "application/vnd.japannet-setstore-wakeup": {\n    "source": "iana"\n  },\n  "application/vnd.japannet-verification": {\n    "source": "iana"\n  },\n  "application/vnd.japannet-verification-wakeup": {\n    "source": "iana"\n  },\n  "application/vnd.jcp.javame.midlet-rms": {\n    "source": "iana",\n    "extensions": ["rms"]\n  },\n  "application/vnd.jisp": {\n    "source": "iana",\n    "extensions": ["jisp"]\n  },\n  "application/vnd.joost.joda-archive": {\n    "source": "iana",\n    "extensions": ["joda"]\n  },\n  "application/vnd.jsk.isdn-ngn": {\n    "source": "iana"\n  },\n  "application/vnd.kahootz": {\n    "source": "iana",\n    "extensions": ["ktz","ktr"]\n  },\n  "application/vnd.kde.karbon": {\n    "source": "iana",\n    "extensions": ["karbon"]\n  },\n  "application/vnd.kde.kchart": {\n    "source": "iana",\n    "extensions": ["chrt"]\n  },\n  "application/vnd.kde.kformula": {\n    "source": "iana",\n    "extensions": ["kfo"]\n  },\n  "application/vnd.kde.kivio": {\n    "source": "iana",\n    "extensions": ["flw"]\n  },\n  "application/vnd.kde.kontour": {\n    "source": "iana",\n    "extensions": ["kon"]\n  },\n  "application/vnd.kde.kpresenter": {\n    "source": "iana",\n    "extensions": ["kpr","kpt"]\n  },\n  "application/vnd.kde.kspread": {\n    "source": "iana",\n    "extensions": ["ksp"]\n  },\n  "application/vnd.kde.kword": {\n    "source": "iana",\n    "extensions": ["kwd","kwt"]\n  },\n  "application/vnd.kenameaapp": {\n    "source": "iana",\n    "extensions": ["htke"]\n  },\n  "application/vnd.kidspiration": {\n    "source": "iana",\n    "extensions": ["kia"]\n  },\n  "application/vnd.kinar": {\n    "source": "iana",\n    "extensions": ["kne","knp"]\n  },\n  "application/vnd.koan": {\n    "source": "iana",\n    "extensions": ["skp","skd","skt","skm"]\n  },\n  "application/vnd.kodak-descriptor": {\n    "source": "iana",\n    "extensions": ["sse"]\n  },\n  "application/vnd.las": {\n    "source": "iana"\n  },\n  "application/vnd.las.las+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.las.las+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["lasxml"]\n  },\n  "application/vnd.laszip": {\n    "source": "iana"\n  },\n  "application/vnd.leap+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.liberty-request+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.llamagraphics.life-balance.desktop": {\n    "source": "iana",\n    "extensions": ["lbd"]\n  },\n  "application/vnd.llamagraphics.life-balance.exchange+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["lbe"]\n  },\n  "application/vnd.logipipe.circuit+zip": {\n    "source": "iana",\n    "compressible": false\n  },\n  "application/vnd.loom": {\n    "source": "iana"\n  },\n  "application/vnd.lotus-1-2-3": {\n    "source": "iana",\n    "extensions": ["123"]\n  },\n  "application/vnd.lotus-approach": {\n    "source": "iana",\n    "extensions": ["apr"]\n  },\n  "application/vnd.lotus-freelance": {\n    "source": "iana",\n    "extensions": ["pre"]\n  },\n  "application/vnd.lotus-notes": {\n    "source": "iana",\n    "extensions": ["nsf"]\n  },\n  "application/vnd.lotus-organizer": {\n    "source": "iana",\n    "extensions": ["org"]\n  },\n  "application/vnd.lotus-screencam": {\n    "source": "iana",\n    "extensions": ["scm"]\n  },\n  "application/vnd.lotus-wordpro": {\n    "source": "iana",\n    "extensions": ["lwp"]\n  },\n  "application/vnd.macports.portpkg": {\n    "source": "iana",\n    "extensions": ["portpkg"]\n  },\n  "application/vnd.mapbox-vector-tile": {\n    "source": "iana"\n  },\n  "application/vnd.marlin.drm.actiontoken+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.marlin.drm.conftoken+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.marlin.drm.license+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.marlin.drm.mdcf": {\n    "source": "iana"\n  },\n  "application/vnd.mason+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.maxmind.maxmind-db": {\n    "source": "iana"\n  },\n  "application/vnd.mcd": {\n    "source": "iana",\n    "extensions": ["mcd"]\n  },\n  "application/vnd.medcalcdata": {\n    "source": "iana",\n    "extensions": ["mc1"]\n  },\n  "application/vnd.mediastation.cdkey": {\n    "source": "iana",\n    "extensions": ["cdkey"]\n  },\n  "application/vnd.meridian-slingshot": {\n    "source": "iana"\n  },\n  "application/vnd.mfer": {\n    "source": "iana",\n    "extensions": ["mwf"]\n  },\n  "application/vnd.mfmp": {\n    "source": "iana",\n    "extensions": ["mfm"]\n  },\n  "application/vnd.micro+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.micrografx.flo": {\n    "source": "iana",\n    "extensions": ["flo"]\n  },\n  "application/vnd.micrografx.igx": {\n    "source": "iana",\n    "extensions": ["igx"]\n  },\n  "application/vnd.microsoft.portable-executable": {\n    "source": "iana"\n  },\n  "application/vnd.microsoft.windows.thumbnail-cache": {\n    "source": "iana"\n  },\n  "application/vnd.miele+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.mif": {\n    "source": "iana",\n    "extensions": ["mif"]\n  },\n  "application/vnd.minisoft-hp3000-save": {\n    "source": "iana"\n  },\n  "application/vnd.mitsubishi.misty-guard.trustweb": {\n    "source": "iana"\n  },\n  "application/vnd.mobius.daf": {\n    "source": "iana",\n    "extensions": ["daf"]\n  },\n  "application/vnd.mobius.dis": {\n    "source": "iana",\n    "extensions": ["dis"]\n  },\n  "application/vnd.mobius.mbk": {\n    "source": "iana",\n    "extensions": ["mbk"]\n  },\n  "application/vnd.mobius.mqy": {\n    "source": "iana",\n    "extensions": ["mqy"]\n  },\n  "application/vnd.mobius.msl": {\n    "source": "iana",\n    "extensions": ["msl"]\n  },\n  "application/vnd.mobius.plc": {\n    "source": "iana",\n    "extensions": ["plc"]\n  },\n  "application/vnd.mobius.txf": {\n    "source": "iana",\n    "extensions": ["txf"]\n  },\n  "application/vnd.mophun.application": {\n    "source": "iana",\n    "extensions": ["mpn"]\n  },\n  "application/vnd.mophun.certificate": {\n    "source": "iana",\n    "extensions": ["mpc"]\n  },\n  "application/vnd.motorola.flexsuite": {\n    "source": "iana"\n  },\n  "application/vnd.motorola.flexsuite.adsi": {\n    "source": "iana"\n  },\n  "application/vnd.motorola.flexsuite.fis": {\n    "source": "iana"\n  },\n  "application/vnd.motorola.flexsuite.gotap": {\n    "source": "iana"\n  },\n  "application/vnd.motorola.flexsuite.kmr": {\n    "source": "iana"\n  },\n  "application/vnd.motorola.flexsuite.ttc": {\n    "source": "iana"\n  },\n  "application/vnd.motorola.flexsuite.wem": {\n    "source": "iana"\n  },\n  "application/vnd.motorola.iprm": {\n    "source": "iana"\n  },\n  "application/vnd.mozilla.xul+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xul"]\n  },\n  "application/vnd.ms-3mfdocument": {\n    "source": "iana"\n  },\n  "application/vnd.ms-artgalry": {\n    "source": "iana",\n    "extensions": ["cil"]\n  },\n  "application/vnd.ms-asf": {\n    "source": "iana"\n  },\n  "application/vnd.ms-cab-compressed": {\n    "source": "iana",\n    "extensions": ["cab"]\n  },\n  "application/vnd.ms-color.iccprofile": {\n    "source": "apache"\n  },\n  "application/vnd.ms-excel": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["xls","xlm","xla","xlc","xlt","xlw"]\n  },\n  "application/vnd.ms-excel.addin.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["xlam"]\n  },\n  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["xlsb"]\n  },\n  "application/vnd.ms-excel.sheet.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["xlsm"]\n  },\n  "application/vnd.ms-excel.template.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["xltm"]\n  },\n  "application/vnd.ms-fontobject": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["eot"]\n  },\n  "application/vnd.ms-htmlhelp": {\n    "source": "iana",\n    "extensions": ["chm"]\n  },\n  "application/vnd.ms-ims": {\n    "source": "iana",\n    "extensions": ["ims"]\n  },\n  "application/vnd.ms-lrm": {\n    "source": "iana",\n    "extensions": ["lrm"]\n  },\n  "application/vnd.ms-office.activex+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ms-officetheme": {\n    "source": "iana",\n    "extensions": ["thmx"]\n  },\n  "application/vnd.ms-opentype": {\n    "source": "apache",\n    "compressible": true\n  },\n  "application/vnd.ms-outlook": {\n    "compressible": false,\n    "extensions": ["msg"]\n  },\n  "application/vnd.ms-package.obfuscated-opentype": {\n    "source": "apache"\n  },\n  "application/vnd.ms-pki.seccat": {\n    "source": "apache",\n    "extensions": ["cat"]\n  },\n  "application/vnd.ms-pki.stl": {\n    "source": "apache",\n    "extensions": ["stl"]\n  },\n  "application/vnd.ms-playready.initiator+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ms-powerpoint": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["ppt","pps","pot"]\n  },\n  "application/vnd.ms-powerpoint.addin.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["ppam"]\n  },\n  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["pptm"]\n  },\n  "application/vnd.ms-powerpoint.slide.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["sldm"]\n  },\n  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["ppsm"]\n  },\n  "application/vnd.ms-powerpoint.template.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["potm"]\n  },\n  "application/vnd.ms-printdevicecapabilities+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ms-printing.printticket+xml": {\n    "source": "apache",\n    "compressible": true\n  },\n  "application/vnd.ms-printschematicket+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.ms-project": {\n    "source": "iana",\n    "extensions": ["mpp","mpt"]\n  },\n  "application/vnd.ms-tnef": {\n    "source": "iana"\n  },\n  "application/vnd.ms-windows.devicepairing": {\n    "source": "iana"\n  },\n  "application/vnd.ms-windows.nwprinting.oob": {\n    "source": "iana"\n  },\n  "application/vnd.ms-windows.printerpairing": {\n    "source": "iana"\n  },\n  "application/vnd.ms-windows.wsd.oob": {\n    "source": "iana"\n  },\n  "application/vnd.ms-wmdrm.lic-chlg-req": {\n    "source": "iana"\n  },\n  "application/vnd.ms-wmdrm.lic-resp": {\n    "source": "iana"\n  },\n  "application/vnd.ms-wmdrm.meter-chlg-req": {\n    "source": "iana"\n  },\n  "application/vnd.ms-wmdrm.meter-resp": {\n    "source": "iana"\n  },\n  "application/vnd.ms-word.document.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["docm"]\n  },\n  "application/vnd.ms-word.template.macroenabled.12": {\n    "source": "iana",\n    "extensions": ["dotm"]\n  },\n  "application/vnd.ms-works": {\n    "source": "iana",\n    "extensions": ["wps","wks","wcm","wdb"]\n  },\n  "application/vnd.ms-wpl": {\n    "source": "iana",\n    "extensions": ["wpl"]\n  },\n  "application/vnd.ms-xpsdocument": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["xps"]\n  },\n  "application/vnd.msa-disk-image": {\n    "source": "iana"\n  },\n  "application/vnd.mseq": {\n    "source": "iana",\n    "extensions": ["mseq"]\n  },\n  "application/vnd.msign": {\n    "source": "iana"\n  },\n  "application/vnd.multiad.creator": {\n    "source": "iana"\n  },\n  "application/vnd.multiad.creator.cif": {\n    "source": "iana"\n  },\n  "application/vnd.music-niff": {\n    "source": "iana"\n  },\n  "application/vnd.musician": {\n    "source": "iana",\n    "extensions": ["mus"]\n  },\n  "application/vnd.muvee.style": {\n    "source": "iana",\n    "extensions": ["msty"]\n  },\n  "application/vnd.mynfc": {\n    "source": "iana",\n    "extensions": ["taglet"]\n  },\n  "application/vnd.ncd.control": {\n    "source": "iana"\n  },\n  "application/vnd.ncd.reference": {\n    "source": "iana"\n  },\n  "application/vnd.nearst.inv+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.nervana": {\n    "source": "iana"\n  },\n  "application/vnd.netfpx": {\n    "source": "iana"\n  },\n  "application/vnd.neurolanguage.nlu": {\n    "source": "iana",\n    "extensions": ["nlu"]\n  },\n  "application/vnd.nimn": {\n    "source": "iana"\n  },\n  "application/vnd.nintendo.nitro.rom": {\n    "source": "iana"\n  },\n  "application/vnd.nintendo.snes.rom": {\n    "source": "iana"\n  },\n  "application/vnd.nitf": {\n    "source": "iana",\n    "extensions": ["ntf","nitf"]\n  },\n  "application/vnd.noblenet-directory": {\n    "source": "iana",\n    "extensions": ["nnd"]\n  },\n  "application/vnd.noblenet-sealer": {\n    "source": "iana",\n    "extensions": ["nns"]\n  },\n  "application/vnd.noblenet-web": {\n    "source": "iana",\n    "extensions": ["nnw"]\n  },\n  "application/vnd.nokia.catalogs": {\n    "source": "iana"\n  },\n  "application/vnd.nokia.conml+wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.nokia.conml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.nokia.iptv.config+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.nokia.isds-radio-presets": {\n    "source": "iana"\n  },\n  "application/vnd.nokia.landmark+wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.nokia.landmark+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.nokia.landmarkcollection+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.nokia.n-gage.ac+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ac"]\n  },\n  "application/vnd.nokia.n-gage.data": {\n    "source": "iana",\n    "extensions": ["ngdat"]\n  },\n  "application/vnd.nokia.n-gage.symbian.install": {\n    "source": "iana",\n    "extensions": ["n-gage"]\n  },\n  "application/vnd.nokia.ncd": {\n    "source": "iana"\n  },\n  "application/vnd.nokia.pcd+wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.nokia.pcd+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.nokia.radio-preset": {\n    "source": "iana",\n    "extensions": ["rpst"]\n  },\n  "application/vnd.nokia.radio-presets": {\n    "source": "iana",\n    "extensions": ["rpss"]\n  },\n  "application/vnd.novadigm.edm": {\n    "source": "iana",\n    "extensions": ["edm"]\n  },\n  "application/vnd.novadigm.edx": {\n    "source": "iana",\n    "extensions": ["edx"]\n  },\n  "application/vnd.novadigm.ext": {\n    "source": "iana",\n    "extensions": ["ext"]\n  },\n  "application/vnd.ntt-local.content-share": {\n    "source": "iana"\n  },\n  "application/vnd.ntt-local.file-transfer": {\n    "source": "iana"\n  },\n  "application/vnd.ntt-local.ogw_remote-access": {\n    "source": "iana"\n  },\n  "application/vnd.ntt-local.sip-ta_remote": {\n    "source": "iana"\n  },\n  "application/vnd.ntt-local.sip-ta_tcp_stream": {\n    "source": "iana"\n  },\n  "application/vnd.oasis.opendocument.chart": {\n    "source": "iana",\n    "extensions": ["odc"]\n  },\n  "application/vnd.oasis.opendocument.chart-template": {\n    "source": "iana",\n    "extensions": ["otc"]\n  },\n  "application/vnd.oasis.opendocument.database": {\n    "source": "iana",\n    "extensions": ["odb"]\n  },\n  "application/vnd.oasis.opendocument.formula": {\n    "source": "iana",\n    "extensions": ["odf"]\n  },\n  "application/vnd.oasis.opendocument.formula-template": {\n    "source": "iana",\n    "extensions": ["odft"]\n  },\n  "application/vnd.oasis.opendocument.graphics": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["odg"]\n  },\n  "application/vnd.oasis.opendocument.graphics-template": {\n    "source": "iana",\n    "extensions": ["otg"]\n  },\n  "application/vnd.oasis.opendocument.image": {\n    "source": "iana",\n    "extensions": ["odi"]\n  },\n  "application/vnd.oasis.opendocument.image-template": {\n    "source": "iana",\n    "extensions": ["oti"]\n  },\n  "application/vnd.oasis.opendocument.presentation": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["odp"]\n  },\n  "application/vnd.oasis.opendocument.presentation-template": {\n    "source": "iana",\n    "extensions": ["otp"]\n  },\n  "application/vnd.oasis.opendocument.spreadsheet": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["ods"]\n  },\n  "application/vnd.oasis.opendocument.spreadsheet-template": {\n    "source": "iana",\n    "extensions": ["ots"]\n  },\n  "application/vnd.oasis.opendocument.text": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["odt"]\n  },\n  "application/vnd.oasis.opendocument.text-master": {\n    "source": "iana",\n    "extensions": ["odm"]\n  },\n  "application/vnd.oasis.opendocument.text-template": {\n    "source": "iana",\n    "extensions": ["ott"]\n  },\n  "application/vnd.oasis.opendocument.text-web": {\n    "source": "iana",\n    "extensions": ["oth"]\n  },\n  "application/vnd.obn": {\n    "source": "iana"\n  },\n  "application/vnd.ocf+cbor": {\n    "source": "iana"\n  },\n  "application/vnd.oci.image.manifest.v1+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oftn.l10n+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.contentaccessdownload+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.contentaccessstreaming+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.cspg-hexbinary": {\n    "source": "iana"\n  },\n  "application/vnd.oipf.dae.svg+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.dae.xhtml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.mippvcontrolmessage+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.pae.gem": {\n    "source": "iana"\n  },\n  "application/vnd.oipf.spdiscovery+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.spdlist+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.ueprofile+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oipf.userprofile+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.olpc-sugar": {\n    "source": "iana",\n    "extensions": ["xo"]\n  },\n  "application/vnd.oma-scws-config": {\n    "source": "iana"\n  },\n  "application/vnd.oma-scws-http-request": {\n    "source": "iana"\n  },\n  "application/vnd.oma-scws-http-response": {\n    "source": "iana"\n  },\n  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.bcast.drm-trigger+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.bcast.imd+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.bcast.ltkm": {\n    "source": "iana"\n  },\n  "application/vnd.oma.bcast.notification+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.bcast.provisioningtrigger": {\n    "source": "iana"\n  },\n  "application/vnd.oma.bcast.sgboot": {\n    "source": "iana"\n  },\n  "application/vnd.oma.bcast.sgdd+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.bcast.sgdu": {\n    "source": "iana"\n  },\n  "application/vnd.oma.bcast.simple-symbol-container": {\n    "source": "iana"\n  },\n  "application/vnd.oma.bcast.smartcard-trigger+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.bcast.sprov+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.bcast.stkm": {\n    "source": "iana"\n  },\n  "application/vnd.oma.cab-address-book+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.cab-feature-handler+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.cab-pcc+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.cab-subs-invite+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.cab-user-prefs+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.dcd": {\n    "source": "iana"\n  },\n  "application/vnd.oma.dcdc": {\n    "source": "iana"\n  },\n  "application/vnd.oma.dd2+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["dd2"]\n  },\n  "application/vnd.oma.drm.risd+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.group-usage-list+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.lwm2m+cbor": {\n    "source": "iana"\n  },\n  "application/vnd.oma.lwm2m+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.lwm2m+tlv": {\n    "source": "iana"\n  },\n  "application/vnd.oma.pal+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.poc.detailed-progress-report+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.poc.final-report+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.poc.groups+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.poc.invocation-descriptor+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.poc.optimized-progress-report+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.push": {\n    "source": "iana"\n  },\n  "application/vnd.oma.scidm.messages+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oma.xcap-directory+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.omads-email+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/vnd.omads-file+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/vnd.omads-folder+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/vnd.omaloc-supl-init": {\n    "source": "iana"\n  },\n  "application/vnd.onepager": {\n    "source": "iana"\n  },\n  "application/vnd.onepagertamp": {\n    "source": "iana"\n  },\n  "application/vnd.onepagertamx": {\n    "source": "iana"\n  },\n  "application/vnd.onepagertat": {\n    "source": "iana"\n  },\n  "application/vnd.onepagertatp": {\n    "source": "iana"\n  },\n  "application/vnd.onepagertatx": {\n    "source": "iana"\n  },\n  "application/vnd.openblox.game+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["obgx"]\n  },\n  "application/vnd.openblox.game-binary": {\n    "source": "iana"\n  },\n  "application/vnd.openeye.oeb": {\n    "source": "iana"\n  },\n  "application/vnd.openofficeorg.extension": {\n    "source": "apache",\n    "extensions": ["oxt"]\n  },\n  "application/vnd.openstreetmap.data+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["osm"]\n  },\n  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.drawing+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["pptx"]\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.slide": {\n    "source": "iana",\n    "extensions": ["sldx"]\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {\n    "source": "iana",\n    "extensions": ["ppsx"]\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.template": {\n    "source": "iana",\n    "extensions": ["potx"]\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["xlsx"]\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {\n    "source": "iana",\n    "extensions": ["xltx"]\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.theme+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.vmldrawing": {\n    "source": "iana"\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["docx"]\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {\n    "source": "iana",\n    "extensions": ["dotx"]\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-package.core-properties+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.openxmlformats-package.relationships+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oracle.resource+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.orange.indata": {\n    "source": "iana"\n  },\n  "application/vnd.osa.netdeploy": {\n    "source": "iana"\n  },\n  "application/vnd.osgeo.mapguide.package": {\n    "source": "iana",\n    "extensions": ["mgp"]\n  },\n  "application/vnd.osgi.bundle": {\n    "source": "iana"\n  },\n  "application/vnd.osgi.dp": {\n    "source": "iana",\n    "extensions": ["dp"]\n  },\n  "application/vnd.osgi.subsystem": {\n    "source": "iana",\n    "extensions": ["esa"]\n  },\n  "application/vnd.otps.ct-kip+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.oxli.countgraph": {\n    "source": "iana"\n  },\n  "application/vnd.pagerduty+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.palm": {\n    "source": "iana",\n    "extensions": ["pdb","pqa","oprc"]\n  },\n  "application/vnd.panoply": {\n    "source": "iana"\n  },\n  "application/vnd.paos.xml": {\n    "source": "iana"\n  },\n  "application/vnd.patentdive": {\n    "source": "iana"\n  },\n  "application/vnd.patientecommsdoc": {\n    "source": "iana"\n  },\n  "application/vnd.pawaafile": {\n    "source": "iana",\n    "extensions": ["paw"]\n  },\n  "application/vnd.pcos": {\n    "source": "iana"\n  },\n  "application/vnd.pg.format": {\n    "source": "iana",\n    "extensions": ["str"]\n  },\n  "application/vnd.pg.osasli": {\n    "source": "iana",\n    "extensions": ["ei6"]\n  },\n  "application/vnd.piaccess.application-licence": {\n    "source": "iana"\n  },\n  "application/vnd.picsel": {\n    "source": "iana",\n    "extensions": ["efif"]\n  },\n  "application/vnd.pmi.widget": {\n    "source": "iana",\n    "extensions": ["wg"]\n  },\n  "application/vnd.poc.group-advertisement+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.pocketlearn": {\n    "source": "iana",\n    "extensions": ["plf"]\n  },\n  "application/vnd.powerbuilder6": {\n    "source": "iana",\n    "extensions": ["pbd"]\n  },\n  "application/vnd.powerbuilder6-s": {\n    "source": "iana"\n  },\n  "application/vnd.powerbuilder7": {\n    "source": "iana"\n  },\n  "application/vnd.powerbuilder7-s": {\n    "source": "iana"\n  },\n  "application/vnd.powerbuilder75": {\n    "source": "iana"\n  },\n  "application/vnd.powerbuilder75-s": {\n    "source": "iana"\n  },\n  "application/vnd.preminet": {\n    "source": "iana"\n  },\n  "application/vnd.previewsystems.box": {\n    "source": "iana",\n    "extensions": ["box"]\n  },\n  "application/vnd.proteus.magazine": {\n    "source": "iana",\n    "extensions": ["mgz"]\n  },\n  "application/vnd.psfs": {\n    "source": "iana"\n  },\n  "application/vnd.publishare-delta-tree": {\n    "source": "iana",\n    "extensions": ["qps"]\n  },\n  "application/vnd.pvi.ptid1": {\n    "source": "iana",\n    "extensions": ["ptid"]\n  },\n  "application/vnd.pwg-multiplexed": {\n    "source": "iana"\n  },\n  "application/vnd.pwg-xhtml-print+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.qualcomm.brew-app-res": {\n    "source": "iana"\n  },\n  "application/vnd.quarantainenet": {\n    "source": "iana"\n  },\n  "application/vnd.quark.quarkxpress": {\n    "source": "iana",\n    "extensions": ["qxd","qxt","qwd","qwt","qxl","qxb"]\n  },\n  "application/vnd.quobject-quoxdocument": {\n    "source": "iana"\n  },\n  "application/vnd.radisys.moml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-audit+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-audit-conf+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-audit-conn+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-audit-dialog+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-audit-stream+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-conf+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-dialog+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-dialog-base+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-dialog-fax-detect+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-dialog-group+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-dialog-speech+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.radisys.msml-dialog-transform+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.rainstor.data": {\n    "source": "iana"\n  },\n  "application/vnd.rapid": {\n    "source": "iana"\n  },\n  "application/vnd.rar": {\n    "source": "iana",\n    "extensions": ["rar"]\n  },\n  "application/vnd.realvnc.bed": {\n    "source": "iana",\n    "extensions": ["bed"]\n  },\n  "application/vnd.recordare.musicxml": {\n    "source": "iana",\n    "extensions": ["mxl"]\n  },\n  "application/vnd.recordare.musicxml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["musicxml"]\n  },\n  "application/vnd.renlearn.rlprint": {\n    "source": "iana"\n  },\n  "application/vnd.restful+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.rig.cryptonote": {\n    "source": "iana",\n    "extensions": ["cryptonote"]\n  },\n  "application/vnd.rim.cod": {\n    "source": "apache",\n    "extensions": ["cod"]\n  },\n  "application/vnd.rn-realmedia": {\n    "source": "apache",\n    "extensions": ["rm"]\n  },\n  "application/vnd.rn-realmedia-vbr": {\n    "source": "apache",\n    "extensions": ["rmvb"]\n  },\n  "application/vnd.route66.link66+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["link66"]\n  },\n  "application/vnd.rs-274x": {\n    "source": "iana"\n  },\n  "application/vnd.ruckus.download": {\n    "source": "iana"\n  },\n  "application/vnd.s3sms": {\n    "source": "iana"\n  },\n  "application/vnd.sailingtracker.track": {\n    "source": "iana",\n    "extensions": ["st"]\n  },\n  "application/vnd.sar": {\n    "source": "iana"\n  },\n  "application/vnd.sbm.cid": {\n    "source": "iana"\n  },\n  "application/vnd.sbm.mid2": {\n    "source": "iana"\n  },\n  "application/vnd.scribus": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.3df": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.csf": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.doc": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.eml": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.mht": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.net": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.ppt": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.tiff": {\n    "source": "iana"\n  },\n  "application/vnd.sealed.xls": {\n    "source": "iana"\n  },\n  "application/vnd.sealedmedia.softseal.html": {\n    "source": "iana"\n  },\n  "application/vnd.sealedmedia.softseal.pdf": {\n    "source": "iana"\n  },\n  "application/vnd.seemail": {\n    "source": "iana",\n    "extensions": ["see"]\n  },\n  "application/vnd.seis+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.sema": {\n    "source": "iana",\n    "extensions": ["sema"]\n  },\n  "application/vnd.semd": {\n    "source": "iana",\n    "extensions": ["semd"]\n  },\n  "application/vnd.semf": {\n    "source": "iana",\n    "extensions": ["semf"]\n  },\n  "application/vnd.shade-save-file": {\n    "source": "iana"\n  },\n  "application/vnd.shana.informed.formdata": {\n    "source": "iana",\n    "extensions": ["ifm"]\n  },\n  "application/vnd.shana.informed.formtemplate": {\n    "source": "iana",\n    "extensions": ["itp"]\n  },\n  "application/vnd.shana.informed.interchange": {\n    "source": "iana",\n    "extensions": ["iif"]\n  },\n  "application/vnd.shana.informed.package": {\n    "source": "iana",\n    "extensions": ["ipk"]\n  },\n  "application/vnd.shootproof+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.shopkick+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.shp": {\n    "source": "iana"\n  },\n  "application/vnd.shx": {\n    "source": "iana"\n  },\n  "application/vnd.sigrok.session": {\n    "source": "iana"\n  },\n  "application/vnd.simtech-mindmapper": {\n    "source": "iana",\n    "extensions": ["twd","twds"]\n  },\n  "application/vnd.siren+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.smaf": {\n    "source": "iana",\n    "extensions": ["mmf"]\n  },\n  "application/vnd.smart.notebook": {\n    "source": "iana"\n  },\n  "application/vnd.smart.teacher": {\n    "source": "iana",\n    "extensions": ["teacher"]\n  },\n  "application/vnd.snesdev-page-table": {\n    "source": "iana"\n  },\n  "application/vnd.software602.filler.form+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["fo"]\n  },\n  "application/vnd.software602.filler.form-xml-zip": {\n    "source": "iana"\n  },\n  "application/vnd.solent.sdkm+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["sdkm","sdkd"]\n  },\n  "application/vnd.spotfire.dxp": {\n    "source": "iana",\n    "extensions": ["dxp"]\n  },\n  "application/vnd.spotfire.sfs": {\n    "source": "iana",\n    "extensions": ["sfs"]\n  },\n  "application/vnd.sqlite3": {\n    "source": "iana"\n  },\n  "application/vnd.sss-cod": {\n    "source": "iana"\n  },\n  "application/vnd.sss-dtf": {\n    "source": "iana"\n  },\n  "application/vnd.sss-ntf": {\n    "source": "iana"\n  },\n  "application/vnd.stardivision.calc": {\n    "source": "apache",\n    "extensions": ["sdc"]\n  },\n  "application/vnd.stardivision.draw": {\n    "source": "apache",\n    "extensions": ["sda"]\n  },\n  "application/vnd.stardivision.impress": {\n    "source": "apache",\n    "extensions": ["sdd"]\n  },\n  "application/vnd.stardivision.math": {\n    "source": "apache",\n    "extensions": ["smf"]\n  },\n  "application/vnd.stardivision.writer": {\n    "source": "apache",\n    "extensions": ["sdw","vor"]\n  },\n  "application/vnd.stardivision.writer-global": {\n    "source": "apache",\n    "extensions": ["sgl"]\n  },\n  "application/vnd.stepmania.package": {\n    "source": "iana",\n    "extensions": ["smzip"]\n  },\n  "application/vnd.stepmania.stepchart": {\n    "source": "iana",\n    "extensions": ["sm"]\n  },\n  "application/vnd.street-stream": {\n    "source": "iana"\n  },\n  "application/vnd.sun.wadl+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["wadl"]\n  },\n  "application/vnd.sun.xml.calc": {\n    "source": "apache",\n    "extensions": ["sxc"]\n  },\n  "application/vnd.sun.xml.calc.template": {\n    "source": "apache",\n    "extensions": ["stc"]\n  },\n  "application/vnd.sun.xml.draw": {\n    "source": "apache",\n    "extensions": ["sxd"]\n  },\n  "application/vnd.sun.xml.draw.template": {\n    "source": "apache",\n    "extensions": ["std"]\n  },\n  "application/vnd.sun.xml.impress": {\n    "source": "apache",\n    "extensions": ["sxi"]\n  },\n  "application/vnd.sun.xml.impress.template": {\n    "source": "apache",\n    "extensions": ["sti"]\n  },\n  "application/vnd.sun.xml.math": {\n    "source": "apache",\n    "extensions": ["sxm"]\n  },\n  "application/vnd.sun.xml.writer": {\n    "source": "apache",\n    "extensions": ["sxw"]\n  },\n  "application/vnd.sun.xml.writer.global": {\n    "source": "apache",\n    "extensions": ["sxg"]\n  },\n  "application/vnd.sun.xml.writer.template": {\n    "source": "apache",\n    "extensions": ["stw"]\n  },\n  "application/vnd.sus-calendar": {\n    "source": "iana",\n    "extensions": ["sus","susp"]\n  },\n  "application/vnd.svd": {\n    "source": "iana",\n    "extensions": ["svd"]\n  },\n  "application/vnd.swiftview-ics": {\n    "source": "iana"\n  },\n  "application/vnd.sycle+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.symbian.install": {\n    "source": "apache",\n    "extensions": ["sis","sisx"]\n  },\n  "application/vnd.syncml+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["xsm"]\n  },\n  "application/vnd.syncml.dm+wbxml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "extensions": ["bdm"]\n  },\n  "application/vnd.syncml.dm+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["xdm"]\n  },\n  "application/vnd.syncml.dm.notification": {\n    "source": "iana"\n  },\n  "application/vnd.syncml.dmddf+wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.syncml.dmddf+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["ddf"]\n  },\n  "application/vnd.syncml.dmtnds+wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.syncml.dmtnds+xml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true\n  },\n  "application/vnd.syncml.ds.notification": {\n    "source": "iana"\n  },\n  "application/vnd.tableschema+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.tao.intent-module-archive": {\n    "source": "iana",\n    "extensions": ["tao"]\n  },\n  "application/vnd.tcpdump.pcap": {\n    "source": "iana",\n    "extensions": ["pcap","cap","dmp"]\n  },\n  "application/vnd.think-cell.ppttc+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.tmd.mediaflex.api+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.tml": {\n    "source": "iana"\n  },\n  "application/vnd.tmobile-livetv": {\n    "source": "iana",\n    "extensions": ["tmo"]\n  },\n  "application/vnd.tri.onesource": {\n    "source": "iana"\n  },\n  "application/vnd.trid.tpt": {\n    "source": "iana",\n    "extensions": ["tpt"]\n  },\n  "application/vnd.triscape.mxs": {\n    "source": "iana",\n    "extensions": ["mxs"]\n  },\n  "application/vnd.trueapp": {\n    "source": "iana",\n    "extensions": ["tra"]\n  },\n  "application/vnd.truedoc": {\n    "source": "iana"\n  },\n  "application/vnd.ubisoft.webplayer": {\n    "source": "iana"\n  },\n  "application/vnd.ufdl": {\n    "source": "iana",\n    "extensions": ["ufd","ufdl"]\n  },\n  "application/vnd.uiq.theme": {\n    "source": "iana",\n    "extensions": ["utz"]\n  },\n  "application/vnd.umajin": {\n    "source": "iana",\n    "extensions": ["umj"]\n  },\n  "application/vnd.unity": {\n    "source": "iana",\n    "extensions": ["unityweb"]\n  },\n  "application/vnd.uoml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["uoml"]\n  },\n  "application/vnd.uplanet.alert": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.alert-wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.bearer-choice": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.bearer-choice-wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.cacheop": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.cacheop-wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.channel": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.channel-wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.list": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.list-wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.listcmd": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.listcmd-wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.uplanet.signal": {\n    "source": "iana"\n  },\n  "application/vnd.uri-map": {\n    "source": "iana"\n  },\n  "application/vnd.valve.source.material": {\n    "source": "iana"\n  },\n  "application/vnd.vcx": {\n    "source": "iana",\n    "extensions": ["vcx"]\n  },\n  "application/vnd.vd-study": {\n    "source": "iana"\n  },\n  "application/vnd.vectorworks": {\n    "source": "iana"\n  },\n  "application/vnd.vel+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.verimatrix.vcas": {\n    "source": "iana"\n  },\n  "application/vnd.veryant.thin": {\n    "source": "iana"\n  },\n  "application/vnd.ves.encrypted": {\n    "source": "iana"\n  },\n  "application/vnd.vidsoft.vidconference": {\n    "source": "iana"\n  },\n  "application/vnd.visio": {\n    "source": "iana",\n    "extensions": ["vsd","vst","vss","vsw"]\n  },\n  "application/vnd.visionary": {\n    "source": "iana",\n    "extensions": ["vis"]\n  },\n  "application/vnd.vividence.scriptfile": {\n    "source": "iana"\n  },\n  "application/vnd.vsf": {\n    "source": "iana",\n    "extensions": ["vsf"]\n  },\n  "application/vnd.wap.sic": {\n    "source": "iana"\n  },\n  "application/vnd.wap.slc": {\n    "source": "iana"\n  },\n  "application/vnd.wap.wbxml": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "extensions": ["wbxml"]\n  },\n  "application/vnd.wap.wmlc": {\n    "source": "iana",\n    "extensions": ["wmlc"]\n  },\n  "application/vnd.wap.wmlscriptc": {\n    "source": "iana",\n    "extensions": ["wmlsc"]\n  },\n  "application/vnd.webturbo": {\n    "source": "iana",\n    "extensions": ["wtb"]\n  },\n  "application/vnd.wfa.dpp": {\n    "source": "iana"\n  },\n  "application/vnd.wfa.p2p": {\n    "source": "iana"\n  },\n  "application/vnd.wfa.wsc": {\n    "source": "iana"\n  },\n  "application/vnd.windows.devicepairing": {\n    "source": "iana"\n  },\n  "application/vnd.wmc": {\n    "source": "iana"\n  },\n  "application/vnd.wmf.bootstrap": {\n    "source": "iana"\n  },\n  "application/vnd.wolfram.mathematica": {\n    "source": "iana"\n  },\n  "application/vnd.wolfram.mathematica.package": {\n    "source": "iana"\n  },\n  "application/vnd.wolfram.player": {\n    "source": "iana",\n    "extensions": ["nbp"]\n  },\n  "application/vnd.wordperfect": {\n    "source": "iana",\n    "extensions": ["wpd"]\n  },\n  "application/vnd.wqd": {\n    "source": "iana",\n    "extensions": ["wqd"]\n  },\n  "application/vnd.wrq-hp3000-labelled": {\n    "source": "iana"\n  },\n  "application/vnd.wt.stf": {\n    "source": "iana",\n    "extensions": ["stf"]\n  },\n  "application/vnd.wv.csp+wbxml": {\n    "source": "iana"\n  },\n  "application/vnd.wv.csp+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.wv.ssp+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.xacml+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.xara": {\n    "source": "iana",\n    "extensions": ["xar"]\n  },\n  "application/vnd.xfdl": {\n    "source": "iana",\n    "extensions": ["xfdl"]\n  },\n  "application/vnd.xfdl.webform": {\n    "source": "iana"\n  },\n  "application/vnd.xmi+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vnd.xmpie.cpkg": {\n    "source": "iana"\n  },\n  "application/vnd.xmpie.dpkg": {\n    "source": "iana"\n  },\n  "application/vnd.xmpie.plan": {\n    "source": "iana"\n  },\n  "application/vnd.xmpie.ppkg": {\n    "source": "iana"\n  },\n  "application/vnd.xmpie.xlim": {\n    "source": "iana"\n  },\n  "application/vnd.yamaha.hv-dic": {\n    "source": "iana",\n    "extensions": ["hvd"]\n  },\n  "application/vnd.yamaha.hv-script": {\n    "source": "iana",\n    "extensions": ["hvs"]\n  },\n  "application/vnd.yamaha.hv-voice": {\n    "source": "iana",\n    "extensions": ["hvp"]\n  },\n  "application/vnd.yamaha.openscoreformat": {\n    "source": "iana",\n    "extensions": ["osf"]\n  },\n  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["osfpvg"]\n  },\n  "application/vnd.yamaha.remote-setup": {\n    "source": "iana"\n  },\n  "application/vnd.yamaha.smaf-audio": {\n    "source": "iana",\n    "extensions": ["saf"]\n  },\n  "application/vnd.yamaha.smaf-phrase": {\n    "source": "iana",\n    "extensions": ["spf"]\n  },\n  "application/vnd.yamaha.through-ngn": {\n    "source": "iana"\n  },\n  "application/vnd.yamaha.tunnel-udpencap": {\n    "source": "iana"\n  },\n  "application/vnd.yaoweme": {\n    "source": "iana"\n  },\n  "application/vnd.yellowriver-custom-menu": {\n    "source": "iana",\n    "extensions": ["cmp"]\n  },\n  "application/vnd.youtube.yt": {\n    "source": "iana"\n  },\n  "application/vnd.zul": {\n    "source": "iana",\n    "extensions": ["zir","zirz"]\n  },\n  "application/vnd.zzazz.deck+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["zaz"]\n  },\n  "application/voicexml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["vxml"]\n  },\n  "application/voucher-cms+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/vq-rtcpxr": {\n    "source": "iana"\n  },\n  "application/wasm": {\n    "compressible": true,\n    "extensions": ["wasm"]\n  },\n  "application/watcherinfo+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/webpush-options+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/whoispp-query": {\n    "source": "iana"\n  },\n  "application/whoispp-response": {\n    "source": "iana"\n  },\n  "application/widget": {\n    "source": "iana",\n    "extensions": ["wgt"]\n  },\n  "application/winhlp": {\n    "source": "apache",\n    "extensions": ["hlp"]\n  },\n  "application/wita": {\n    "source": "iana"\n  },\n  "application/wordperfect5.1": {\n    "source": "iana"\n  },\n  "application/wsdl+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["wsdl"]\n  },\n  "application/wspolicy+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["wspolicy"]\n  },\n  "application/x-7z-compressed": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["7z"]\n  },\n  "application/x-abiword": {\n    "source": "apache",\n    "extensions": ["abw"]\n  },\n  "application/x-ace-compressed": {\n    "source": "apache",\n    "extensions": ["ace"]\n  },\n  "application/x-amf": {\n    "source": "apache"\n  },\n  "application/x-apple-diskimage": {\n    "source": "apache",\n    "extensions": ["dmg"]\n  },\n  "application/x-arj": {\n    "compressible": false,\n    "extensions": ["arj"]\n  },\n  "application/x-authorware-bin": {\n    "source": "apache",\n    "extensions": ["aab","x32","u32","vox"]\n  },\n  "application/x-authorware-map": {\n    "source": "apache",\n    "extensions": ["aam"]\n  },\n  "application/x-authorware-seg": {\n    "source": "apache",\n    "extensions": ["aas"]\n  },\n  "application/x-bcpio": {\n    "source": "apache",\n    "extensions": ["bcpio"]\n  },\n  "application/x-bdoc": {\n    "compressible": false,\n    "extensions": ["bdoc"]\n  },\n  "application/x-bittorrent": {\n    "source": "apache",\n    "extensions": ["torrent"]\n  },\n  "application/x-blorb": {\n    "source": "apache",\n    "extensions": ["blb","blorb"]\n  },\n  "application/x-bzip": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["bz"]\n  },\n  "application/x-bzip2": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["bz2","boz"]\n  },\n  "application/x-cbr": {\n    "source": "apache",\n    "extensions": ["cbr","cba","cbt","cbz","cb7"]\n  },\n  "application/x-cdlink": {\n    "source": "apache",\n    "extensions": ["vcd"]\n  },\n  "application/x-cfs-compressed": {\n    "source": "apache",\n    "extensions": ["cfs"]\n  },\n  "application/x-chat": {\n    "source": "apache",\n    "extensions": ["chat"]\n  },\n  "application/x-chess-pgn": {\n    "source": "apache",\n    "extensions": ["pgn"]\n  },\n  "application/x-chrome-extension": {\n    "extensions": ["crx"]\n  },\n  "application/x-cocoa": {\n    "source": "nginx",\n    "extensions": ["cco"]\n  },\n  "application/x-compress": {\n    "source": "apache"\n  },\n  "application/x-conference": {\n    "source": "apache",\n    "extensions": ["nsc"]\n  },\n  "application/x-cpio": {\n    "source": "apache",\n    "extensions": ["cpio"]\n  },\n  "application/x-csh": {\n    "source": "apache",\n    "extensions": ["csh"]\n  },\n  "application/x-deb": {\n    "compressible": false\n  },\n  "application/x-debian-package": {\n    "source": "apache",\n    "extensions": ["deb","udeb"]\n  },\n  "application/x-dgc-compressed": {\n    "source": "apache",\n    "extensions": ["dgc"]\n  },\n  "application/x-director": {\n    "source": "apache",\n    "extensions": ["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]\n  },\n  "application/x-doom": {\n    "source": "apache",\n    "extensions": ["wad"]\n  },\n  "application/x-dtbncx+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["ncx"]\n  },\n  "application/x-dtbook+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["dtb"]\n  },\n  "application/x-dtbresource+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["res"]\n  },\n  "application/x-dvi": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["dvi"]\n  },\n  "application/x-envoy": {\n    "source": "apache",\n    "extensions": ["evy"]\n  },\n  "application/x-eva": {\n    "source": "apache",\n    "extensions": ["eva"]\n  },\n  "application/x-font-bdf": {\n    "source": "apache",\n    "extensions": ["bdf"]\n  },\n  "application/x-font-dos": {\n    "source": "apache"\n  },\n  "application/x-font-framemaker": {\n    "source": "apache"\n  },\n  "application/x-font-ghostscript": {\n    "source": "apache",\n    "extensions": ["gsf"]\n  },\n  "application/x-font-libgrx": {\n    "source": "apache"\n  },\n  "application/x-font-linux-psf": {\n    "source": "apache",\n    "extensions": ["psf"]\n  },\n  "application/x-font-pcf": {\n    "source": "apache",\n    "extensions": ["pcf"]\n  },\n  "application/x-font-snf": {\n    "source": "apache",\n    "extensions": ["snf"]\n  },\n  "application/x-font-speedo": {\n    "source": "apache"\n  },\n  "application/x-font-sunos-news": {\n    "source": "apache"\n  },\n  "application/x-font-type1": {\n    "source": "apache",\n    "extensions": ["pfa","pfb","pfm","afm"]\n  },\n  "application/x-font-vfont": {\n    "source": "apache"\n  },\n  "application/x-freearc": {\n    "source": "apache",\n    "extensions": ["arc"]\n  },\n  "application/x-futuresplash": {\n    "source": "apache",\n    "extensions": ["spl"]\n  },\n  "application/x-gca-compressed": {\n    "source": "apache",\n    "extensions": ["gca"]\n  },\n  "application/x-glulx": {\n    "source": "apache",\n    "extensions": ["ulx"]\n  },\n  "application/x-gnumeric": {\n    "source": "apache",\n    "extensions": ["gnumeric"]\n  },\n  "application/x-gramps-xml": {\n    "source": "apache",\n    "extensions": ["gramps"]\n  },\n  "application/x-gtar": {\n    "source": "apache",\n    "extensions": ["gtar"]\n  },\n  "application/x-gzip": {\n    "source": "apache"\n  },\n  "application/x-hdf": {\n    "source": "apache",\n    "extensions": ["hdf"]\n  },\n  "application/x-httpd-php": {\n    "compressible": true,\n    "extensions": ["php"]\n  },\n  "application/x-install-instructions": {\n    "source": "apache",\n    "extensions": ["install"]\n  },\n  "application/x-iso9660-image": {\n    "source": "apache",\n    "extensions": ["iso"]\n  },\n  "application/x-java-archive-diff": {\n    "source": "nginx",\n    "extensions": ["jardiff"]\n  },\n  "application/x-java-jnlp-file": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["jnlp"]\n  },\n  "application/x-javascript": {\n    "compressible": true\n  },\n  "application/x-keepass2": {\n    "extensions": ["kdbx"]\n  },\n  "application/x-latex": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["latex"]\n  },\n  "application/x-lua-bytecode": {\n    "extensions": ["luac"]\n  },\n  "application/x-lzh-compressed": {\n    "source": "apache",\n    "extensions": ["lzh","lha"]\n  },\n  "application/x-makeself": {\n    "source": "nginx",\n    "extensions": ["run"]\n  },\n  "application/x-mie": {\n    "source": "apache",\n    "extensions": ["mie"]\n  },\n  "application/x-mobipocket-ebook": {\n    "source": "apache",\n    "extensions": ["prc","mobi"]\n  },\n  "application/x-mpegurl": {\n    "compressible": false\n  },\n  "application/x-ms-application": {\n    "source": "apache",\n    "extensions": ["application"]\n  },\n  "application/x-ms-shortcut": {\n    "source": "apache",\n    "extensions": ["lnk"]\n  },\n  "application/x-ms-wmd": {\n    "source": "apache",\n    "extensions": ["wmd"]\n  },\n  "application/x-ms-wmz": {\n    "source": "apache",\n    "extensions": ["wmz"]\n  },\n  "application/x-ms-xbap": {\n    "source": "apache",\n    "extensions": ["xbap"]\n  },\n  "application/x-msaccess": {\n    "source": "apache",\n    "extensions": ["mdb"]\n  },\n  "application/x-msbinder": {\n    "source": "apache",\n    "extensions": ["obd"]\n  },\n  "application/x-mscardfile": {\n    "source": "apache",\n    "extensions": ["crd"]\n  },\n  "application/x-msclip": {\n    "source": "apache",\n    "extensions": ["clp"]\n  },\n  "application/x-msdos-program": {\n    "extensions": ["exe"]\n  },\n  "application/x-msdownload": {\n    "source": "apache",\n    "extensions": ["exe","dll","com","bat","msi"]\n  },\n  "application/x-msmediaview": {\n    "source": "apache",\n    "extensions": ["mvb","m13","m14"]\n  },\n  "application/x-msmetafile": {\n    "source": "apache",\n    "extensions": ["wmf","wmz","emf","emz"]\n  },\n  "application/x-msmoney": {\n    "source": "apache",\n    "extensions": ["mny"]\n  },\n  "application/x-mspublisher": {\n    "source": "apache",\n    "extensions": ["pub"]\n  },\n  "application/x-msschedule": {\n    "source": "apache",\n    "extensions": ["scd"]\n  },\n  "application/x-msterminal": {\n    "source": "apache",\n    "extensions": ["trm"]\n  },\n  "application/x-mswrite": {\n    "source": "apache",\n    "extensions": ["wri"]\n  },\n  "application/x-netcdf": {\n    "source": "apache",\n    "extensions": ["nc","cdf"]\n  },\n  "application/x-ns-proxy-autoconfig": {\n    "compressible": true,\n    "extensions": ["pac"]\n  },\n  "application/x-nzb": {\n    "source": "apache",\n    "extensions": ["nzb"]\n  },\n  "application/x-perl": {\n    "source": "nginx",\n    "extensions": ["pl","pm"]\n  },\n  "application/x-pilot": {\n    "source": "nginx",\n    "extensions": ["prc","pdb"]\n  },\n  "application/x-pkcs12": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["p12","pfx"]\n  },\n  "application/x-pkcs7-certificates": {\n    "source": "apache",\n    "extensions": ["p7b","spc"]\n  },\n  "application/x-pkcs7-certreqresp": {\n    "source": "apache",\n    "extensions": ["p7r"]\n  },\n  "application/x-pki-message": {\n    "source": "iana"\n  },\n  "application/x-rar-compressed": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["rar"]\n  },\n  "application/x-redhat-package-manager": {\n    "source": "nginx",\n    "extensions": ["rpm"]\n  },\n  "application/x-research-info-systems": {\n    "source": "apache",\n    "extensions": ["ris"]\n  },\n  "application/x-sea": {\n    "source": "nginx",\n    "extensions": ["sea"]\n  },\n  "application/x-sh": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["sh"]\n  },\n  "application/x-shar": {\n    "source": "apache",\n    "extensions": ["shar"]\n  },\n  "application/x-shockwave-flash": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["swf"]\n  },\n  "application/x-silverlight-app": {\n    "source": "apache",\n    "extensions": ["xap"]\n  },\n  "application/x-sql": {\n    "source": "apache",\n    "extensions": ["sql"]\n  },\n  "application/x-stuffit": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["sit"]\n  },\n  "application/x-stuffitx": {\n    "source": "apache",\n    "extensions": ["sitx"]\n  },\n  "application/x-subrip": {\n    "source": "apache",\n    "extensions": ["srt"]\n  },\n  "application/x-sv4cpio": {\n    "source": "apache",\n    "extensions": ["sv4cpio"]\n  },\n  "application/x-sv4crc": {\n    "source": "apache",\n    "extensions": ["sv4crc"]\n  },\n  "application/x-t3vm-image": {\n    "source": "apache",\n    "extensions": ["t3"]\n  },\n  "application/x-tads": {\n    "source": "apache",\n    "extensions": ["gam"]\n  },\n  "application/x-tar": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["tar"]\n  },\n  "application/x-tcl": {\n    "source": "apache",\n    "extensions": ["tcl","tk"]\n  },\n  "application/x-tex": {\n    "source": "apache",\n    "extensions": ["tex"]\n  },\n  "application/x-tex-tfm": {\n    "source": "apache",\n    "extensions": ["tfm"]\n  },\n  "application/x-texinfo": {\n    "source": "apache",\n    "extensions": ["texinfo","texi"]\n  },\n  "application/x-tgif": {\n    "source": "apache",\n    "extensions": ["obj"]\n  },\n  "application/x-ustar": {\n    "source": "apache",\n    "extensions": ["ustar"]\n  },\n  "application/x-virtualbox-hdd": {\n    "compressible": true,\n    "extensions": ["hdd"]\n  },\n  "application/x-virtualbox-ova": {\n    "compressible": true,\n    "extensions": ["ova"]\n  },\n  "application/x-virtualbox-ovf": {\n    "compressible": true,\n    "extensions": ["ovf"]\n  },\n  "application/x-virtualbox-vbox": {\n    "compressible": true,\n    "extensions": ["vbox"]\n  },\n  "application/x-virtualbox-vbox-extpack": {\n    "compressible": false,\n    "extensions": ["vbox-extpack"]\n  },\n  "application/x-virtualbox-vdi": {\n    "compressible": true,\n    "extensions": ["vdi"]\n  },\n  "application/x-virtualbox-vhd": {\n    "compressible": true,\n    "extensions": ["vhd"]\n  },\n  "application/x-virtualbox-vmdk": {\n    "compressible": true,\n    "extensions": ["vmdk"]\n  },\n  "application/x-wais-source": {\n    "source": "apache",\n    "extensions": ["src"]\n  },\n  "application/x-web-app-manifest+json": {\n    "compressible": true,\n    "extensions": ["webapp"]\n  },\n  "application/x-www-form-urlencoded": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/x-x509-ca-cert": {\n    "source": "iana",\n    "extensions": ["der","crt","pem"]\n  },\n  "application/x-x509-ca-ra-cert": {\n    "source": "iana"\n  },\n  "application/x-x509-next-ca-cert": {\n    "source": "iana"\n  },\n  "application/x-xfig": {\n    "source": "apache",\n    "extensions": ["fig"]\n  },\n  "application/x-xliff+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["xlf"]\n  },\n  "application/x-xpinstall": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["xpi"]\n  },\n  "application/x-xz": {\n    "source": "apache",\n    "extensions": ["xz"]\n  },\n  "application/x-zmachine": {\n    "source": "apache",\n    "extensions": ["z1","z2","z3","z4","z5","z6","z7","z8"]\n  },\n  "application/x400-bp": {\n    "source": "iana"\n  },\n  "application/xacml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/xaml+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["xaml"]\n  },\n  "application/xcap-att+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xav"]\n  },\n  "application/xcap-caps+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xca"]\n  },\n  "application/xcap-diff+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xdf"]\n  },\n  "application/xcap-el+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xel"]\n  },\n  "application/xcap-error+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xer"]\n  },\n  "application/xcap-ns+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xns"]\n  },\n  "application/xcon-conference-info+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/xcon-conference-info-diff+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/xenc+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xenc"]\n  },\n  "application/xhtml+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xhtml","xht"]\n  },\n  "application/xhtml-voice+xml": {\n    "source": "apache",\n    "compressible": true\n  },\n  "application/xliff+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xlf"]\n  },\n  "application/xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xml","xsl","xsd","rng"]\n  },\n  "application/xml-dtd": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["dtd"]\n  },\n  "application/xml-external-parsed-entity": {\n    "source": "iana"\n  },\n  "application/xml-patch+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/xmpp+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/xop+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xop"]\n  },\n  "application/xproc+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["xpl"]\n  },\n  "application/xslt+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xsl","xslt"]\n  },\n  "application/xspf+xml": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["xspf"]\n  },\n  "application/xv+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["mxml","xhvml","xvml","xvm"]\n  },\n  "application/yang": {\n    "source": "iana",\n    "extensions": ["yang"]\n  },\n  "application/yang-data+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/yang-data+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/yang-patch+json": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/yang-patch+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "application/yin+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["yin"]\n  },\n  "application/zip": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["zip"]\n  },\n  "application/zlib": {\n    "source": "iana"\n  },\n  "application/zstd": {\n    "source": "iana"\n  },\n  "audio/1d-interleaved-parityfec": {\n    "source": "iana"\n  },\n  "audio/32kadpcm": {\n    "source": "iana"\n  },\n  "audio/3gpp": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["3gpp"]\n  },\n  "audio/3gpp2": {\n    "source": "iana"\n  },\n  "audio/aac": {\n    "source": "iana"\n  },\n  "audio/ac3": {\n    "source": "iana"\n  },\n  "audio/adpcm": {\n    "source": "apache",\n    "extensions": ["adp"]\n  },\n  "audio/amr": {\n    "source": "iana"\n  },\n  "audio/amr-wb": {\n    "source": "iana"\n  },\n  "audio/amr-wb+": {\n    "source": "iana"\n  },\n  "audio/aptx": {\n    "source": "iana"\n  },\n  "audio/asc": {\n    "source": "iana"\n  },\n  "audio/atrac-advanced-lossless": {\n    "source": "iana"\n  },\n  "audio/atrac-x": {\n    "source": "iana"\n  },\n  "audio/atrac3": {\n    "source": "iana"\n  },\n  "audio/basic": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["au","snd"]\n  },\n  "audio/bv16": {\n    "source": "iana"\n  },\n  "audio/bv32": {\n    "source": "iana"\n  },\n  "audio/clearmode": {\n    "source": "iana"\n  },\n  "audio/cn": {\n    "source": "iana"\n  },\n  "audio/dat12": {\n    "source": "iana"\n  },\n  "audio/dls": {\n    "source": "iana"\n  },\n  "audio/dsr-es201108": {\n    "source": "iana"\n  },\n  "audio/dsr-es202050": {\n    "source": "iana"\n  },\n  "audio/dsr-es202211": {\n    "source": "iana"\n  },\n  "audio/dsr-es202212": {\n    "source": "iana"\n  },\n  "audio/dv": {\n    "source": "iana"\n  },\n  "audio/dvi4": {\n    "source": "iana"\n  },\n  "audio/eac3": {\n    "source": "iana"\n  },\n  "audio/encaprtp": {\n    "source": "iana"\n  },\n  "audio/evrc": {\n    "source": "iana"\n  },\n  "audio/evrc-qcp": {\n    "source": "iana"\n  },\n  "audio/evrc0": {\n    "source": "iana"\n  },\n  "audio/evrc1": {\n    "source": "iana"\n  },\n  "audio/evrcb": {\n    "source": "iana"\n  },\n  "audio/evrcb0": {\n    "source": "iana"\n  },\n  "audio/evrcb1": {\n    "source": "iana"\n  },\n  "audio/evrcnw": {\n    "source": "iana"\n  },\n  "audio/evrcnw0": {\n    "source": "iana"\n  },\n  "audio/evrcnw1": {\n    "source": "iana"\n  },\n  "audio/evrcwb": {\n    "source": "iana"\n  },\n  "audio/evrcwb0": {\n    "source": "iana"\n  },\n  "audio/evrcwb1": {\n    "source": "iana"\n  },\n  "audio/evs": {\n    "source": "iana"\n  },\n  "audio/flexfec": {\n    "source": "iana"\n  },\n  "audio/fwdred": {\n    "source": "iana"\n  },\n  "audio/g711-0": {\n    "source": "iana"\n  },\n  "audio/g719": {\n    "source": "iana"\n  },\n  "audio/g722": {\n    "source": "iana"\n  },\n  "audio/g7221": {\n    "source": "iana"\n  },\n  "audio/g723": {\n    "source": "iana"\n  },\n  "audio/g726-16": {\n    "source": "iana"\n  },\n  "audio/g726-24": {\n    "source": "iana"\n  },\n  "audio/g726-32": {\n    "source": "iana"\n  },\n  "audio/g726-40": {\n    "source": "iana"\n  },\n  "audio/g728": {\n    "source": "iana"\n  },\n  "audio/g729": {\n    "source": "iana"\n  },\n  "audio/g7291": {\n    "source": "iana"\n  },\n  "audio/g729d": {\n    "source": "iana"\n  },\n  "audio/g729e": {\n    "source": "iana"\n  },\n  "audio/gsm": {\n    "source": "iana"\n  },\n  "audio/gsm-efr": {\n    "source": "iana"\n  },\n  "audio/gsm-hr-08": {\n    "source": "iana"\n  },\n  "audio/ilbc": {\n    "source": "iana"\n  },\n  "audio/ip-mr_v2.5": {\n    "source": "iana"\n  },\n  "audio/isac": {\n    "source": "apache"\n  },\n  "audio/l16": {\n    "source": "iana"\n  },\n  "audio/l20": {\n    "source": "iana"\n  },\n  "audio/l24": {\n    "source": "iana",\n    "compressible": false\n  },\n  "audio/l8": {\n    "source": "iana"\n  },\n  "audio/lpc": {\n    "source": "iana"\n  },\n  "audio/melp": {\n    "source": "iana"\n  },\n  "audio/melp1200": {\n    "source": "iana"\n  },\n  "audio/melp2400": {\n    "source": "iana"\n  },\n  "audio/melp600": {\n    "source": "iana"\n  },\n  "audio/mhas": {\n    "source": "iana"\n  },\n  "audio/midi": {\n    "source": "apache",\n    "extensions": ["mid","midi","kar","rmi"]\n  },\n  "audio/mobile-xmf": {\n    "source": "iana",\n    "extensions": ["mxmf"]\n  },\n  "audio/mp3": {\n    "compressible": false,\n    "extensions": ["mp3"]\n  },\n  "audio/mp4": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["m4a","mp4a"]\n  },\n  "audio/mp4a-latm": {\n    "source": "iana"\n  },\n  "audio/mpa": {\n    "source": "iana"\n  },\n  "audio/mpa-robust": {\n    "source": "iana"\n  },\n  "audio/mpeg": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["mpga","mp2","mp2a","mp3","m2a","m3a"]\n  },\n  "audio/mpeg4-generic": {\n    "source": "iana"\n  },\n  "audio/musepack": {\n    "source": "apache"\n  },\n  "audio/ogg": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["oga","ogg","spx","opus"]\n  },\n  "audio/opus": {\n    "source": "iana"\n  },\n  "audio/parityfec": {\n    "source": "iana"\n  },\n  "audio/pcma": {\n    "source": "iana"\n  },\n  "audio/pcma-wb": {\n    "source": "iana"\n  },\n  "audio/pcmu": {\n    "source": "iana"\n  },\n  "audio/pcmu-wb": {\n    "source": "iana"\n  },\n  "audio/prs.sid": {\n    "source": "iana"\n  },\n  "audio/qcelp": {\n    "source": "iana"\n  },\n  "audio/raptorfec": {\n    "source": "iana"\n  },\n  "audio/red": {\n    "source": "iana"\n  },\n  "audio/rtp-enc-aescm128": {\n    "source": "iana"\n  },\n  "audio/rtp-midi": {\n    "source": "iana"\n  },\n  "audio/rtploopback": {\n    "source": "iana"\n  },\n  "audio/rtx": {\n    "source": "iana"\n  },\n  "audio/s3m": {\n    "source": "apache",\n    "extensions": ["s3m"]\n  },\n  "audio/silk": {\n    "source": "apache",\n    "extensions": ["sil"]\n  },\n  "audio/smv": {\n    "source": "iana"\n  },\n  "audio/smv-qcp": {\n    "source": "iana"\n  },\n  "audio/smv0": {\n    "source": "iana"\n  },\n  "audio/sofa": {\n    "source": "iana"\n  },\n  "audio/sp-midi": {\n    "source": "iana"\n  },\n  "audio/speex": {\n    "source": "iana"\n  },\n  "audio/t140c": {\n    "source": "iana"\n  },\n  "audio/t38": {\n    "source": "iana"\n  },\n  "audio/telephone-event": {\n    "source": "iana"\n  },\n  "audio/tetra_acelp": {\n    "source": "iana"\n  },\n  "audio/tetra_acelp_bb": {\n    "source": "iana"\n  },\n  "audio/tone": {\n    "source": "iana"\n  },\n  "audio/tsvcis": {\n    "source": "iana"\n  },\n  "audio/uemclip": {\n    "source": "iana"\n  },\n  "audio/ulpfec": {\n    "source": "iana"\n  },\n  "audio/usac": {\n    "source": "iana"\n  },\n  "audio/vdvi": {\n    "source": "iana"\n  },\n  "audio/vmr-wb": {\n    "source": "iana"\n  },\n  "audio/vnd.3gpp.iufp": {\n    "source": "iana"\n  },\n  "audio/vnd.4sb": {\n    "source": "iana"\n  },\n  "audio/vnd.audiokoz": {\n    "source": "iana"\n  },\n  "audio/vnd.celp": {\n    "source": "iana"\n  },\n  "audio/vnd.cisco.nse": {\n    "source": "iana"\n  },\n  "audio/vnd.cmles.radio-events": {\n    "source": "iana"\n  },\n  "audio/vnd.cns.anp1": {\n    "source": "iana"\n  },\n  "audio/vnd.cns.inf1": {\n    "source": "iana"\n  },\n  "audio/vnd.dece.audio": {\n    "source": "iana",\n    "extensions": ["uva","uvva"]\n  },\n  "audio/vnd.digital-winds": {\n    "source": "iana",\n    "extensions": ["eol"]\n  },\n  "audio/vnd.dlna.adts": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.heaac.1": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.heaac.2": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.mlp": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.mps": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.pl2": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.pl2x": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.pl2z": {\n    "source": "iana"\n  },\n  "audio/vnd.dolby.pulse.1": {\n    "source": "iana"\n  },\n  "audio/vnd.dra": {\n    "source": "iana",\n    "extensions": ["dra"]\n  },\n  "audio/vnd.dts": {\n    "source": "iana",\n    "extensions": ["dts"]\n  },\n  "audio/vnd.dts.hd": {\n    "source": "iana",\n    "extensions": ["dtshd"]\n  },\n  "audio/vnd.dts.uhd": {\n    "source": "iana"\n  },\n  "audio/vnd.dvb.file": {\n    "source": "iana"\n  },\n  "audio/vnd.everad.plj": {\n    "source": "iana"\n  },\n  "audio/vnd.hns.audio": {\n    "source": "iana"\n  },\n  "audio/vnd.lucent.voice": {\n    "source": "iana",\n    "extensions": ["lvp"]\n  },\n  "audio/vnd.ms-playready.media.pya": {\n    "source": "iana",\n    "extensions": ["pya"]\n  },\n  "audio/vnd.nokia.mobile-xmf": {\n    "source": "iana"\n  },\n  "audio/vnd.nortel.vbk": {\n    "source": "iana"\n  },\n  "audio/vnd.nuera.ecelp4800": {\n    "source": "iana",\n    "extensions": ["ecelp4800"]\n  },\n  "audio/vnd.nuera.ecelp7470": {\n    "source": "iana",\n    "extensions": ["ecelp7470"]\n  },\n  "audio/vnd.nuera.ecelp9600": {\n    "source": "iana",\n    "extensions": ["ecelp9600"]\n  },\n  "audio/vnd.octel.sbc": {\n    "source": "iana"\n  },\n  "audio/vnd.presonus.multitrack": {\n    "source": "iana"\n  },\n  "audio/vnd.qcelp": {\n    "source": "iana"\n  },\n  "audio/vnd.rhetorex.32kadpcm": {\n    "source": "iana"\n  },\n  "audio/vnd.rip": {\n    "source": "iana",\n    "extensions": ["rip"]\n  },\n  "audio/vnd.rn-realaudio": {\n    "compressible": false\n  },\n  "audio/vnd.sealedmedia.softseal.mpeg": {\n    "source": "iana"\n  },\n  "audio/vnd.vmx.cvsd": {\n    "source": "iana"\n  },\n  "audio/vnd.wave": {\n    "compressible": false\n  },\n  "audio/vorbis": {\n    "source": "iana",\n    "compressible": false\n  },\n  "audio/vorbis-config": {\n    "source": "iana"\n  },\n  "audio/wav": {\n    "compressible": false,\n    "extensions": ["wav"]\n  },\n  "audio/wave": {\n    "compressible": false,\n    "extensions": ["wav"]\n  },\n  "audio/webm": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["weba"]\n  },\n  "audio/x-aac": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["aac"]\n  },\n  "audio/x-aiff": {\n    "source": "apache",\n    "extensions": ["aif","aiff","aifc"]\n  },\n  "audio/x-caf": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["caf"]\n  },\n  "audio/x-flac": {\n    "source": "apache",\n    "extensions": ["flac"]\n  },\n  "audio/x-m4a": {\n    "source": "nginx",\n    "extensions": ["m4a"]\n  },\n  "audio/x-matroska": {\n    "source": "apache",\n    "extensions": ["mka"]\n  },\n  "audio/x-mpegurl": {\n    "source": "apache",\n    "extensions": ["m3u"]\n  },\n  "audio/x-ms-wax": {\n    "source": "apache",\n    "extensions": ["wax"]\n  },\n  "audio/x-ms-wma": {\n    "source": "apache",\n    "extensions": ["wma"]\n  },\n  "audio/x-pn-realaudio": {\n    "source": "apache",\n    "extensions": ["ram","ra"]\n  },\n  "audio/x-pn-realaudio-plugin": {\n    "source": "apache",\n    "extensions": ["rmp"]\n  },\n  "audio/x-realaudio": {\n    "source": "nginx",\n    "extensions": ["ra"]\n  },\n  "audio/x-tta": {\n    "source": "apache"\n  },\n  "audio/x-wav": {\n    "source": "apache",\n    "extensions": ["wav"]\n  },\n  "audio/xm": {\n    "source": "apache",\n    "extensions": ["xm"]\n  },\n  "chemical/x-cdx": {\n    "source": "apache",\n    "extensions": ["cdx"]\n  },\n  "chemical/x-cif": {\n    "source": "apache",\n    "extensions": ["cif"]\n  },\n  "chemical/x-cmdf": {\n    "source": "apache",\n    "extensions": ["cmdf"]\n  },\n  "chemical/x-cml": {\n    "source": "apache",\n    "extensions": ["cml"]\n  },\n  "chemical/x-csml": {\n    "source": "apache",\n    "extensions": ["csml"]\n  },\n  "chemical/x-pdb": {\n    "source": "apache"\n  },\n  "chemical/x-xyz": {\n    "source": "apache",\n    "extensions": ["xyz"]\n  },\n  "font/collection": {\n    "source": "iana",\n    "extensions": ["ttc"]\n  },\n  "font/otf": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["otf"]\n  },\n  "font/sfnt": {\n    "source": "iana"\n  },\n  "font/ttf": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["ttf"]\n  },\n  "font/woff": {\n    "source": "iana",\n    "extensions": ["woff"]\n  },\n  "font/woff2": {\n    "source": "iana",\n    "extensions": ["woff2"]\n  },\n  "image/aces": {\n    "source": "iana",\n    "extensions": ["exr"]\n  },\n  "image/apng": {\n    "compressible": false,\n    "extensions": ["apng"]\n  },\n  "image/avci": {\n    "source": "iana"\n  },\n  "image/avcs": {\n    "source": "iana"\n  },\n  "image/avif": {\n    "compressible": false,\n    "extensions": ["avif"]\n  },\n  "image/bmp": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["bmp"]\n  },\n  "image/cgm": {\n    "source": "iana",\n    "extensions": ["cgm"]\n  },\n  "image/dicom-rle": {\n    "source": "iana",\n    "extensions": ["drle"]\n  },\n  "image/emf": {\n    "source": "iana",\n    "extensions": ["emf"]\n  },\n  "image/fits": {\n    "source": "iana",\n    "extensions": ["fits"]\n  },\n  "image/g3fax": {\n    "source": "iana",\n    "extensions": ["g3"]\n  },\n  "image/gif": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["gif"]\n  },\n  "image/heic": {\n    "source": "iana",\n    "extensions": ["heic"]\n  },\n  "image/heic-sequence": {\n    "source": "iana",\n    "extensions": ["heics"]\n  },\n  "image/heif": {\n    "source": "iana",\n    "extensions": ["heif"]\n  },\n  "image/heif-sequence": {\n    "source": "iana",\n    "extensions": ["heifs"]\n  },\n  "image/hej2k": {\n    "source": "iana",\n    "extensions": ["hej2"]\n  },\n  "image/hsj2": {\n    "source": "iana",\n    "extensions": ["hsj2"]\n  },\n  "image/ief": {\n    "source": "iana",\n    "extensions": ["ief"]\n  },\n  "image/jls": {\n    "source": "iana",\n    "extensions": ["jls"]\n  },\n  "image/jp2": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["jp2","jpg2"]\n  },\n  "image/jpeg": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["jpeg","jpg","jpe"]\n  },\n  "image/jph": {\n    "source": "iana",\n    "extensions": ["jph"]\n  },\n  "image/jphc": {\n    "source": "iana",\n    "extensions": ["jhc"]\n  },\n  "image/jpm": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["jpm"]\n  },\n  "image/jpx": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["jpx","jpf"]\n  },\n  "image/jxr": {\n    "source": "iana",\n    "extensions": ["jxr"]\n  },\n  "image/jxra": {\n    "source": "iana",\n    "extensions": ["jxra"]\n  },\n  "image/jxrs": {\n    "source": "iana",\n    "extensions": ["jxrs"]\n  },\n  "image/jxs": {\n    "source": "iana",\n    "extensions": ["jxs"]\n  },\n  "image/jxsc": {\n    "source": "iana",\n    "extensions": ["jxsc"]\n  },\n  "image/jxsi": {\n    "source": "iana",\n    "extensions": ["jxsi"]\n  },\n  "image/jxss": {\n    "source": "iana",\n    "extensions": ["jxss"]\n  },\n  "image/ktx": {\n    "source": "iana",\n    "extensions": ["ktx"]\n  },\n  "image/ktx2": {\n    "source": "iana",\n    "extensions": ["ktx2"]\n  },\n  "image/naplps": {\n    "source": "iana"\n  },\n  "image/pjpeg": {\n    "compressible": false\n  },\n  "image/png": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["png"]\n  },\n  "image/prs.btif": {\n    "source": "iana",\n    "extensions": ["btif"]\n  },\n  "image/prs.pti": {\n    "source": "iana",\n    "extensions": ["pti"]\n  },\n  "image/pwg-raster": {\n    "source": "iana"\n  },\n  "image/sgi": {\n    "source": "apache",\n    "extensions": ["sgi"]\n  },\n  "image/svg+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["svg","svgz"]\n  },\n  "image/t38": {\n    "source": "iana",\n    "extensions": ["t38"]\n  },\n  "image/tiff": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["tif","tiff"]\n  },\n  "image/tiff-fx": {\n    "source": "iana",\n    "extensions": ["tfx"]\n  },\n  "image/vnd.adobe.photoshop": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["psd"]\n  },\n  "image/vnd.airzip.accelerator.azv": {\n    "source": "iana",\n    "extensions": ["azv"]\n  },\n  "image/vnd.cns.inf2": {\n    "source": "iana"\n  },\n  "image/vnd.dece.graphic": {\n    "source": "iana",\n    "extensions": ["uvi","uvvi","uvg","uvvg"]\n  },\n  "image/vnd.djvu": {\n    "source": "iana",\n    "extensions": ["djvu","djv"]\n  },\n  "image/vnd.dvb.subtitle": {\n    "source": "iana",\n    "extensions": ["sub"]\n  },\n  "image/vnd.dwg": {\n    "source": "iana",\n    "extensions": ["dwg"]\n  },\n  "image/vnd.dxf": {\n    "source": "iana",\n    "extensions": ["dxf"]\n  },\n  "image/vnd.fastbidsheet": {\n    "source": "iana",\n    "extensions": ["fbs"]\n  },\n  "image/vnd.fpx": {\n    "source": "iana",\n    "extensions": ["fpx"]\n  },\n  "image/vnd.fst": {\n    "source": "iana",\n    "extensions": ["fst"]\n  },\n  "image/vnd.fujixerox.edmics-mmr": {\n    "source": "iana",\n    "extensions": ["mmr"]\n  },\n  "image/vnd.fujixerox.edmics-rlc": {\n    "source": "iana",\n    "extensions": ["rlc"]\n  },\n  "image/vnd.globalgraphics.pgb": {\n    "source": "iana"\n  },\n  "image/vnd.microsoft.icon": {\n    "source": "iana",\n    "extensions": ["ico"]\n  },\n  "image/vnd.mix": {\n    "source": "iana"\n  },\n  "image/vnd.mozilla.apng": {\n    "source": "iana"\n  },\n  "image/vnd.ms-dds": {\n    "extensions": ["dds"]\n  },\n  "image/vnd.ms-modi": {\n    "source": "iana",\n    "extensions": ["mdi"]\n  },\n  "image/vnd.ms-photo": {\n    "source": "apache",\n    "extensions": ["wdp"]\n  },\n  "image/vnd.net-fpx": {\n    "source": "iana",\n    "extensions": ["npx"]\n  },\n  "image/vnd.pco.b16": {\n    "source": "iana",\n    "extensions": ["b16"]\n  },\n  "image/vnd.radiance": {\n    "source": "iana"\n  },\n  "image/vnd.sealed.png": {\n    "source": "iana"\n  },\n  "image/vnd.sealedmedia.softseal.gif": {\n    "source": "iana"\n  },\n  "image/vnd.sealedmedia.softseal.jpg": {\n    "source": "iana"\n  },\n  "image/vnd.svf": {\n    "source": "iana"\n  },\n  "image/vnd.tencent.tap": {\n    "source": "iana",\n    "extensions": ["tap"]\n  },\n  "image/vnd.valve.source.texture": {\n    "source": "iana",\n    "extensions": ["vtf"]\n  },\n  "image/vnd.wap.wbmp": {\n    "source": "iana",\n    "extensions": ["wbmp"]\n  },\n  "image/vnd.xiff": {\n    "source": "iana",\n    "extensions": ["xif"]\n  },\n  "image/vnd.zbrush.pcx": {\n    "source": "iana",\n    "extensions": ["pcx"]\n  },\n  "image/webp": {\n    "source": "apache",\n    "extensions": ["webp"]\n  },\n  "image/wmf": {\n    "source": "iana",\n    "extensions": ["wmf"]\n  },\n  "image/x-3ds": {\n    "source": "apache",\n    "extensions": ["3ds"]\n  },\n  "image/x-cmu-raster": {\n    "source": "apache",\n    "extensions": ["ras"]\n  },\n  "image/x-cmx": {\n    "source": "apache",\n    "extensions": ["cmx"]\n  },\n  "image/x-freehand": {\n    "source": "apache",\n    "extensions": ["fh","fhc","fh4","fh5","fh7"]\n  },\n  "image/x-icon": {\n    "source": "apache",\n    "compressible": true,\n    "extensions": ["ico"]\n  },\n  "image/x-jng": {\n    "source": "nginx",\n    "extensions": ["jng"]\n  },\n  "image/x-mrsid-image": {\n    "source": "apache",\n    "extensions": ["sid"]\n  },\n  "image/x-ms-bmp": {\n    "source": "nginx",\n    "compressible": true,\n    "extensions": ["bmp"]\n  },\n  "image/x-pcx": {\n    "source": "apache",\n    "extensions": ["pcx"]\n  },\n  "image/x-pict": {\n    "source": "apache",\n    "extensions": ["pic","pct"]\n  },\n  "image/x-portable-anymap": {\n    "source": "apache",\n    "extensions": ["pnm"]\n  },\n  "image/x-portable-bitmap": {\n    "source": "apache",\n    "extensions": ["pbm"]\n  },\n  "image/x-portable-graymap": {\n    "source": "apache",\n    "extensions": ["pgm"]\n  },\n  "image/x-portable-pixmap": {\n    "source": "apache",\n    "extensions": ["ppm"]\n  },\n  "image/x-rgb": {\n    "source": "apache",\n    "extensions": ["rgb"]\n  },\n  "image/x-tga": {\n    "source": "apache",\n    "extensions": ["tga"]\n  },\n  "image/x-xbitmap": {\n    "source": "apache",\n    "extensions": ["xbm"]\n  },\n  "image/x-xcf": {\n    "compressible": false\n  },\n  "image/x-xpixmap": {\n    "source": "apache",\n    "extensions": ["xpm"]\n  },\n  "image/x-xwindowdump": {\n    "source": "apache",\n    "extensions": ["xwd"]\n  },\n  "message/cpim": {\n    "source": "iana"\n  },\n  "message/delivery-status": {\n    "source": "iana"\n  },\n  "message/disposition-notification": {\n    "source": "iana",\n    "extensions": [\n      "disposition-notification"\n    ]\n  },\n  "message/external-body": {\n    "source": "iana"\n  },\n  "message/feedback-report": {\n    "source": "iana"\n  },\n  "message/global": {\n    "source": "iana",\n    "extensions": ["u8msg"]\n  },\n  "message/global-delivery-status": {\n    "source": "iana",\n    "extensions": ["u8dsn"]\n  },\n  "message/global-disposition-notification": {\n    "source": "iana",\n    "extensions": ["u8mdn"]\n  },\n  "message/global-headers": {\n    "source": "iana",\n    "extensions": ["u8hdr"]\n  },\n  "message/http": {\n    "source": "iana",\n    "compressible": false\n  },\n  "message/imdn+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "message/news": {\n    "source": "iana"\n  },\n  "message/partial": {\n    "source": "iana",\n    "compressible": false\n  },\n  "message/rfc822": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["eml","mime"]\n  },\n  "message/s-http": {\n    "source": "iana"\n  },\n  "message/sip": {\n    "source": "iana"\n  },\n  "message/sipfrag": {\n    "source": "iana"\n  },\n  "message/tracking-status": {\n    "source": "iana"\n  },\n  "message/vnd.si.simp": {\n    "source": "iana"\n  },\n  "message/vnd.wfa.wsc": {\n    "source": "iana",\n    "extensions": ["wsc"]\n  },\n  "model/3mf": {\n    "source": "iana",\n    "extensions": ["3mf"]\n  },\n  "model/e57": {\n    "source": "iana"\n  },\n  "model/gltf+json": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["gltf"]\n  },\n  "model/gltf-binary": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["glb"]\n  },\n  "model/iges": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["igs","iges"]\n  },\n  "model/mesh": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["msh","mesh","silo"]\n  },\n  "model/mtl": {\n    "source": "iana",\n    "extensions": ["mtl"]\n  },\n  "model/obj": {\n    "source": "iana",\n    "extensions": ["obj"]\n  },\n  "model/stl": {\n    "source": "iana",\n    "extensions": ["stl"]\n  },\n  "model/vnd.collada+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["dae"]\n  },\n  "model/vnd.dwf": {\n    "source": "iana",\n    "extensions": ["dwf"]\n  },\n  "model/vnd.flatland.3dml": {\n    "source": "iana"\n  },\n  "model/vnd.gdl": {\n    "source": "iana",\n    "extensions": ["gdl"]\n  },\n  "model/vnd.gs-gdl": {\n    "source": "apache"\n  },\n  "model/vnd.gs.gdl": {\n    "source": "iana"\n  },\n  "model/vnd.gtw": {\n    "source": "iana",\n    "extensions": ["gtw"]\n  },\n  "model/vnd.moml+xml": {\n    "source": "iana",\n    "compressible": true\n  },\n  "model/vnd.mts": {\n    "source": "iana",\n    "extensions": ["mts"]\n  },\n  "model/vnd.opengex": {\n    "source": "iana",\n    "extensions": ["ogex"]\n  },\n  "model/vnd.parasolid.transmit.binary": {\n    "source": "iana",\n    "extensions": ["x_b"]\n  },\n  "model/vnd.parasolid.transmit.text": {\n    "source": "iana",\n    "extensions": ["x_t"]\n  },\n  "model/vnd.rosette.annotated-data-model": {\n    "source": "iana"\n  },\n  "model/vnd.usdz+zip": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["usdz"]\n  },\n  "model/vnd.valve.source.compiled-map": {\n    "source": "iana",\n    "extensions": ["bsp"]\n  },\n  "model/vnd.vtu": {\n    "source": "iana",\n    "extensions": ["vtu"]\n  },\n  "model/vrml": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["wrl","vrml"]\n  },\n  "model/x3d+binary": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["x3db","x3dbz"]\n  },\n  "model/x3d+fastinfoset": {\n    "source": "iana",\n    "extensions": ["x3db"]\n  },\n  "model/x3d+vrml": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["x3dv","x3dvz"]\n  },\n  "model/x3d+xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["x3d","x3dz"]\n  },\n  "model/x3d-vrml": {\n    "source": "iana",\n    "extensions": ["x3dv"]\n  },\n  "multipart/alternative": {\n    "source": "iana",\n    "compressible": false\n  },\n  "multipart/appledouble": {\n    "source": "iana"\n  },\n  "multipart/byteranges": {\n    "source": "iana"\n  },\n  "multipart/digest": {\n    "source": "iana"\n  },\n  "multipart/encrypted": {\n    "source": "iana",\n    "compressible": false\n  },\n  "multipart/form-data": {\n    "source": "iana",\n    "compressible": false\n  },\n  "multipart/header-set": {\n    "source": "iana"\n  },\n  "multipart/mixed": {\n    "source": "iana"\n  },\n  "multipart/multilingual": {\n    "source": "iana"\n  },\n  "multipart/parallel": {\n    "source": "iana"\n  },\n  "multipart/related": {\n    "source": "iana",\n    "compressible": false\n  },\n  "multipart/report": {\n    "source": "iana"\n  },\n  "multipart/signed": {\n    "source": "iana",\n    "compressible": false\n  },\n  "multipart/vnd.bint.med-plus": {\n    "source": "iana"\n  },\n  "multipart/voice-message": {\n    "source": "iana"\n  },\n  "multipart/x-mixed-replace": {\n    "source": "iana"\n  },\n  "text/1d-interleaved-parityfec": {\n    "source": "iana"\n  },\n  "text/cache-manifest": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["appcache","manifest"]\n  },\n  "text/calendar": {\n    "source": "iana",\n    "extensions": ["ics","ifb"]\n  },\n  "text/calender": {\n    "compressible": true\n  },\n  "text/cmd": {\n    "compressible": true\n  },\n  "text/coffeescript": {\n    "extensions": ["coffee","litcoffee"]\n  },\n  "text/cql": {\n    "source": "iana"\n  },\n  "text/cql-expression": {\n    "source": "iana"\n  },\n  "text/cql-identifier": {\n    "source": "iana"\n  },\n  "text/css": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["css"]\n  },\n  "text/csv": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["csv"]\n  },\n  "text/csv-schema": {\n    "source": "iana"\n  },\n  "text/directory": {\n    "source": "iana"\n  },\n  "text/dns": {\n    "source": "iana"\n  },\n  "text/ecmascript": {\n    "source": "iana"\n  },\n  "text/encaprtp": {\n    "source": "iana"\n  },\n  "text/enriched": {\n    "source": "iana"\n  },\n  "text/fhirpath": {\n    "source": "iana"\n  },\n  "text/flexfec": {\n    "source": "iana"\n  },\n  "text/fwdred": {\n    "source": "iana"\n  },\n  "text/gff3": {\n    "source": "iana"\n  },\n  "text/grammar-ref-list": {\n    "source": "iana"\n  },\n  "text/html": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["html","htm","shtml"]\n  },\n  "text/jade": {\n    "extensions": ["jade"]\n  },\n  "text/javascript": {\n    "source": "iana",\n    "compressible": true\n  },\n  "text/jcr-cnd": {\n    "source": "iana"\n  },\n  "text/jsx": {\n    "compressible": true,\n    "extensions": ["jsx"]\n  },\n  "text/less": {\n    "compressible": true,\n    "extensions": ["less"]\n  },\n  "text/markdown": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["markdown","md"]\n  },\n  "text/mathml": {\n    "source": "nginx",\n    "extensions": ["mml"]\n  },\n  "text/mdx": {\n    "compressible": true,\n    "extensions": ["mdx"]\n  },\n  "text/mizar": {\n    "source": "iana"\n  },\n  "text/n3": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["n3"]\n  },\n  "text/parameters": {\n    "source": "iana",\n    "charset": "UTF-8"\n  },\n  "text/parityfec": {\n    "source": "iana"\n  },\n  "text/plain": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["txt","text","conf","def","list","log","in","ini"]\n  },\n  "text/provenance-notation": {\n    "source": "iana",\n    "charset": "UTF-8"\n  },\n  "text/prs.fallenstein.rst": {\n    "source": "iana"\n  },\n  "text/prs.lines.tag": {\n    "source": "iana",\n    "extensions": ["dsc"]\n  },\n  "text/prs.prop.logic": {\n    "source": "iana"\n  },\n  "text/raptorfec": {\n    "source": "iana"\n  },\n  "text/red": {\n    "source": "iana"\n  },\n  "text/rfc822-headers": {\n    "source": "iana"\n  },\n  "text/richtext": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rtx"]\n  },\n  "text/rtf": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["rtf"]\n  },\n  "text/rtp-enc-aescm128": {\n    "source": "iana"\n  },\n  "text/rtploopback": {\n    "source": "iana"\n  },\n  "text/rtx": {\n    "source": "iana"\n  },\n  "text/sgml": {\n    "source": "iana",\n    "extensions": ["sgml","sgm"]\n  },\n  "text/shaclc": {\n    "source": "iana"\n  },\n  "text/shex": {\n    "extensions": ["shex"]\n  },\n  "text/slim": {\n    "extensions": ["slim","slm"]\n  },\n  "text/spdx": {\n    "source": "iana",\n    "extensions": ["spdx"]\n  },\n  "text/strings": {\n    "source": "iana"\n  },\n  "text/stylus": {\n    "extensions": ["stylus","styl"]\n  },\n  "text/t140": {\n    "source": "iana"\n  },\n  "text/tab-separated-values": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["tsv"]\n  },\n  "text/troff": {\n    "source": "iana",\n    "extensions": ["t","tr","roff","man","me","ms"]\n  },\n  "text/turtle": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "extensions": ["ttl"]\n  },\n  "text/ulpfec": {\n    "source": "iana"\n  },\n  "text/uri-list": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["uri","uris","urls"]\n  },\n  "text/vcard": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["vcard"]\n  },\n  "text/vnd.a": {\n    "source": "iana"\n  },\n  "text/vnd.abc": {\n    "source": "iana"\n  },\n  "text/vnd.ascii-art": {\n    "source": "iana"\n  },\n  "text/vnd.curl": {\n    "source": "iana",\n    "extensions": ["curl"]\n  },\n  "text/vnd.curl.dcurl": {\n    "source": "apache",\n    "extensions": ["dcurl"]\n  },\n  "text/vnd.curl.mcurl": {\n    "source": "apache",\n    "extensions": ["mcurl"]\n  },\n  "text/vnd.curl.scurl": {\n    "source": "apache",\n    "extensions": ["scurl"]\n  },\n  "text/vnd.debian.copyright": {\n    "source": "iana",\n    "charset": "UTF-8"\n  },\n  "text/vnd.dmclientscript": {\n    "source": "iana"\n  },\n  "text/vnd.dvb.subtitle": {\n    "source": "iana",\n    "extensions": ["sub"]\n  },\n  "text/vnd.esmertec.theme-descriptor": {\n    "source": "iana",\n    "charset": "UTF-8"\n  },\n  "text/vnd.ficlab.flt": {\n    "source": "iana"\n  },\n  "text/vnd.fly": {\n    "source": "iana",\n    "extensions": ["fly"]\n  },\n  "text/vnd.fmi.flexstor": {\n    "source": "iana",\n    "extensions": ["flx"]\n  },\n  "text/vnd.gml": {\n    "source": "iana"\n  },\n  "text/vnd.graphviz": {\n    "source": "iana",\n    "extensions": ["gv"]\n  },\n  "text/vnd.hans": {\n    "source": "iana"\n  },\n  "text/vnd.hgl": {\n    "source": "iana"\n  },\n  "text/vnd.in3d.3dml": {\n    "source": "iana",\n    "extensions": ["3dml"]\n  },\n  "text/vnd.in3d.spot": {\n    "source": "iana",\n    "extensions": ["spot"]\n  },\n  "text/vnd.iptc.newsml": {\n    "source": "iana"\n  },\n  "text/vnd.iptc.nitf": {\n    "source": "iana"\n  },\n  "text/vnd.latex-z": {\n    "source": "iana"\n  },\n  "text/vnd.motorola.reflex": {\n    "source": "iana"\n  },\n  "text/vnd.ms-mediapackage": {\n    "source": "iana"\n  },\n  "text/vnd.net2phone.commcenter.command": {\n    "source": "iana"\n  },\n  "text/vnd.radisys.msml-basic-layout": {\n    "source": "iana"\n  },\n  "text/vnd.senx.warpscript": {\n    "source": "iana"\n  },\n  "text/vnd.si.uricatalogue": {\n    "source": "iana"\n  },\n  "text/vnd.sosi": {\n    "source": "iana"\n  },\n  "text/vnd.sun.j2me.app-descriptor": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "extensions": ["jad"]\n  },\n  "text/vnd.trolltech.linguist": {\n    "source": "iana",\n    "charset": "UTF-8"\n  },\n  "text/vnd.wap.si": {\n    "source": "iana"\n  },\n  "text/vnd.wap.sl": {\n    "source": "iana"\n  },\n  "text/vnd.wap.wml": {\n    "source": "iana",\n    "extensions": ["wml"]\n  },\n  "text/vnd.wap.wmlscript": {\n    "source": "iana",\n    "extensions": ["wmls"]\n  },\n  "text/vtt": {\n    "source": "iana",\n    "charset": "UTF-8",\n    "compressible": true,\n    "extensions": ["vtt"]\n  },\n  "text/x-asm": {\n    "source": "apache",\n    "extensions": ["s","asm"]\n  },\n  "text/x-c": {\n    "source": "apache",\n    "extensions": ["c","cc","cxx","cpp","h","hh","dic"]\n  },\n  "text/x-component": {\n    "source": "nginx",\n    "extensions": ["htc"]\n  },\n  "text/x-fortran": {\n    "source": "apache",\n    "extensions": ["f","for","f77","f90"]\n  },\n  "text/x-gwt-rpc": {\n    "compressible": true\n  },\n  "text/x-handlebars-template": {\n    "extensions": ["hbs"]\n  },\n  "text/x-java-source": {\n    "source": "apache",\n    "extensions": ["java"]\n  },\n  "text/x-jquery-tmpl": {\n    "compressible": true\n  },\n  "text/x-lua": {\n    "extensions": ["lua"]\n  },\n  "text/x-markdown": {\n    "compressible": true,\n    "extensions": ["mkd"]\n  },\n  "text/x-nfo": {\n    "source": "apache",\n    "extensions": ["nfo"]\n  },\n  "text/x-opml": {\n    "source": "apache",\n    "extensions": ["opml"]\n  },\n  "text/x-org": {\n    "compressible": true,\n    "extensions": ["org"]\n  },\n  "text/x-pascal": {\n    "source": "apache",\n    "extensions": ["p","pas"]\n  },\n  "text/x-processing": {\n    "compressible": true,\n    "extensions": ["pde"]\n  },\n  "text/x-sass": {\n    "extensions": ["sass"]\n  },\n  "text/x-scss": {\n    "extensions": ["scss"]\n  },\n  "text/x-setext": {\n    "source": "apache",\n    "extensions": ["etx"]\n  },\n  "text/x-sfv": {\n    "source": "apache",\n    "extensions": ["sfv"]\n  },\n  "text/x-suse-ymp": {\n    "compressible": true,\n    "extensions": ["ymp"]\n  },\n  "text/x-uuencode": {\n    "source": "apache",\n    "extensions": ["uu"]\n  },\n  "text/x-vcalendar": {\n    "source": "apache",\n    "extensions": ["vcs"]\n  },\n  "text/x-vcard": {\n    "source": "apache",\n    "extensions": ["vcf"]\n  },\n  "text/xml": {\n    "source": "iana",\n    "compressible": true,\n    "extensions": ["xml"]\n  },\n  "text/xml-external-parsed-entity": {\n    "source": "iana"\n  },\n  "text/yaml": {\n    "extensions": ["yaml","yml"]\n  },\n  "video/1d-interleaved-parityfec": {\n    "source": "iana"\n  },\n  "video/3gpp": {\n    "source": "iana",\n    "extensions": ["3gp","3gpp"]\n  },\n  "video/3gpp-tt": {\n    "source": "iana"\n  },\n  "video/3gpp2": {\n    "source": "iana",\n    "extensions": ["3g2"]\n  },\n  "video/bmpeg": {\n    "source": "iana"\n  },\n  "video/bt656": {\n    "source": "iana"\n  },\n  "video/celb": {\n    "source": "iana"\n  },\n  "video/dv": {\n    "source": "iana"\n  },\n  "video/encaprtp": {\n    "source": "iana"\n  },\n  "video/flexfec": {\n    "source": "iana"\n  },\n  "video/h261": {\n    "source": "iana",\n    "extensions": ["h261"]\n  },\n  "video/h263": {\n    "source": "iana",\n    "extensions": ["h263"]\n  },\n  "video/h263-1998": {\n    "source": "iana"\n  },\n  "video/h263-2000": {\n    "source": "iana"\n  },\n  "video/h264": {\n    "source": "iana",\n    "extensions": ["h264"]\n  },\n  "video/h264-rcdo": {\n    "source": "iana"\n  },\n  "video/h264-svc": {\n    "source": "iana"\n  },\n  "video/h265": {\n    "source": "iana"\n  },\n  "video/iso.segment": {\n    "source": "iana"\n  },\n  "video/jpeg": {\n    "source": "iana",\n    "extensions": ["jpgv"]\n  },\n  "video/jpeg2000": {\n    "source": "iana"\n  },\n  "video/jpm": {\n    "source": "apache",\n    "extensions": ["jpm","jpgm"]\n  },\n  "video/mj2": {\n    "source": "iana",\n    "extensions": ["mj2","mjp2"]\n  },\n  "video/mp1s": {\n    "source": "iana"\n  },\n  "video/mp2p": {\n    "source": "iana"\n  },\n  "video/mp2t": {\n    "source": "iana",\n    "extensions": ["ts"]\n  },\n  "video/mp4": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["mp4","mp4v","mpg4"]\n  },\n  "video/mp4v-es": {\n    "source": "iana"\n  },\n  "video/mpeg": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["mpeg","mpg","mpe","m1v","m2v"]\n  },\n  "video/mpeg4-generic": {\n    "source": "iana"\n  },\n  "video/mpv": {\n    "source": "iana"\n  },\n  "video/nv": {\n    "source": "iana"\n  },\n  "video/ogg": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["ogv"]\n  },\n  "video/parityfec": {\n    "source": "iana"\n  },\n  "video/pointer": {\n    "source": "iana"\n  },\n  "video/quicktime": {\n    "source": "iana",\n    "compressible": false,\n    "extensions": ["qt","mov"]\n  },\n  "video/raptorfec": {\n    "source": "iana"\n  },\n  "video/raw": {\n    "source": "iana"\n  },\n  "video/rtp-enc-aescm128": {\n    "source": "iana"\n  },\n  "video/rtploopback": {\n    "source": "iana"\n  },\n  "video/rtx": {\n    "source": "iana"\n  },\n  "video/smpte291": {\n    "source": "iana"\n  },\n  "video/smpte292m": {\n    "source": "iana"\n  },\n  "video/ulpfec": {\n    "source": "iana"\n  },\n  "video/vc1": {\n    "source": "iana"\n  },\n  "video/vc2": {\n    "source": "iana"\n  },\n  "video/vnd.cctv": {\n    "source": "iana"\n  },\n  "video/vnd.dece.hd": {\n    "source": "iana",\n    "extensions": ["uvh","uvvh"]\n  },\n  "video/vnd.dece.mobile": {\n    "source": "iana",\n    "extensions": ["uvm","uvvm"]\n  },\n  "video/vnd.dece.mp4": {\n    "source": "iana"\n  },\n  "video/vnd.dece.pd": {\n    "source": "iana",\n    "extensions": ["uvp","uvvp"]\n  },\n  "video/vnd.dece.sd": {\n    "source": "iana",\n    "extensions": ["uvs","uvvs"]\n  },\n  "video/vnd.dece.video": {\n    "source": "iana",\n    "extensions": ["uvv","uvvv"]\n  },\n  "video/vnd.directv.mpeg": {\n    "source": "iana"\n  },\n  "video/vnd.directv.mpeg-tts": {\n    "source": "iana"\n  },\n  "video/vnd.dlna.mpeg-tts": {\n    "source": "iana"\n  },\n  "video/vnd.dvb.file": {\n    "source": "iana",\n    "extensions": ["dvb"]\n  },\n  "video/vnd.fvt": {\n    "source": "iana",\n    "extensions": ["fvt"]\n  },\n  "video/vnd.hns.video": {\n    "source": "iana"\n  },\n  "video/vnd.iptvforum.1dparityfec-1010": {\n    "source": "iana"\n  },\n  "video/vnd.iptvforum.1dparityfec-2005": {\n    "source": "iana"\n  },\n  "video/vnd.iptvforum.2dparityfec-1010": {\n    "source": "iana"\n  },\n  "video/vnd.iptvforum.2dparityfec-2005": {\n    "source": "iana"\n  },\n  "video/vnd.iptvforum.ttsavc": {\n    "source": "iana"\n  },\n  "video/vnd.iptvforum.ttsmpeg2": {\n    "source": "iana"\n  },\n  "video/vnd.motorola.video": {\n    "source": "iana"\n  },\n  "video/vnd.motorola.videop": {\n    "source": "iana"\n  },\n  "video/vnd.mpegurl": {\n    "source": "iana",\n    "extensions": ["mxu","m4u"]\n  },\n  "video/vnd.ms-playready.media.pyv": {\n    "source": "iana",\n    "extensions": ["pyv"]\n  },\n  "video/vnd.nokia.interleaved-multimedia": {\n    "source": "iana"\n  },\n  "video/vnd.nokia.mp4vr": {\n    "source": "iana"\n  },\n  "video/vnd.nokia.videovoip": {\n    "source": "iana"\n  },\n  "video/vnd.objectvideo": {\n    "source": "iana"\n  },\n  "video/vnd.radgamettools.bink": {\n    "source": "iana"\n  },\n  "video/vnd.radgamettools.smacker": {\n    "source": "iana"\n  },\n  "video/vnd.sealed.mpeg1": {\n    "source": "iana"\n  },\n  "video/vnd.sealed.mpeg4": {\n    "source": "iana"\n  },\n  "video/vnd.sealed.swf": {\n    "source": "iana"\n  },\n  "video/vnd.sealedmedia.softseal.mov": {\n    "source": "iana"\n  },\n  "video/vnd.uvvu.mp4": {\n    "source": "iana",\n    "extensions": ["uvu","uvvu"]\n  },\n  "video/vnd.vivo": {\n    "source": "iana",\n    "extensions": ["viv"]\n  },\n  "video/vnd.youtube.yt": {\n    "source": "iana"\n  },\n  "video/vp8": {\n    "source": "iana"\n  },\n  "video/webm": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["webm"]\n  },\n  "video/x-f4v": {\n    "source": "apache",\n    "extensions": ["f4v"]\n  },\n  "video/x-fli": {\n    "source": "apache",\n    "extensions": ["fli"]\n  },\n  "video/x-flv": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["flv"]\n  },\n  "video/x-m4v": {\n    "source": "apache",\n    "extensions": ["m4v"]\n  },\n  "video/x-matroska": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["mkv","mk3d","mks"]\n  },\n  "video/x-mng": {\n    "source": "apache",\n    "extensions": ["mng"]\n  },\n  "video/x-ms-asf": {\n    "source": "apache",\n    "extensions": ["asf","asx"]\n  },\n  "video/x-ms-vob": {\n    "source": "apache",\n    "extensions": ["vob"]\n  },\n  "video/x-ms-wm": {\n    "source": "apache",\n    "extensions": ["wm"]\n  },\n  "video/x-ms-wmv": {\n    "source": "apache",\n    "compressible": false,\n    "extensions": ["wmv"]\n  },\n  "video/x-ms-wmx": {\n    "source": "apache",\n    "extensions": ["wmx"]\n  },\n  "video/x-ms-wvx": {\n    "source": "apache",\n    "extensions": ["wvx"]\n  },\n  "video/x-msvideo": {\n    "source": "apache",\n    "extensions": ["avi"]\n  },\n  "video/x-sgi-movie": {\n    "source": "apache",\n    "extensions": ["movie"]\n  },\n  "video/x-smv": {\n    "source": "apache",\n    "extensions": ["smv"]\n  },\n  "x-conference/x-cooltalk": {\n    "source": "apache",\n    "extensions": ["ice"]\n  },\n  "x-shader/x-fragment": {\n    "compressible": true\n  },\n  "x-shader/x-vertex": {\n    "compressible": true\n  }\n}`);
const osType = (()=>{
    if (globalThis.Deno != null) {
        return Deno.build.os;
    }
    const navigator3 = globalThis.navigator;
    if (navigator3?.appVersion?.includes?.("Win") ?? false) {
        return "windows";
    }
    return "linux";
})();
const isWindows3 = osType === "windows";
const CHAR_FORWARD_SLASH3 = 47;
function assertPath3(path3) {
    if (typeof path3 !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path3)}`);
    }
}
function isPosixPathSeparator3(code1) {
    return code1 === 47;
}
function isPathSeparator3(code1) {
    return isPosixPathSeparator3(code1) || code1 === 92;
}
function isWindowsDeviceRoot3(code1) {
    return code1 >= 97 && code1 <= 122 || code1 >= 65 && code1 <= 90;
}
function normalizeString3(path3, allowAboveRoot, separator, isPathSeparator4) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code1;
    for(let i4 = 0, len = path3.length; i4 <= len; ++i4){
        if (i4 < len) code1 = path3.charCodeAt(i4);
        else if (isPathSeparator4(code1)) break;
        else code1 = CHAR_FORWARD_SLASH3;
        if (isPathSeparator4(code1)) {
            if (lastSlash === i4 - 1 || dots === 1) {
            } else if (lastSlash !== i4 - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i4;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i4;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path3.slice(lastSlash + 1, i4);
                else res = path3.slice(lastSlash + 1, i4);
                lastSegmentLength = i4 - lastSlash - 1;
            }
            lastSlash = i4;
            dots = 0;
        } else if (code1 === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format3(sep9, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep9 + base;
}
class DenoStdInternalError3 extends Error {
    constructor(message5){
        super(message5);
        this.name = "DenoStdInternalError";
    }
}
function assert4(expr, msg1 = "") {
    if (!expr) {
        throw new DenoStdInternalError3(msg1);
    }
}
const sep9 = "\\";
const delimiter9 = ";";
function resolve10(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i4 = pathSegments.length - 1; i4 >= -1; i4--){
        let path3;
        if (i4 >= 0) {
            path3 = pathSegments[i4];
        } else if (!resolvedDevice) {
            if (globalThis.Deno == null) {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path3 = Deno.cwd();
        } else {
            if (globalThis.Deno == null) {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path3 = Deno.env.get(`=${resolvedDevice}`) || Deno.cwd();
            if (path3 === undefined || path3.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path3 = `${resolvedDevice}\\`;
            }
        }
        assertPath3(path3);
        const len = path3.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute9 = false;
        const code1 = path3.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator3(code1)) {
                isAbsolute9 = true;
                if (isPathSeparator3(path3.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator3(path3.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path3.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator3(path3.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator3(path3.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path3.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path3.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot3(code1)) {
                if (path3.charCodeAt(1) === 58) {
                    device = path3.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator3(path3.charCodeAt(2))) {
                            isAbsolute9 = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator3(code1)) {
            rootEnd = 1;
            isAbsolute9 = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path3.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute9;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString3(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator3);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize9(path3) {
    assertPath3(path3);
    const len = path3.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute9 = false;
    const code1 = path3.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator3(code1)) {
            isAbsolute9 = true;
            if (isPathSeparator3(path3.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator3(path3.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path3.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator3(path3.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator3(path3.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path3.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path3.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot3(code1)) {
            if (path3.charCodeAt(1) === 58) {
                device = path3.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator3(path3.charCodeAt(2))) {
                        isAbsolute9 = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator3(code1)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString3(path3.slice(rootEnd), !isAbsolute9, "\\", isPathSeparator3);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute9) tail = ".";
    if (tail.length > 0 && isPathSeparator3(path3.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute9) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute9) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute9(path3) {
    assertPath3(path3);
    const len = path3.length;
    if (len === 0) return false;
    const code1 = path3.charCodeAt(0);
    if (isPathSeparator3(code1)) {
        return true;
    } else if (isWindowsDeviceRoot3(code1)) {
        if (len > 2 && path3.charCodeAt(1) === 58) {
            if (isPathSeparator3(path3.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join9(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i4 = 0; i4 < pathsCount; ++i4){
        const path3 = paths[i4];
        assertPath3(path3);
        if (path3.length > 0) {
            if (joined === undefined) joined = firstPart = path3;
            else joined += `\\${path3}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert4(firstPart != null);
    if (isPathSeparator3(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator3(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator3(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator3(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize9(joined);
}
function relative9(from2, to) {
    assertPath3(from2);
    assertPath3(to);
    if (from2 === to) return "";
    const fromOrig = resolve10(from2);
    const toOrig = resolve10(to);
    if (fromOrig === toOrig) return "";
    from2 = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from2 === to) return "";
    let fromStart = 0;
    let fromEnd = from2.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from2.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from2.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i4 = 0;
    for(; i4 <= length; ++i4){
        if (i4 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i4) === 92) {
                    return toOrig.slice(toStart + i4 + 1);
                } else if (i4 === 2) {
                    return toOrig.slice(toStart + i4);
                }
            }
            if (fromLen > length) {
                if (from2.charCodeAt(fromStart + i4) === 92) {
                    lastCommonSep = i4;
                } else if (i4 === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from2.charCodeAt(fromStart + i4);
        const toCode = to.charCodeAt(toStart + i4);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i4;
    }
    if (i4 !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i4 = fromStart + lastCommonSep + 1; i4 <= fromEnd; ++i4){
        if (i4 === fromEnd || from2.charCodeAt(i4) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath9(path3) {
    if (typeof path3 !== "string") return path3;
    if (path3.length === 0) return "";
    const resolvedPath = resolve10(path3);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code1 = resolvedPath.charCodeAt(2);
                if (code1 !== 63 && code1 !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot3(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path3;
}
function dirname9(path3) {
    assertPath3(path3);
    const len = path3.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code1 = path3.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator3(code1)) {
            rootEnd = offset = 1;
            if (isPathSeparator3(path3.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator3(path3.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator3(path3.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator3(path3.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path3;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot3(code1)) {
            if (path3.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator3(path3.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator3(code1)) {
        return path3;
    }
    for(let i4 = len - 1; i4 >= offset; --i4){
        if (isPathSeparator3(path3.charCodeAt(i4))) {
            if (!matchedSlash) {
                end = i4;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path3.slice(0, end);
}
function basename9(path3, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath3(path3);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i4;
    if (path3.length >= 2) {
        const drive = path3.charCodeAt(0);
        if (isWindowsDeviceRoot3(drive)) {
            if (path3.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path3.length) {
        if (ext.length === path3.length && ext === path3) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i4 = path3.length - 1; i4 >= start; --i4){
            const code1 = path3.charCodeAt(i4);
            if (isPathSeparator3(code1)) {
                if (!matchedSlash) {
                    start = i4 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i4 + 1;
                }
                if (extIdx >= 0) {
                    if (code1 === ext.charCodeAt(extIdx)) {
                        if ((--extIdx) === -1) {
                            end = i4;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path3.length;
        return path3.slice(start, end);
    } else {
        for(i4 = path3.length - 1; i4 >= start; --i4){
            if (isPathSeparator3(path3.charCodeAt(i4))) {
                if (!matchedSlash) {
                    start = i4 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i4 + 1;
            }
        }
        if (end === -1) return "";
        return path3.slice(start, end);
    }
}
function extname9(path3) {
    assertPath3(path3);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path3.length >= 2 && path3.charCodeAt(1) === 58 && isWindowsDeviceRoot3(path3.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i4 = path3.length - 1; i4 >= start; --i4){
        const code1 = path3.charCodeAt(i4);
        if (isPathSeparator3(code1)) {
            if (!matchedSlash) {
                startPart = i4 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i4 + 1;
        }
        if (code1 === 46) {
            if (startDot === -1) startDot = i4;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path3.slice(startDot, end);
}
function format9(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format3("\\", pathObject);
}
function parse10(path3) {
    assertPath3(path3);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path3.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code1 = path3.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator3(code1)) {
            rootEnd = 1;
            if (isPathSeparator3(path3.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator3(path3.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator3(path3.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator3(path3.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot3(code1)) {
            if (path3.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator3(path3.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path3;
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path3;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator3(code1)) {
        ret.root = ret.dir = path3;
        return ret;
    }
    if (rootEnd > 0) ret.root = path3.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i4 = path3.length - 1;
    let preDotState = 0;
    for(; i4 >= rootEnd; --i4){
        code1 = path3.charCodeAt(i4);
        if (isPathSeparator3(code1)) {
            if (!matchedSlash) {
                startPart = i4 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i4 + 1;
        }
        if (code1 === 46) {
            if (startDot === -1) startDot = i4;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path3.slice(startPart, end);
        }
    } else {
        ret.name = path3.slice(startPart, startDot);
        ret.base = path3.slice(startPart, end);
        ret.ext = path3.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path3.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl9(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path3 = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path3 = `\\\\${url.hostname}${path3}`;
    }
    return path3;
}
function toFileUrl(path3) {
    if (!isAbsolute9(path3)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path3.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\][^/\\]))?(.*)/);
    const url = new URL("file:///");
    url.pathname = pathname.replace(/%/g, "%25");
    if (hostname != null) {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod6 = function() {
    return {
        sep: sep9,
        delimiter: delimiter9,
        resolve: resolve10,
        normalize: normalize9,
        isAbsolute: isAbsolute9,
        join: join9,
        relative: relative9,
        toNamespacedPath: toNamespacedPath9,
        dirname: dirname9,
        basename: basename9,
        extname: extname9,
        format: format9,
        parse: parse10,
        fromFileUrl: fromFileUrl9,
        toFileUrl: toFileUrl
    };
}();
const sep10 = "/";
const delimiter10 = ":";
function resolve11(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i4 = pathSegments.length - 1; i4 >= -1 && !resolvedAbsolute; i4--){
        let path3;
        if (i4 >= 0) path3 = pathSegments[i4];
        else {
            if (globalThis.Deno == null) {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path3 = Deno.cwd();
        }
        assertPath3(path3);
        if (path3.length === 0) {
            continue;
        }
        resolvedPath = `${path3}/${resolvedPath}`;
        resolvedAbsolute = path3.charCodeAt(0) === CHAR_FORWARD_SLASH3;
    }
    resolvedPath = normalizeString3(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator3);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize10(path3) {
    assertPath3(path3);
    if (path3.length === 0) return ".";
    const isAbsolute10 = path3.charCodeAt(0) === 47;
    const trailingSeparator = path3.charCodeAt(path3.length - 1) === 47;
    path3 = normalizeString3(path3, !isAbsolute10, "/", isPosixPathSeparator3);
    if (path3.length === 0 && !isAbsolute10) path3 = ".";
    if (path3.length > 0 && trailingSeparator) path3 += "/";
    if (isAbsolute10) return `/${path3}`;
    return path3;
}
function isAbsolute10(path3) {
    assertPath3(path3);
    return path3.length > 0 && path3.charCodeAt(0) === 47;
}
function join10(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i4 = 0, len = paths.length; i4 < len; ++i4){
        const path3 = paths[i4];
        assertPath3(path3);
        if (path3.length > 0) {
            if (!joined) joined = path3;
            else joined += `/${path3}`;
        }
    }
    if (!joined) return ".";
    return normalize10(joined);
}
function relative10(from2, to) {
    assertPath3(from2);
    assertPath3(to);
    if (from2 === to) return "";
    from2 = resolve11(from2);
    to = resolve11(to);
    if (from2 === to) return "";
    let fromStart = 1;
    const fromEnd = from2.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from2.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i4 = 0;
    for(; i4 <= length; ++i4){
        if (i4 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i4) === 47) {
                    return to.slice(toStart + i4 + 1);
                } else if (i4 === 0) {
                    return to.slice(toStart + i4);
                }
            } else if (fromLen > length) {
                if (from2.charCodeAt(fromStart + i4) === 47) {
                    lastCommonSep = i4;
                } else if (i4 === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from2.charCodeAt(fromStart + i4);
        const toCode = to.charCodeAt(toStart + i4);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i4;
    }
    let out = "";
    for(i4 = fromStart + lastCommonSep + 1; i4 <= fromEnd; ++i4){
        if (i4 === fromEnd || from2.charCodeAt(i4) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath10(path3) {
    return path3;
}
function dirname10(path3) {
    assertPath3(path3);
    if (path3.length === 0) return ".";
    const hasRoot = path3.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i4 = path3.length - 1; i4 >= 1; --i4){
        if (path3.charCodeAt(i4) === 47) {
            if (!matchedSlash) {
                end = i4;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path3.slice(0, end);
}
function basename10(path3, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath3(path3);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i4;
    if (ext !== undefined && ext.length > 0 && ext.length <= path3.length) {
        if (ext.length === path3.length && ext === path3) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i4 = path3.length - 1; i4 >= 0; --i4){
            const code1 = path3.charCodeAt(i4);
            if (code1 === 47) {
                if (!matchedSlash) {
                    start = i4 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i4 + 1;
                }
                if (extIdx >= 0) {
                    if (code1 === ext.charCodeAt(extIdx)) {
                        if ((--extIdx) === -1) {
                            end = i4;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path3.length;
        return path3.slice(start, end);
    } else {
        for(i4 = path3.length - 1; i4 >= 0; --i4){
            if (path3.charCodeAt(i4) === 47) {
                if (!matchedSlash) {
                    start = i4 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i4 + 1;
            }
        }
        if (end === -1) return "";
        return path3.slice(start, end);
    }
}
function extname10(path3) {
    assertPath3(path3);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i4 = path3.length - 1; i4 >= 0; --i4){
        const code1 = path3.charCodeAt(i4);
        if (code1 === 47) {
            if (!matchedSlash) {
                startPart = i4 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i4 + 1;
        }
        if (code1 === 46) {
            if (startDot === -1) startDot = i4;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path3.slice(startDot, end);
}
function format10(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format3("/", pathObject);
}
function parse11(path3) {
    assertPath3(path3);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path3.length === 0) return ret;
    const isAbsolute11 = path3.charCodeAt(0) === 47;
    let start;
    if (isAbsolute11) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i4 = path3.length - 1;
    let preDotState = 0;
    for(; i4 >= start; --i4){
        const code1 = path3.charCodeAt(i4);
        if (code1 === 47) {
            if (!matchedSlash) {
                startPart = i4 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i4 + 1;
        }
        if (code1 === 46) {
            if (startDot === -1) startDot = i4;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute11) {
                ret.base = ret.name = path3.slice(1, end);
            } else {
                ret.base = ret.name = path3.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute11) {
            ret.name = path3.slice(1, startDot);
            ret.base = path3.slice(1, end);
        } else {
            ret.name = path3.slice(startPart, startDot);
            ret.base = path3.slice(startPart, end);
        }
        ret.ext = path3.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path3.slice(0, startPart - 1);
    else if (isAbsolute11) ret.dir = "/";
    return ret;
}
function fromFileUrl10(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl1(path3) {
    if (!isAbsolute10(path3)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = path3.replace(/%/g, "%25").replace(/\\/g, "%5C");
    return url;
}
const mod7 = function() {
    return {
        sep: sep10,
        delimiter: delimiter10,
        resolve: resolve11,
        normalize: normalize10,
        isAbsolute: isAbsolute10,
        join: join10,
        relative: relative10,
        toNamespacedPath: toNamespacedPath10,
        dirname: dirname10,
        basename: basename10,
        extname: extname10,
        format: format10,
        parse: parse11,
        fromFileUrl: fromFileUrl10,
        toFileUrl: toFileUrl1
    };
}();
const path3 = isWindows3 ? mod6 : mod7;
const { basename: basename11 , delimiter: delimiter11 , dirname: dirname11 , extname: extname11 , format: format11 , fromFileUrl: fromFileUrl11 , isAbsolute: isAbsolute11 , join: join11 , normalize: normalize11 , parse: parse12 , relative: relative11 , resolve: resolve12 , sep: sep11 , toFileUrl: toFileUrl2 , toNamespacedPath: toNamespacedPath11 ,  } = path3;
const extensions2 = new Map();
const types3 = new Map();
function populateMaps2(extensions3, types4) {
    const preference = [
        "nginx",
        "apache",
        undefined,
        "iana"
    ];
    for (const type of Object.keys(db2)){
        const mime = db2[type];
        const exts = mime.extensions;
        if (!exts || !exts.length) {
            continue;
        }
        extensions3.set(type, exts);
        for (const ext of exts){
            const current = types4.get(ext);
            if (current) {
                const from2 = preference.indexOf(db2[current].source);
                const to = preference.indexOf(mime.source);
                if (current !== "application/octet-stream" && (from2 > to || from2 === to && current.substr(0, 12) === "application/")) {
                    continue;
                }
            }
            types4.set(ext, type);
        }
    }
}
populateMaps2(extensions2, types3);
function lookup2(path4) {
    const extension = extname11("x." + path4).toLowerCase().substr(1);
    return types3.get(extension);
}
class ContentTypeImpl {
    constructor(type2){
        this.type = type2;
        this.parameters = Object.create(null);
    }
}
const PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
const QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;
const TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
function parse13(str2) {
    let index = str2.indexOf(";");
    const type1 = index !== -1 ? str2.substr(0, index).trim() : str2.trim();
    if (!TYPE_REGEXP.test(type1)) {
        throw new TypeError("invalid media type");
    }
    const obj = new ContentTypeImpl(type1.toLowerCase());
    if (index !== -1) {
        let key;
        let match;
        let value2;
        PARAM_REGEXP.lastIndex = index;
        while(match = PARAM_REGEXP.exec(str2)){
            if (match.index !== index) {
                throw new TypeError("invalid parameter format");
            }
            index += match[0].length;
            key = match[1].toLowerCase();
            value2 = match[2];
            if (value2[0] === '"') {
                value2 = value2.substr(1, value2.length - 2).replace(QESC_REGEXP, "$1");
            }
            obj.parameters[key] = value2;
        }
        if (index !== str2.length) {
            throw new TypeError("invalid parameter format");
        }
    }
    return obj;
}
const TYPE_REGEXP1 = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
function test(string) {
    return TYPE_REGEXP1.test(string.toLowerCase());
}
class MediaTypeImpl {
    constructor(type1, subtype, suffix){
        this.type = type1;
        this.subtype = subtype;
        this.suffix = suffix;
    }
}
function is(mediaType, types4) {
    let i4;
    const val = tryNormalizeType(mediaType);
    if (!val) {
        return false;
    }
    if (!types4 || !types4.length) {
        return val;
    }
    let type2;
    for(i4 = 0; i4 < types4.length; i4++){
        const normalized = normalize13(type2 = types4[i4]);
        if (normalized && mimeMatch(normalized, val)) {
            return type2[0] === "+" || type2.indexOf("*") !== -1 ? val : type2;
        }
    }
    return false;
}
function hasBody(header) {
    return header.get("transfer-encoding") !== null || !isNaN(parseInt(header.get("content-length") || "", 10));
}
function typeofrequest(header, types_) {
    const types4 = types_;
    if (!hasBody(header)) {
        return null;
    }
    const value2 = header.get("content-type");
    if (!value2) {
        return false;
    }
    return is(value2, types4);
}
const normalize13 = function normalize13(type2) {
    switch(type2){
        case "urlencoded":
            return "application/x-www-form-urlencoded";
        case "multipart":
            return "multipart/*";
    }
    if (type2[0] === "+") {
        return "*/*" + type2;
    }
    return type2.indexOf("/") === -1 ? lookup2(type2) : type2;
};
function mimeMatch(expected, actual) {
    const actualParts = actual.split("/");
    const expectedParts = expected.split("/");
    if (actualParts.length !== 2 || expectedParts.length !== 2) {
        return false;
    }
    if (expectedParts[0] !== "*" && expectedParts[0] !== actualParts[0]) {
        return false;
    }
    if (expectedParts[1].substr(0, 2) === "*+") {
        return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);
    }
    if (expectedParts[1] !== "*" && expectedParts[1] !== actualParts[1]) {
        return false;
    }
    return true;
}
function normalizeType(value2) {
    const type2 = parse13(value2).type;
    if (!test(type2)) {
        return null;
    }
    return type2;
}
function tryNormalizeType(value2) {
    try {
        return normalizeType(value2);
    } catch (err) {
        return null;
    }
}
const regIP4 = new RegExp("^([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])$");
const regIP6 = new RegExp("^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$");
function isIPv4(ip) {
    return regIP4.test(ip);
}
function isIPv6(ip) {
    return regIP6.test(ip);
}
function isIP(ip) {
    if (isIPv4(ip)) {
        return 4;
    } else if (isIPv6(ip)) {
        return 6;
    } else {
        return 0;
    }
}
const FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
function append(header, field) {
    if (header === "*") {
        return header;
    }
    const fields = !Array.isArray(field) ? parse15(String(field)) : field;
    for(let j = 0; j < fields.length; j++){
        if (!FIELD_NAME_REGEXP.test(fields[j])) {
            throw new TypeError(`field argument contains an invalid header name \`${fields[j]}\``);
        }
    }
    let val = header;
    const vals = parse15(header.toLowerCase());
    if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
        return "*";
    }
    for(let i4 = 0; i4 < fields.length; i4++){
        const fld = fields[i4].toLowerCase();
        if (vals.indexOf(fld) === -1) {
            vals.push(fld);
            val = val ? val + ", " + fields[i4] : fields[i4];
        }
    }
    return val;
}
function parse15(header) {
    let end = 0;
    const list = [];
    let start = 0;
    for(let i4 = 0, len = header.length; i4 < len; i4++){
        switch(header.charCodeAt(i4)){
            case 32:
                if (start === end) {
                    start = end = i4 + 1;
                }
                break;
            case 44:
                list.push(header.substring(start, end));
                start = end = i4 + 1;
                break;
            default:
                end = i4 + 1;
                break;
        }
    }
    list.push(header.substring(start, end));
    return list;
}
function vary(header, field) {
    let val = header.get("vary") || "";
    if (val = append(val, field)) {
        header.set("vary", val);
    }
}
const matchHtmlRegExp = /["'&<>]/;
function escapeHtml(string) {
    const str2 = "" + string;
    const match = matchHtmlRegExp.exec(str2);
    if (!match) {
        return str2;
    }
    let escape;
    let html = "";
    let index = 0;
    let lastIndex = 0;
    for(index = match.index; index < str2.length; index++){
        switch(str2.charCodeAt(index)){
            case 34:
                escape = "&quot;";
                break;
            case 38:
                escape = "&amp;";
                break;
            case 39:
                escape = "&#39;";
                break;
            case 60:
                escape = "&lt;";
                break;
            case 62:
                escape = "&gt;";
                break;
            default: continue;
        }
        if (lastIndex !== index) {
            html += str2.substring(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escape;
    }
    return lastIndex !== index ? html + str2.substring(lastIndex, index) : html;
}
const ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
const UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
const UNMATCHED_SURROGATE_PAIR_REPLACE = "$1\uFFFD$2";
function encodeUrl(url) {
    return String(url).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
}
const importMeta = {
    url: "https://deno.land/x/denoflate@1.1/pkg/denoflate.js",
    main: false
};
let wasm;
let cachedTextDecoder = new TextDecoder('utf-8', {
    ignoreBOM: true,
    fatal: true
});
cachedTextDecoder.decode();
let cachegetUint8Memory0 = null;
function getUint8Memory0() {
    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachegetUint8Memory0;
}
function getStringFromWasm0(ptr, len) {
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
const heap = new Array(32).fill(undefined);
heap.push(undefined, null, true, false);
let heap_next = heap.length;
function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];
    heap[idx] = obj;
    return idx;
}
function getObject(idx) {
    return heap[idx];
}
function dropObject(idx) {
    if (idx < 36) return;
    heap[idx] = heap_next;
    heap_next = idx;
}
function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}
async function load(module, imports) {
    if (typeof Response === 'function' && module instanceof Response) {
        if (typeof WebAssembly.instantiateStreaming === 'function') {
            try {
                return await WebAssembly.instantiateStreaming(module, imports);
            } catch (e) {
                if (module.headers.get('Content-Type') != 'application/wasm') {
                    console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
                } else {
                    throw e;
                }
            }
        }
        const bytes = await module.arrayBuffer();
        return await WebAssembly.instantiate(bytes, imports);
    } else {
        const instance = await WebAssembly.instantiate(module, imports);
        if (instance instanceof WebAssembly.Instance) {
            return {
                instance,
                module
            };
        } else {
            return instance;
        }
    }
}
async function init(input) {
    if (typeof input === 'undefined') {
        input = importMeta.url.replace(/\.js$/, '_bg.wasm');
    }
    const imports = {
    };
    imports.wbg = {
    };
    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
        var ret = getStringFromWasm0(arg0, arg1);
        return addHeapObject(ret);
    };
    imports.wbg.__wbindgen_rethrow = function(arg0) {
        throw takeObject(arg0);
    };
    if (typeof input === 'string' || typeof Request === 'function' && input instanceof Request || typeof URL === 'function' && input instanceof URL) {
        input = fetch(input);
    }
    const { instance , module  } = await load(await input, imports);
    wasm = instance.exports;
    init.__wbindgen_wasm_module = module;
    return wasm;
}
const importMeta1 = {
    url: "https://deno.land/x/denoflate@1.1/mod.ts",
    main: false
};
async function read(path4) {
    const url = new URL(path4, importMeta1.url);
    if (url.protocol === "file:") {
        return await Deno.readFile(url);
    }
    const res = await fetch(url);
    return await res.arrayBuffer();
}
await init(read("./pkg/denoflate_bg.wasm"));
var rangeParser_1 = rangeParser;
function rangeParser(size7, str2, options) {
    if (typeof str2 !== "string") {
        throw new TypeError("argument str must be a string");
    }
    var index = str2.indexOf("=");
    if (index === -1) {
        return -2;
    }
    var arr = str2.slice(index + 1).split(",");
    var ranges = [];
    ranges.type = str2.slice(0, index);
    for(var i4 = 0; i4 < arr.length; i4++){
        var range = arr[i4].split("-");
        var start = parseInt(range[0], 10);
        var end = parseInt(range[1], 10);
        if (isNaN(start)) {
            start = size7 - end;
            end = size7 - 1;
        } else if (isNaN(end)) {
            end = size7 - 1;
        }
        if (end > size7 - 1) {
            end = size7 - 1;
        }
        if (isNaN(start) || isNaN(end) || start > end || start < 0) {
            continue;
        }
        ranges.push({
            start,
            end
        });
    }
    if (ranges.length < 1) {
        return -1;
    }
    return options && options.combine ? combineRanges(ranges) : ranges;
}
function combineRanges(ranges) {
    var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
    for(var j = 0, i4 = 1; i4 < ordered.length; i4++){
        var range = ordered[i4];
        var current = ordered[j];
        if (range.start > current.end + 1) {
            ordered[++j] = range;
        } else if (range.end > current.end) {
            current.end = range.end;
            current.index = Math.min(current.index, range.index);
        }
    }
    ordered.length = j + 1;
    var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
    combined.type = ranges.type;
    return combined;
}
function mapWithIndex(range, index) {
    return {
        start: range.start,
        end: range.end,
        index
    };
}
function mapWithoutIndex(range) {
    return {
        start: range.start,
        end: range.end
    };
}
function sortByRangeIndex(a, b) {
    return a.index - b.index;
}
function sortByRangeStart(a, b) {
    return a.start - b.start;
}
var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;
var hexTable1 = function() {
    var array = [];
    for(var i4 = 0; i4 < 256; ++i4){
        array.push("%" + ((i4 < 16 ? "0" : "") + i4.toString(16)).toUpperCase());
    }
    return array;
}();
var compactQueue = function compactQueue2(queue) {
    while(queue.length > 1){
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
            var compacted = [];
            for(var j = 0; j < obj.length; ++j){
                if (typeof obj[j] !== "undefined") {
                    compacted.push(obj[j]);
                }
            }
            item.obj[item.prop] = compacted;
        }
    }
};
var arrayToObject = function arrayToObject2(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {
    };
    for(var i4 = 0; i4 < source.length; ++i4){
        if (typeof source[i4] !== "undefined") {
            obj[i4] = source[i4];
        }
    }
    return obj;
};
var merge2 = function merge21(target, source, options) {
    if (!source) {
        return target;
    }
    if (typeof source !== "object") {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === "object") {
            if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [
                target,
                source
            ];
        }
        return target;
    }
    if (!target || typeof target !== "object") {
        return [
            target
        ].concat(source);
    }
    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }
    if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i4) {
            if (has.call(target, i4)) {
                var targetItem = target[i4];
                if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
                    target[i4] = merge21(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i4] = item;
            }
        });
        return target;
    }
    return Object.keys(source).reduce(function(acc, key) {
        var value2 = source[key];
        if (has.call(acc, key)) {
            acc[key] = merge21(acc[key], value2, options);
        } else {
            acc[key] = value2;
        }
        return acc;
    }, mergeTarget);
};
var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};
var decode2 = function(str2, decoder2, charset1) {
    var strWithoutPlus = str2.replace(/\+/g, " ");
    if (charset1 === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};
var encode2 = function encode21(str2, defaultEncoder, charset1) {
    if (str2.length === 0) {
        return str2;
    }
    var string = str2;
    if (typeof str2 === "symbol") {
        string = Symbol.prototype.toString.call(str2);
    } else if (typeof str2 !== "string") {
        string = String(str2);
    }
    if (charset1 === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
            return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
    }
    var out = "";
    for(var i4 = 0; i4 < string.length; ++i4){
        var c = string.charCodeAt(i4);
        if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122) {
            out += string.charAt(i4);
            continue;
        }
        if (c < 128) {
            out = out + hexTable1[c];
            continue;
        }
        if (c < 2048) {
            out = out + (hexTable1[192 | c >> 6] + hexTable1[128 | c & 63]);
            continue;
        }
        if (c < 55296 || c >= 57344) {
            out = out + (hexTable1[224 | c >> 12] + hexTable1[128 | c >> 6 & 63] + hexTable1[128 | c & 63]);
            continue;
        }
        i4 += 1;
        c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i4) & 1023);
        out += hexTable1[240 | c >> 18] + hexTable1[128 | c >> 12 & 63] + hexTable1[128 | c >> 6 & 63] + hexTable1[128 | c & 63];
    }
    return out;
};
var compact = function compact2(value2) {
    var queue = [
        {
            obj: {
                o: value2
            },
            prop: "o"
        }
    ];
    var refs = [];
    for(var i4 = 0; i4 < queue.length; ++i4){
        var item = queue[i4];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for(var j = 0; j < keys.length; ++j){
            var key = keys[j];
            var val = obj[key];
            if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
                queue.push({
                    obj,
                    prop: key
                });
                refs.push(val);
            }
        }
    }
    compactQueue(queue);
    return value2;
};
var isRegExp = function isRegExp2(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
};
var isBuffer = function isBuffer2(obj) {
    if (!obj || typeof obj !== "object") {
        return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};
var combine = function combine2(a, b) {
    return [].concat(a, b);
};
var maybeMap = function maybeMap2(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for(var i4 = 0; i4 < val.length; i4 += 1){
            mapped.push(fn(val[i4]));
        }
        return mapped;
    }
    return fn(val);
};
var utils = {
    arrayToObject,
    assign,
    combine,
    compact,
    decode: decode2,
    encode: encode2,
    isBuffer,
    isRegExp,
    maybeMap,
    merge: merge2
};
var replace = String.prototype.replace;
var percentTwenties = /%20/g;
var Format = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
};
var formats = utils.assign({
    default: Format.RFC3986,
    formatters: {
        RFC1738: function(value2) {
            return replace.call(value2, percentTwenties, "+");
        },
        RFC3986: function(value2) {
            return String(value2);
        }
    }
}, Format);
var has$1 = Object.prototype.hasOwnProperty;
var arrayPrefixGenerators = {
    brackets: function brackets(prefix2) {
        return prefix2 + "[]";
    },
    comma: "comma",
    indices: function indices(prefix2, key) {
        return prefix2 + "[" + key + "]";
    },
    repeat: function repeat(prefix2) {
        return prefix2;
    }
};
var isArray$1 = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function(arr, valueOrArray) {
    push.apply(arr, isArray$1(valueOrArray) ? valueOrArray : [
        valueOrArray
    ]);
};
var toISO = Date.prototype.toISOString;
var defaultFormat = formats["default"];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    charset: "utf-8",
    charsetSentinel: false,
    delimiter: "&",
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};
var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
    return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
};
var stringify = function stringify2(object, prefix2, generateArrayPrefix, strictNullHandling, skipNulls, encoder2, filter, sort, allowDots, serializeDate2, formatter, encodeValuesOnly, charset1) {
    var obj = object;
    if (typeof filter === "function") {
        obj = filter(prefix2, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate2(obj);
    } else if (generateArrayPrefix === "comma" && isArray$1(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
            if (value2 instanceof Date) {
                return serializeDate2(value2);
            }
            return value2;
        }).join(",");
    }
    if (obj === null) {
        if (strictNullHandling) {
            return encoder2 && !encodeValuesOnly ? encoder2(prefix2, defaults.encoder, charset1, "key") : prefix2;
        }
        obj = "";
    }
    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder2) {
            var keyValue = encodeValuesOnly ? prefix2 : encoder2(prefix2, defaults.encoder, charset1, "key");
            return [
                formatter(keyValue) + "=" + formatter(encoder2(obj, defaults.encoder, charset1, "value"))
            ];
        }
        return [
            formatter(prefix2) + "=" + formatter(String(obj))
        ];
    }
    var values1 = [];
    if (typeof obj === "undefined") {
        return values1;
    }
    var objKeys;
    if (isArray$1(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }
    for(var i5 = 0; i5 < objKeys.length; ++i5){
        var key = objKeys[i5];
        var value2 = obj[key];
        if (skipNulls && value2 === null) {
            continue;
        }
        var keyPrefix = isArray$1(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(prefix2, key) : prefix2 : prefix2 + (allowDots ? "." + key : "[" + key + "]");
        pushToArray(values1, stringify2(value2, keyPrefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder2, filter, sort, allowDots, serializeDate2, formatter, encodeValuesOnly, charset1));
    }
    return values1;
};
var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
    if (!opts) {
        return defaults;
    }
    if (opts.encoder !== null && opts.encoder !== void 0 && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
    }
    var charset1 = opts.charset || defaults.charset;
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var format12 = formats["default"];
    if (typeof opts.format !== "undefined") {
        if (!has$1.call(formats.formatters, opts.format)) {
            throw new TypeError("Unknown format option provided.");
        }
        format12 = opts.format;
    }
    var formatter = formats.formatters[format12];
    var filter = defaults.filter;
    if (typeof opts.filter === "function" || isArray$1(opts.filter)) {
        filter = opts.filter;
    }
    return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        charset: charset1,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
    };
};
var stringify_1 = function(object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);
    var objKeys;
    var filter;
    if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
    } else if (isArray$1(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }
    var keys = [];
    if (typeof obj !== "object" || obj === null) {
        return "";
    }
    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if (opts && "indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
    } else {
        arrayFormat = "indices";
    }
    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
    if (!objKeys) {
        objKeys = Object.keys(obj);
    }
    if (options.sort) {
        objKeys.sort(options.sort);
    }
    for(var i5 = 0; i5 < objKeys.length; ++i5){
        var key = objKeys[i5];
        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(obj[key], key, generateArrayPrefix, options.strictNullHandling, options.skipNulls, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.formatter, options.encodeValuesOnly, options.charset));
    }
    var joined = keys.join(options.delimiter);
    var prefix2 = options.addQueryPrefix === true ? "?" : "";
    if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
            prefix2 += "utf8=%26%2310003%3B&";
        } else {
            prefix2 += "utf8=%E2%9C%93&";
        }
    }
    return joined.length > 0 ? prefix2 + joined : "";
};
var has$2 = Object.prototype.hasOwnProperty;
var isArray$2 = Array.isArray;
var defaults$1 = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: false,
    comma: false,
    decoder: utils.decode,
    delimiter: "&",
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
};
var interpretNumericEntities = function(str2) {
    return str2.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};
var parseArrayValue = function(val, options) {
    if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
    }
    return val;
};
var isoSentinel = "utf8=%26%2310003%3B";
var charsetSentinel = "utf8=%E2%9C%93";
var parseValues = function parseQueryStringValues(str2, options) {
    var obj = {
    };
    var cleanStr = options.ignoreQueryPrefix ? str2.replace(/^\?/, "") : str2;
    var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1;
    var i5;
    var charset1 = options.charset;
    if (options.charsetSentinel) {
        for(i5 = 0; i5 < parts.length; ++i5){
            if (parts[i5].indexOf("utf8=") === 0) {
                if (parts[i5] === charsetSentinel) {
                    charset1 = "utf-8";
                } else if (parts[i5] === isoSentinel) {
                    charset1 = "iso-8859-1";
                }
                skipIndex = i5;
                i5 = parts.length;
            }
        }
    }
    for(i5 = 0; i5 < parts.length; ++i5){
        if (i5 === skipIndex) {
            continue;
        }
        var part = parts[i5];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults$1.decoder, charset1, "key");
            val = options.strictNullHandling ? null : "";
        } else {
            key = options.decoder(part.slice(0, pos), defaults$1.decoder, charset1, "key");
            val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function(encodedVal) {
                return options.decoder(encodedVal, defaults$1.decoder, charset1, "value");
            });
        }
        if (val && options.interpretNumericEntities && charset1 === "iso-8859-1") {
            val = interpretNumericEntities(val);
        }
        if (part.indexOf("[]=") > -1) {
            val = isArray$2(val) ? [
                val
            ] : val;
        }
        if (has$2.call(obj, key)) {
            obj[key] = utils.combine(obj[key], val);
        } else {
            obj[key] = val;
        }
    }
    return obj;
};
var parseObject = function(chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);
    for(var i5 = chain.length - 1; i5 >= 0; --i5){
        var obj;
        var root = chain[i5];
        if (root === "[]" && options.parseArrays) {
            obj = [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {
            };
            var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === "") {
                obj = {
                    0: leaf
                };
            } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
                obj = [];
                obj[index] = leaf;
            } else {
                obj[cleanRoot] = leaf;
            }
        }
        leaf = obj;
    }
    return leaf;
};
var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
    var brackets2 = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;
    var segment = options.depth > 0 && brackets2.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;
    var keys = [];
    if (parent) {
        if (!options.plainObjects && has$2.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(parent);
    }
    var i5 = 0;
    while(options.depth > 0 && (segment = child.exec(key)) !== null && i5 < options.depth){
        i5 += 1;
        if (!options.plainObjects && has$2.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }
    if (segment) {
        keys.push("[" + key.slice(segment.index) + "]");
    }
    return parseObject(keys, val, options, valuesParsed);
};
var normalizeParseOptions = function normalizeParseOptions2(opts) {
    if (!opts) {
        return defaults$1;
    }
    if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
    }
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var charset1 = typeof opts.charset === "undefined" ? defaults$1.charset : opts.charset;
    return {
        allowDots: typeof opts.allowDots === "undefined" ? defaults$1.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults$1.allowPrototypes,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults$1.arrayLimit,
        charset: charset1,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$1.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults$1.comma,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults$1.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults$1.delimiter,
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults$1.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults$1.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults$1.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults$1.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$1.strictNullHandling
    };
};
var parse16 = function(str2, opts) {
    var options = normalizeParseOptions(opts);
    if (str2 === "" || str2 === null || typeof str2 === "undefined") {
        return options.plainObjects ? Object.create(null) : {
        };
    }
    var tempObj = typeof str2 === "string" ? parseValues(str2, options) : str2;
    var obj = options.plainObjects ? Object.create(null) : {
    };
    var keys = Object.keys(tempObj);
    for(var i5 = 0; i5 < keys.length; ++i5){
        var key = keys[i5];
        var newObj = parseKeys(key, tempObj[key], options, typeof str2 === "string");
        obj = utils.merge(obj, newObj, options);
    }
    return utils.compact(obj);
};
var lib = {
    formats,
    parse: parse16,
    stringify: stringify_1
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {
};
function createCommonjsModule(fn, basedir, module) {
    return module = {
        path: basedir,
        exports: {
        },
        require: function(path4, base) {
            return commonjsRequire(path4, base === void 0 || base === null ? module.path : base);
        }
    }, fn(module, module.exports), module.exports;
}
function commonjsRequire() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var ipaddr = createCommonjsModule(function(module) {
    (function(root) {
        const ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
        const ipv4Regexes = {
            fourOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
            threeOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
            twoOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}$`, "i"),
            longValue: new RegExp(`^${ipv4Part}$`, "i")
        };
        const octalRegex = new RegExp(`^0[0-7]+$`, "i");
        const hexRegex = new RegExp(`^0x[a-f0-9]+$`, "i");
        const zoneIndex = "%[0-9a-z]{1,}";
        const ipv6Part = "(?:[0-9a-f]+::?)+";
        const ipv6Regexes = {
            zoneIndex: new RegExp(zoneIndex, "i"),
            native: new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, "i"),
            deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?)$`, "i"),
            transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?$`, "i")
        };
        function expandIPv6(string, parts) {
            if (string.indexOf("::") !== string.lastIndexOf("::")) {
                return null;
            }
            let colonCount = 0;
            let lastColon = -1;
            let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];
            let replacement, replacementCount;
            if (zoneId) {
                zoneId = zoneId.substring(1);
                string = string.replace(/%.+$/, "");
            }
            while((lastColon = string.indexOf(":", lastColon + 1)) >= 0){
                colonCount++;
            }
            if (string.substr(0, 2) === "::") {
                colonCount--;
            }
            if (string.substr(-2, 2) === "::") {
                colonCount--;
            }
            if (colonCount > parts) {
                return null;
            }
            replacementCount = parts - colonCount;
            replacement = ":";
            while(replacementCount--){
                replacement += "0:";
            }
            string = string.replace("::", replacement);
            if (string[0] === ":") {
                string = string.slice(1);
            }
            if (string[string.length - 1] === ":") {
                string = string.slice(0, -1);
            }
            parts = (function() {
                const ref = string.split(":");
                const results = [];
                for(let i5 = 0; i5 < ref.length; i5++){
                    results.push(parseInt(ref[i5], 16));
                }
                return results;
            })();
            return {
                parts,
                zoneId
            };
        }
        function matchCIDR(first, second, partSize, cidrBits) {
            if (first.length !== second.length) {
                throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
            }
            let part = 0;
            let shift;
            while(cidrBits > 0){
                shift = partSize - cidrBits;
                if (shift < 0) {
                    shift = 0;
                }
                if (first[part] >> shift !== second[part] >> shift) {
                    return false;
                }
                cidrBits -= partSize;
                part += 1;
            }
            return true;
        }
        function parseIntAuto(string) {
            if (hexRegex.test(string)) {
                return parseInt(string, 16);
            }
            if (string[0] === "0" && !isNaN(parseInt(string[1], 10))) {
                if (octalRegex.test(string)) {
                    return parseInt(string, 8);
                }
                throw new Error(`ipaddr: cannot parse ${string} as octal`);
            }
            return parseInt(string, 10);
        }
        function padPart(part, length) {
            while(part.length < length){
                part = `0${part}`;
            }
            return part;
        }
        const ipaddr2 = {
        };
        ipaddr2.IPv4 = (function() {
            function IPv42(octets) {
                if (octets.length !== 4) {
                    throw new Error("ipaddr: ipv4 octet count should be 4");
                }
                let i5, octet;
                for(i5 = 0; i5 < octets.length; i5++){
                    octet = octets[i5];
                    if (!(0 <= octet && octet <= 255)) {
                        throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
                    }
                }
                this.octets = octets;
            }
            IPv42.prototype.SpecialRanges = {
                unspecified: [
                    [
                        new IPv42([
                            0,
                            0,
                            0,
                            0
                        ]),
                        8
                    ]
                ],
                broadcast: [
                    [
                        new IPv42([
                            255,
                            255,
                            255,
                            255
                        ]),
                        32
                    ]
                ],
                multicast: [
                    [
                        new IPv42([
                            224,
                            0,
                            0,
                            0
                        ]),
                        4
                    ]
                ],
                linkLocal: [
                    [
                        new IPv42([
                            169,
                            254,
                            0,
                            0
                        ]),
                        16
                    ]
                ],
                loopback: [
                    [
                        new IPv42([
                            127,
                            0,
                            0,
                            0
                        ]),
                        8
                    ]
                ],
                carrierGradeNat: [
                    [
                        new IPv42([
                            100,
                            64,
                            0,
                            0
                        ]),
                        10
                    ]
                ],
                private: [
                    [
                        new IPv42([
                            10,
                            0,
                            0,
                            0
                        ]),
                        8
                    ],
                    [
                        new IPv42([
                            172,
                            16,
                            0,
                            0
                        ]),
                        12
                    ],
                    [
                        new IPv42([
                            192,
                            168,
                            0,
                            0
                        ]),
                        16
                    ]
                ],
                reserved: [
                    [
                        new IPv42([
                            192,
                            0,
                            0,
                            0
                        ]),
                        24
                    ],
                    [
                        new IPv42([
                            192,
                            0,
                            2,
                            0
                        ]),
                        24
                    ],
                    [
                        new IPv42([
                            192,
                            88,
                            99,
                            0
                        ]),
                        24
                    ],
                    [
                        new IPv42([
                            198,
                            51,
                            100,
                            0
                        ]),
                        24
                    ],
                    [
                        new IPv42([
                            203,
                            0,
                            113,
                            0
                        ]),
                        24
                    ],
                    [
                        new IPv42([
                            240,
                            0,
                            0,
                            0
                        ]),
                        4
                    ]
                ]
            };
            IPv42.prototype.kind = function() {
                return "ipv4";
            };
            IPv42.prototype.match = function(other, cidrRange) {
                let ref;
                if (cidrRange === void 0) {
                    ref = other;
                    other = ref[0];
                    cidrRange = ref[1];
                }
                if (other.kind() !== "ipv4") {
                    throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
                }
                return matchCIDR(this.octets, other.octets, 8, cidrRange);
            };
            IPv42.prototype.prefixLengthFromSubnetMask = function() {
                let cidr = 0;
                let stop = false;
                const zerotable = {
                    0: 8,
                    128: 7,
                    192: 6,
                    224: 5,
                    240: 4,
                    248: 3,
                    252: 2,
                    254: 1,
                    255: 0
                };
                let i5, octet, zeros;
                for(i5 = 3; i5 >= 0; i5 -= 1){
                    octet = this.octets[i5];
                    if (octet in zerotable) {
                        zeros = zerotable[octet];
                        if (stop && zeros !== 0) {
                            return null;
                        }
                        if (zeros !== 8) {
                            stop = true;
                        }
                        cidr += zeros;
                    } else {
                        return null;
                    }
                }
                return 32 - cidr;
            };
            IPv42.prototype.range = function() {
                return ipaddr2.subnetMatch(this, this.SpecialRanges);
            };
            IPv42.prototype.toByteArray = function() {
                return this.octets.slice(0);
            };
            IPv42.prototype.toIPv4MappedAddress = function() {
                return ipaddr2.IPv6.parse(`::ffff:${this.toString()}`);
            };
            IPv42.prototype.toNormalizedString = function() {
                return this.toString();
            };
            IPv42.prototype.toString = function() {
                return this.octets.join(".");
            };
            return IPv42;
        })();
        ipaddr2.IPv4.broadcastAddressFromCIDR = function(string) {
            try {
                const cidr = this.parseCIDR(string);
                const ipInterfaceOctets = cidr[0].toByteArray();
                const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
                const octets = [];
                let i5 = 0;
                while(i5 < 4){
                    octets.push(parseInt(ipInterfaceOctets[i5], 10) | parseInt(subnetMaskOctets[i5], 10) ^ 255);
                    i5++;
                }
                return new this(octets);
            } catch (e) {
                throw new Error("ipaddr: the address does not have IPv4 CIDR format");
            }
        };
        ipaddr2.IPv4.isIPv4 = function(string) {
            return this.parser(string) !== null;
        };
        ipaddr2.IPv4.isValid = function(string) {
            try {
                new this(this.parser(string));
                return true;
            } catch (e) {
                return false;
            }
        };
        ipaddr2.IPv4.isValidFourPartDecimal = function(string) {
            if (ipaddr2.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
                return true;
            } else {
                return false;
            }
        };
        ipaddr2.IPv4.networkAddressFromCIDR = function(string) {
            let cidr, i5, ipInterfaceOctets, octets, subnetMaskOctets;
            try {
                cidr = this.parseCIDR(string);
                ipInterfaceOctets = cidr[0].toByteArray();
                subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
                octets = [];
                i5 = 0;
                while(i5 < 4){
                    octets.push(parseInt(ipInterfaceOctets[i5], 10) & parseInt(subnetMaskOctets[i5], 10));
                    i5++;
                }
                return new this(octets);
            } catch (e) {
                throw new Error("ipaddr: the address does not have IPv4 CIDR format");
            }
        };
        ipaddr2.IPv4.parse = function(string) {
            const parts = this.parser(string);
            if (parts === null) {
                throw new Error("ipaddr: string is not formatted like an IPv4 Address");
            }
            return new this(parts);
        };
        ipaddr2.IPv4.parseCIDR = function(string) {
            let match;
            if (match = string.match(/^(.+)\/(\d+)$/)) {
                const maskLength = parseInt(match[2]);
                if (maskLength >= 0 && maskLength <= 32) {
                    const parsed = [
                        this.parse(match[1]),
                        maskLength
                    ];
                    Object.defineProperty(parsed, "toString", {
                        value: function() {
                            return this.join("/");
                        }
                    });
                    return parsed;
                }
            }
            throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
        };
        ipaddr2.IPv4.parser = function(string) {
            let match, part, value3;
            if (match = string.match(ipv4Regexes.fourOctet)) {
                return (function() {
                    const ref = match.slice(1, 6);
                    const results = [];
                    for(let i5 = 0; i5 < ref.length; i5++){
                        part = ref[i5];
                        results.push(parseIntAuto(part));
                    }
                    return results;
                })();
            } else if (match = string.match(ipv4Regexes.longValue)) {
                value3 = parseIntAuto(match[1]);
                if (value3 > 4294967295 || value3 < 0) {
                    throw new Error("ipaddr: address outside defined range");
                }
                return (function() {
                    const results = [];
                    let shift;
                    for(shift = 0; shift <= 24; shift += 8){
                        results.push(value3 >> shift & 255);
                    }
                    return results;
                })().reverse();
            } else if (match = string.match(ipv4Regexes.twoOctet)) {
                return (function() {
                    const ref = match.slice(1, 4);
                    const results = [];
                    value3 = parseIntAuto(ref[1]);
                    if (value3 > 16777215 || value3 < 0) {
                        throw new Error("ipaddr: address outside defined range");
                    }
                    results.push(parseIntAuto(ref[0]));
                    results.push(value3 >> 16 & 255);
                    results.push(value3 >> 8 & 255);
                    results.push(value3 & 255);
                    return results;
                })();
            } else if (match = string.match(ipv4Regexes.threeOctet)) {
                return (function() {
                    const ref = match.slice(1, 5);
                    const results = [];
                    value3 = parseIntAuto(ref[2]);
                    if (value3 > 65535 || value3 < 0) {
                        throw new Error("ipaddr: address outside defined range");
                    }
                    results.push(parseIntAuto(ref[0]));
                    results.push(parseIntAuto(ref[1]));
                    results.push(value3 >> 8 & 255);
                    results.push(value3 & 255);
                    return results;
                })();
            } else {
                return null;
            }
        };
        ipaddr2.IPv4.subnetMaskFromPrefixLength = function(prefix2) {
            prefix2 = parseInt(prefix2);
            if (prefix2 < 0 || prefix2 > 32) {
                throw new Error("ipaddr: invalid IPv4 prefix length");
            }
            const octets = [
                0,
                0,
                0,
                0
            ];
            let j = 0;
            const filledOctetCount = Math.floor(prefix2 / 8);
            while(j < filledOctetCount){
                octets[j] = 255;
                j++;
            }
            if (filledOctetCount < 4) {
                octets[filledOctetCount] = Math.pow(2, prefix2 % 8) - 1 << 8 - prefix2 % 8;
            }
            return new this(octets);
        };
        ipaddr2.IPv6 = (function() {
            function IPv62(parts, zoneId) {
                let i5, part;
                if (parts.length === 16) {
                    this.parts = [];
                    for(i5 = 0; i5 <= 14; i5 += 2){
                        this.parts.push(parts[i5] << 8 | parts[i5 + 1]);
                    }
                } else if (parts.length === 8) {
                    this.parts = parts;
                } else {
                    throw new Error("ipaddr: ipv6 part count should be 8 or 16");
                }
                for(i5 = 0; i5 < this.parts.length; i5++){
                    part = this.parts[i5];
                    if (!(0 <= part && part <= 65535)) {
                        throw new Error("ipaddr: ipv6 part should fit in 16 bits");
                    }
                }
                if (zoneId) {
                    this.zoneId = zoneId;
                }
            }
            IPv62.prototype.SpecialRanges = {
                unspecified: [
                    new IPv62([
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]),
                    128
                ],
                linkLocal: [
                    new IPv62([
                        65152,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]),
                    10
                ],
                multicast: [
                    new IPv62([
                        65280,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]),
                    8
                ],
                loopback: [
                    new IPv62([
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        1
                    ]),
                    128
                ],
                uniqueLocal: [
                    new IPv62([
                        64512,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]),
                    7
                ],
                ipv4Mapped: [
                    new IPv62([
                        0,
                        0,
                        0,
                        0,
                        0,
                        65535,
                        0,
                        0
                    ]),
                    96
                ],
                rfc6145: [
                    new IPv62([
                        0,
                        0,
                        0,
                        0,
                        65535,
                        0,
                        0,
                        0
                    ]),
                    96
                ],
                rfc6052: [
                    new IPv62([
                        100,
                        65435,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]),
                    96
                ],
                "6to4": [
                    new IPv62([
                        8194,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]),
                    16
                ],
                teredo: [
                    new IPv62([
                        8193,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]),
                    32
                ],
                reserved: [
                    [
                        new IPv62([
                            8193,
                            3512,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0
                        ]),
                        32
                    ]
                ]
            };
            IPv62.prototype.isIPv4MappedAddress = function() {
                return this.range() === "ipv4Mapped";
            };
            IPv62.prototype.kind = function() {
                return "ipv6";
            };
            IPv62.prototype.match = function(other, cidrRange) {
                let ref;
                if (cidrRange === void 0) {
                    ref = other;
                    other = ref[0];
                    cidrRange = ref[1];
                }
                if (other.kind() !== "ipv6") {
                    throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
                }
                return matchCIDR(this.parts, other.parts, 16, cidrRange);
            };
            IPv62.prototype.prefixLengthFromSubnetMask = function() {
                let cidr = 0;
                let stop = false;
                const zerotable = {
                    0: 16,
                    32768: 15,
                    49152: 14,
                    57344: 13,
                    61440: 12,
                    63488: 11,
                    64512: 10,
                    65024: 9,
                    65280: 8,
                    65408: 7,
                    65472: 6,
                    65504: 5,
                    65520: 4,
                    65528: 3,
                    65532: 2,
                    65534: 1,
                    65535: 0
                };
                let part, zeros;
                for(let i5 = 7; i5 >= 0; i5 -= 1){
                    part = this.parts[i5];
                    if (part in zerotable) {
                        zeros = zerotable[part];
                        if (stop && zeros !== 0) {
                            return null;
                        }
                        if (zeros !== 16) {
                            stop = true;
                        }
                        cidr += zeros;
                    } else {
                        return null;
                    }
                }
                return 128 - cidr;
            };
            IPv62.prototype.range = function() {
                return ipaddr2.subnetMatch(this, this.SpecialRanges);
            };
            IPv62.prototype.toByteArray = function() {
                let part;
                const bytes = [];
                const ref = this.parts;
                for(let i5 = 0; i5 < ref.length; i5++){
                    part = ref[i5];
                    bytes.push(part >> 8);
                    bytes.push(part & 255);
                }
                return bytes;
            };
            IPv62.prototype.toFixedLengthString = function() {
                const addr = (function() {
                    const results = [];
                    for(let i5 = 0; i5 < this.parts.length; i5++){
                        results.push(padPart(this.parts[i5].toString(16), 4));
                    }
                    return results;
                }).call(this).join(":");
                let suffix1 = "";
                if (this.zoneId) {
                    suffix1 = `%${this.zoneId}`;
                }
                return addr + suffix1;
            };
            IPv62.prototype.toIPv4Address = function() {
                if (!this.isIPv4MappedAddress()) {
                    throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
                }
                const ref = this.parts.slice(-2);
                const high = ref[0];
                const low = ref[1];
                return new ipaddr2.IPv4([
                    high >> 8,
                    high & 255,
                    low >> 8,
                    low & 255
                ]);
            };
            IPv62.prototype.toNormalizedString = function() {
                const addr = (function() {
                    const results = [];
                    for(let i5 = 0; i5 < this.parts.length; i5++){
                        results.push(this.parts[i5].toString(16));
                    }
                    return results;
                }).call(this).join(":");
                let suffix1 = "";
                if (this.zoneId) {
                    suffix1 = `%${this.zoneId}`;
                }
                return addr + suffix1;
            };
            IPv62.prototype.toRFC5952String = function() {
                const regex = /((^|:)(0(:|$)){2,})/g;
                const string = this.toNormalizedString();
                let bestMatchIndex = 0;
                let bestMatchLength = -1;
                let match;
                while(match = regex.exec(string)){
                    if (match[0].length > bestMatchLength) {
                        bestMatchIndex = match.index;
                        bestMatchLength = match[0].length;
                    }
                }
                if (bestMatchLength < 0) {
                    return string;
                }
                return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;
            };
            IPv62.prototype.toString = function() {
                return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
            };
            return IPv62;
        })();
        ipaddr2.IPv6.isIPv6 = function(string) {
            return this.parser(string) !== null;
        };
        ipaddr2.IPv6.isValid = function(string) {
            if (typeof string === "string" && string.indexOf(":") === -1) {
                return false;
            }
            try {
                const addr = this.parser(string);
                new this(addr.parts, addr.zoneId);
                return true;
            } catch (e) {
                return false;
            }
        };
        ipaddr2.IPv6.parse = function(string) {
            const addr = this.parser(string);
            if (addr.parts === null) {
                throw new Error("ipaddr: string is not formatted like an IPv6 Address");
            }
            return new this(addr.parts, addr.zoneId);
        };
        ipaddr2.IPv6.parseCIDR = function(string) {
            let maskLength, match, parsed;
            if (match = string.match(/^(.+)\/(\d+)$/)) {
                maskLength = parseInt(match[2]);
                if (maskLength >= 0 && maskLength <= 128) {
                    parsed = [
                        this.parse(match[1]),
                        maskLength
                    ];
                    Object.defineProperty(parsed, "toString", {
                        value: function() {
                            return this.join("/");
                        }
                    });
                    return parsed;
                }
            }
            throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
        };
        ipaddr2.IPv6.parser = function(string) {
            let addr, i5, match, octet, octets, zoneId;
            if (match = string.match(ipv6Regexes.deprecatedTransitional)) {
                return this.parser(`::ffff:${match[1]}`);
            }
            if (ipv6Regexes.native.test(string)) {
                return expandIPv6(string, 8);
            }
            if (match = string.match(ipv6Regexes.transitional)) {
                zoneId = match[6] || "";
                addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
                if (addr.parts) {
                    octets = [
                        parseInt(match[2]),
                        parseInt(match[3]),
                        parseInt(match[4]),
                        parseInt(match[5])
                    ];
                    for(i5 = 0; i5 < octets.length; i5++){
                        octet = octets[i5];
                        if (!(0 <= octet && octet <= 255)) {
                            return null;
                        }
                    }
                    addr.parts.push(octets[0] << 8 | octets[1]);
                    addr.parts.push(octets[2] << 8 | octets[3]);
                    return {
                        parts: addr.parts,
                        zoneId: addr.zoneId
                    };
                }
            }
            return null;
        };
        ipaddr2.fromByteArray = function(bytes) {
            const length = bytes.length;
            if (length === 4) {
                return new ipaddr2.IPv4(bytes);
            } else if (length === 16) {
                return new ipaddr2.IPv6(bytes);
            } else {
                throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
            }
        };
        ipaddr2.isValid = function(string) {
            return ipaddr2.IPv6.isValid(string) || ipaddr2.IPv4.isValid(string);
        };
        ipaddr2.parse = function(string) {
            if (ipaddr2.IPv6.isValid(string)) {
                return ipaddr2.IPv6.parse(string);
            } else if (ipaddr2.IPv4.isValid(string)) {
                return ipaddr2.IPv4.parse(string);
            } else {
                throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
            }
        };
        ipaddr2.parseCIDR = function(string) {
            try {
                return ipaddr2.IPv6.parseCIDR(string);
            } catch (e) {
                try {
                    return ipaddr2.IPv4.parseCIDR(string);
                } catch (e2) {
                    throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
                }
            }
        };
        ipaddr2.process = function(string) {
            const addr = this.parse(string);
            if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
                return addr.toIPv4Address();
            } else {
                return addr;
            }
        };
        ipaddr2.subnetMatch = function(address, rangeList, defaultName) {
            let i5, rangeName, rangeSubnets, subnet;
            if (defaultName === void 0 || defaultName === null) {
                defaultName = "unicast";
            }
            for(rangeName in rangeList){
                if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {
                    rangeSubnets = rangeList[rangeName];
                    if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
                        rangeSubnets = [
                            rangeSubnets
                        ];
                    }
                    for(i5 = 0; i5 < rangeSubnets.length; i5++){
                        subnet = rangeSubnets[i5];
                        if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {
                            return rangeName;
                        }
                    }
                }
            }
            return defaultName;
        };
        if (module.exports) {
            module.exports = ipaddr2;
        } else {
            root.ipaddr = ipaddr2;
        }
    })(commonjsGlobal);
});
const methods = [
    "get",
    "post",
    "put",
    "head",
    "delete",
    "options",
    "trace",
    "copy",
    "lock",
    "mkcol",
    "move",
    "purge",
    "propfind",
    "proppatch",
    "unlock",
    "report",
    "mkactivity",
    "checkout",
    "merge",
    "m-search",
    "notify",
    "subscribe",
    "unsubscribe",
    "patch",
    "search",
    "connect", 
];
const MATCHING_GROUP_REGEXP = /\((?!\?)/g;
function pathToRegexp(path4, keys, options) {
    options = options || {
    };
    keys = keys || [];
    const strict = options.strict;
    const end = options.end !== false;
    const flags = options.sensitive ? "" : "i";
    let extraOffset = 0;
    const keysOffset = keys.length;
    let i5 = 0;
    let name = 0;
    let m;
    if (path4 instanceof RegExp) {
        while(m = MATCHING_GROUP_REGEXP.exec(path4.source)){
            keys.push({
                name: name++,
                optional: false,
                offset: m.index
            });
        }
        return path4;
    }
    if (Array.isArray(path4)) {
        path4 = path4.map(function(value3) {
            return pathToRegexp(value3, keys, options).source;
        });
        return new RegExp("(?:" + path4.join("|") + ")", flags);
    }
    path4 = ("^" + path4 + (strict ? "" : path4[path4.length - 1] === "/" ? "?" : "/?")).replace(/\/\(/g, "/(?:").replace(/([\/\.])/g, "\\$1").replace(/(\\\/)?(\\\.)?:(\w+)(\(.*?\))?(\*)?(\?)?/g, function(match, slash, format12, key, capture, star, optional, offset) {
        slash = slash || "";
        format12 = format12 || "";
        capture = capture || "([^\\/" + format12 + "]+?)";
        optional = optional || "";
        keys.push({
            name: key,
            optional: !!optional,
            offset: offset + extraOffset
        });
        const result = "" + (optional ? "" : slash) + "(?:" + format12 + (optional ? slash : "") + capture + (star ? "((?:[\\/" + format12 + "].+?)?)" : "") + ")" + optional;
        extraOffset += result.length - match.length;
        return result;
    }).replace(/\*/g, function(star, index) {
        let len = keys.length;
        while((len--) > keysOffset && keys[len].offset > index){
            keys[len].offset += 3;
        }
        return "(.*)";
    });
    while(m = MATCHING_GROUP_REGEXP.exec(path4)){
        let escapeCount = 0;
        let index = m.index;
        while(path4.charAt(--index) === "\\"){
            escapeCount++;
        }
        if (escapeCount % 2 === 1) {
            continue;
        }
        if (keysOffset + i5 === keys.length || keys[keysOffset + i5].offset > m.index) {
            keys.splice(keysOffset + i5, 0, {
                name: name++,
                optional: false,
                offset: m.index
            });
        }
        i5++;
    }
    path4 += end ? "$" : path4[path4.length - 1] === "/" ? "" : "(?=\\/|$)";
    return new RegExp(path4, flags);
}
const Layer = function Layer(path4, options = {
}, fn) {
    if (!(this instanceof Layer)) {
        return new Layer(path4, options, fn);
    }
    this.handle = fn;
    this.name = fn.name || "<anonymous>";
    this.params = undefined;
    this.path = undefined;
    this.regexp = pathToRegexp(path4, this.keys = [], options);
    this.regexp.fast_star = path4 === "*";
    this.regexp.fast_slash = path4 === "/" && options.end === false;
};
Layer.prototype.handle_error = async function handle_error(error, req, res, next) {
    let fn = this.handle;
    if (fn.length !== 4) {
        return next(error);
    }
    try {
        await fn(error, req, res, next);
    } catch (err) {
        next(err);
    }
};
Layer.prototype.handle_request = async function handle(req, res, next) {
    let fn = this.handle;
    if (fn.length > 3) {
        return next();
    }
    try {
        await fn(req, res, next);
    } catch (err) {
        next(err);
    }
};
Layer.prototype.match = function match(path4) {
    let match1;
    if (path4 != null) {
        if (this.regexp.fast_slash) {
            this.params = {
            };
            this.path = "";
            return true;
        }
        if (this.regexp.fast_star) {
            this.params = {
                "0": decode_param(path4)
            };
            this.path = path4;
            return true;
        }
        match1 = this.regexp.exec(path4);
    }
    if (!match1) {
        this.params = undefined;
        this.path = undefined;
        return false;
    }
    this.params = {
    };
    this.path = match1[0];
    let keys = this.keys;
    let params = this.params;
    for(let i5 = 1; i5 < match1.length; i5++){
        let key = keys[i5 - 1];
        let prop = key.name;
        let val = decode_param(match1[i5]);
        if (val !== undefined || !Object.prototype.hasOwnProperty.call(params, prop)) {
            params[prop] = val;
        }
    }
    return true;
};
function decode_param(val) {
    if (typeof val !== "string" || val.length === 0) {
        return val;
    }
    try {
        return decodeURIComponent(val);
    } catch (err) {
        if (err instanceof URIError) {
            err.message = "Failed to decode param '" + val + "'";
            err.status = 400;
        }
        throw err;
    }
}
const Route = function Route(path4) {
    this.path = path4;
    this.stack = [];
    this.methods = {
    };
};
Route.prototype._handles_method = function _handles_method(method) {
    if (this.methods._all) {
        return true;
    }
    let name = method.toLowerCase();
    if (name === "head" && !this.methods["head"]) {
        name = "get";
    }
    return Boolean(this.methods[name]);
};
Route.prototype._options = function _options() {
    let methods1 = Object.keys(this.methods);
    if (this.methods.get && !this.methods.head) {
        methods1.push("head");
    }
    for(let i5 = 0; i5 < methods1.length; i5++){
        methods1[i5] = methods1[i5].toUpperCase();
    }
    return methods1;
};
Route.prototype.dispatch = function dispatch(req, res, done) {
    let idx = 0;
    let stack = this.stack;
    if (stack.length === 0) {
        return done();
    }
    let method = req.method.toLowerCase();
    if (method === "head" && !this.methods["head"]) {
        method = "get";
    }
    req.route = this;
    next();
    function next(err) {
        if (err && err === "route") {
            return done();
        }
        if (err && err === "router") {
            return done(err);
        }
        let layer = stack[idx++];
        if (!layer) {
            return done(err);
        }
        if (layer.method && layer.method !== method) {
            return next(err);
        }
        if (err) {
            layer.handle_error(err, req, res, next);
        } else {
            layer.handle_request(req, res, next);
        }
    }
};
Route.prototype.all = function all() {
    let handles = Array.prototype.slice.call(arguments).flat(1);
    for(let i5 = 0; i5 < handles.length; i5++){
        let handle1 = handles[i5];
        if (typeof handle1 !== "function") {
            let type2 = Object.prototype.toString.call(handle1);
            let msg1 = "Route.all() requires a callback function but got a " + type2;
            throw new TypeError(msg1);
        }
        let layer = Layer("/", {
        }, handle1);
        layer.method = undefined;
        this.methods._all = true;
        this.stack.push(layer);
    }
    return this;
};
methods.forEach(function(method) {
    Route.prototype[method] = function() {
        let handles = Array.prototype.slice.call(arguments).flat(1);
        for(let i5 = 0; i5 < handles.length; i5++){
            let handle1 = handles[i5];
            if (typeof handle1 !== "function") {
                let type2 = Object.prototype.toString.call(handle1);
                let msg1 = "Route." + method + "() requires a callback function but got a " + type2;
                throw new Error(msg1);
            }
            let layer = Layer("/", {
            }, handle1);
            layer.method = method;
            this.methods[method] = true;
            this.stack.push(layer);
        }
        return this;
    };
});
function merge3(a, b) {
    if (a && b) {
        for(let key in b){
            a[key] = b[key];
        }
    }
    return a;
}
function parseUrl(req) {
    const url = req.url;
    if (url === undefined) {
        return undefined;
    }
    let parsed = req._parsedUrl;
    if (fresh(url, parsed)) {
        return parsed;
    }
    parsed = fastParse(url);
    parsed._raw = url;
    return req._parsedUrl = parsed;
}
function fastParse(str2) {
    if (typeof str2 !== "string" || str2.charCodeAt(0) !== 47) {
        try {
            return new URL(str2);
        } catch (_) {
        }
    }
    let pathname = str2;
    let query = null;
    let search = null;
    for(let i5 = 1; i5 < str2.length; i5++){
        switch(str2.charCodeAt(i5)){
            case 63:
                if (search === null) {
                    pathname = str2.substring(0, i5);
                    query = str2.substring(i5 + 1);
                    search = str2.substring(i5);
                }
                break;
            case 9:
            case 10:
            case 12:
            case 13:
            case 32:
            case 35:
            case 160:
            case 65279:
                return new URL(str2);
        }
    }
    const url = {
    };
    url.path = str2 || null;
    url.href = str2 || null;
    url.pathname = pathname || null;
    url.query = query || null;
    url.search = search || null;
    url.searchParams = new URLSearchParams(search || "");
    return url;
}
function fresh(url, parsedUrl) {
    return typeof parsedUrl === "object" && parsedUrl !== null && parsedUrl._raw === url;
}
const objectRegExp = /^\[object (\S+)\]$/;
const setPrototypeOf = Object.setPrototypeOf;
const Router = function(options = {
}) {
    function router(req, res, next) {
        router.handle(req, res, next);
    }
    setPrototypeOf(router, Router);
    router.params = {
    };
    router._params = [];
    router.caseSensitive = options.caseSensitive;
    router.mergeParams = options.mergeParams;
    router.strict = options.strict;
    router.stack = [];
    return router;
};
Router.param = function param(name, fn) {
    var params = this._params;
    var len = params.length;
    var ret;
    if (typeof name !== "string") {
        throw new Error("invalid param() call for " + name + ", value must be a string");
    }
    for(var i5 = 0; i5 < len; ++i5){
        if (ret = params[i5](name, fn)) {
            fn = ret;
        }
    }
    if ("function" !== typeof fn) {
        throw new Error("invalid param() call for " + name + ", got " + fn);
    }
    (this.params[name] = this.params[name] || []).push(fn);
    return this;
};
Router.handle = function handle1(req, res, out = ()=>{
}) {
    const self = this;
    let idx = 0;
    let protohost = getProtohost(req.url) || "";
    let removed = "";
    let slashAdded = false;
    let paramcalled = {
    };
    let options = [];
    let stack = self.stack;
    let parentParams = req.params;
    let parentUrl = req.baseUrl || "";
    let done = restore(out, req, "baseUrl", "next", "params");
    req.next = next;
    if (req.method === "OPTIONS") {
        done = wrap(done, function(old, err) {
            if (err || options.length === 0) {
                return old(err);
            }
            sendOptionsResponse(res, options, old);
        });
    }
    req.baseUrl = parentUrl;
    req.originalUrl = req.originalUrl || req.url;
    next();
    function next(err) {
        let layerError = err === "route" ? null : err;
        if (slashAdded) {
            req.url = req.url.substr(1);
            slashAdded = false;
        }
        if (removed.length !== 0) {
            req.baseUrl = parentUrl;
            req.url = protohost + removed + req.url.substr(protohost.length);
            removed = "";
        }
        if (layerError === "router") {
            setImmediate(done, null);
            return;
        }
        if (idx >= stack.length) {
            setImmediate(done, layerError);
            return;
        }
        let path4 = (parseUrl(req) || {
        }).pathname;
        if (path4 == null) {
            return done(layerError);
        }
        let layer;
        let match1;
        let route;
        while(match1 !== true && idx < stack.length){
            layer = stack[idx++];
            match1 = matchLayer(layer, path4);
            route = layer.route;
            if (typeof match1 !== "boolean") {
                layerError = layerError || match1;
            }
            if (match1 !== true) {
                continue;
            }
            if (!route) {
                continue;
            }
            if (layerError) {
                match1 = false;
                continue;
            }
            let method = req.method;
            let has_method = route._handles_method(method);
            if (!has_method && method === "OPTIONS") {
                appendMethods(options, route._options());
            }
            if (!has_method && method !== "HEAD") {
                match1 = false;
                continue;
            }
        }
        if (match1 !== true) {
            return done(layerError);
        }
        if (route) {
            req.route = route;
        }
        req.params = self.mergeParams ? mergeParams(layer.params, parentParams) : layer.params;
        let layerPath = layer.path;
        self.process_params(layer, paramcalled, req, res, function(err1) {
            if (err1) {
                return next(layerError || err1);
            }
            if (route) {
                return layer.handle_request(req, res, next);
            }
            trim_prefix(layer, layerError, layerPath, path4);
        });
    }
    function trim_prefix(layer, layerError, layerPath, path4) {
        if (layerPath.length !== 0) {
            let c = path4[layerPath.length];
            if (c && c !== "/" && c !== ".") {
                return next(layerError);
            }
            removed = layerPath;
            req.url = protohost + req.url.substr(protohost.length + removed.length);
            if (!protohost && req.url[0] !== "/") {
                req.url = "/" + req.url;
                slashAdded = true;
            }
            req.baseUrl = parentUrl + (removed[removed.length - 1] === "/" ? removed.substring(0, removed.length - 1) : removed);
        }
        if (layerError) {
            layer.handle_error(layerError, req, res, next);
        } else {
            layer.handle_request(req, res, next);
        }
    }
};
Router.process_params = function process_params(layer, called, req, res, done) {
    let params = this.params;
    let keys = layer.keys;
    if (!keys || keys.length === 0) {
        return done();
    }
    let i5 = 0;
    let name;
    let paramIndex = 0;
    let key;
    let paramVal;
    let paramCallbacks;
    let paramCalled;
    function param1(err) {
        if (err) {
            return done(err);
        }
        if (i5 >= keys.length) {
            return done();
        }
        paramIndex = 0;
        key = keys[i5++];
        name = key.name;
        paramVal = req.params[name];
        paramCallbacks = params[name];
        paramCalled = called[name];
        if (paramVal === undefined || !paramCallbacks) {
            return param1();
        }
        if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && paramCalled.error !== "route")) {
            req.params[name] = paramCalled.value;
            return param1(paramCalled.error);
        }
        called[name] = paramCalled = {
            error: null,
            match: paramVal,
            value: paramVal
        };
        paramCallback();
    }
    function paramCallback(err) {
        let fn = paramCallbacks[paramIndex++];
        paramCalled.value = req.params[key.name];
        if (err) {
            paramCalled.error = err;
            param1(err);
            return;
        }
        if (!fn) return param1();
        try {
            fn(req, res, paramCallback, paramVal, key.name);
        } catch (e) {
            paramCallback(e);
        }
    }
    param1();
};
Router.use = function use(fn) {
    let offset = 0;
    let path4 = "/";
    if (typeof fn !== "function") {
        let arg = fn;
        while(Array.isArray(arg) && arg.length !== 0){
            arg = arg[0];
        }
        if (typeof arg !== "function") {
            offset = 1;
            path4 = fn;
        }
    }
    let callbacks = Array.prototype.slice.call(arguments, offset).flat(1);
    if (callbacks.length === 0) {
        throw new TypeError("Router.use() requires a middleware function");
    }
    for(let i5 = 0; i5 < callbacks.length; i5++){
        let fn1 = callbacks[i5];
        if (typeof fn1 !== "function") {
            throw new TypeError("Router.use() requires a middleware function but got a " + gettype(fn1));
        }
        let layer = new Layer(path4, {
            sensitive: this.caseSensitive,
            strict: false,
            end: false
        }, fn1);
        layer.route = undefined;
        this.stack.push(layer);
    }
    return this;
};
Router.route = function route(path4) {
    let route1 = new Route(path4);
    let layer = new Layer(path4, {
        sensitive: this.caseSensitive,
        strict: this.strict,
        end: true
    }, route1.dispatch.bind(route1));
    layer.route = route1;
    this.stack.push(layer);
    return route1;
};
methods.concat("all").forEach(function(method) {
    Router[method] = function(path4) {
        let route1 = this.route(path4);
        route1[method].apply(route1, Array.prototype.slice.call(arguments, 1));
        return this;
    };
});
function appendMethods(list, addition) {
    for(let i5 = 0; i5 < addition.length; i5++){
        let method = addition[i5];
        if (list.indexOf(method) === -1) {
            list.push(method);
        }
    }
}
function getProtohost(url) {
    if (typeof url !== "string" || url.length === 0 || url[0] === "/") {
        return undefined;
    }
    let searchIndex = url.indexOf("?");
    let pathLength = searchIndex !== -1 ? searchIndex : url.length;
    let fqdnIndex = url.substr(0, pathLength).indexOf("://");
    return fqdnIndex !== -1 ? url.substr(0, url.indexOf("/", 3 + fqdnIndex)) : undefined;
}
function gettype(obj) {
    let type2 = typeof obj;
    if (type2 !== "object") {
        return type2;
    }
    return Object.prototype.toString.call(obj).replace(objectRegExp, "$1");
}
function matchLayer(layer, path4) {
    try {
        return layer.match(path4);
    } catch (err) {
        return err;
    }
}
function mergeParams(params, parent) {
    if (typeof parent !== "object" || !parent) {
        return params;
    }
    let obj = merge3({
    }, parent);
    if (!(0 in params) || !(0 in parent)) {
        return merge3(obj, params);
    }
    let i5 = 0;
    let o = 0;
    while(i5 in params){
        i5++;
    }
    while(o in parent){
        o++;
    }
    for(i5--; i5 >= 0; i5--){
        params[i5 + o] = params[i5];
        if (i5 < o) {
            delete params[i5];
        }
    }
    return merge3(obj, params);
}
function restore(fn, obj) {
    let props = new Array(arguments.length - 2);
    let vals = new Array(arguments.length - 2);
    for(let i5 = 0; i5 < props.length; i5++){
        props[i5] = arguments[i5 + 2];
        vals[i5] = obj[props[i5]];
    }
    return function() {
        for(let i6 = 0; i6 < props.length; i6++){
            obj[props[i6]] = vals[i6];
        }
        return fn.apply(this, arguments);
    };
}
function sendOptionsResponse(res, options, next) {
    try {
        let body = options.join(",");
        res.set("Allow", body);
        res.send(body);
    } catch (err) {
        next(err);
    }
}
function wrap(old, fn) {
    return function proxy() {
        let args = new Array(arguments.length + 1);
        args[0] = old;
        for(let i5 = 0, len = arguments.length; i5 < len; i5++){
            args[i5 + 1] = arguments[i5];
        }
        fn.apply(this, args);
    };
}
const create2 = Object.create;
const setPrototypeOf1 = Object.setPrototypeOf;
const init1 = function(app) {
    return function opineInit(req, res, next) {
        if (app.enabled("x-powered-by")) res.set("X-Powered-By", "Opine");
        req.res = res;
        res.req = req;
        req.next = next;
        setPrototypeOf1(req, app.request);
        setPrototypeOf1(res, app.response);
        res.locals = res.locals || create2(null);
        next();
    };
};
const query = function(options) {
    let opts = merge3({
    }, options);
    let queryParse = lib.parse;
    if (typeof options === "function") {
        queryParse = options;
        opts = undefined;
    }
    if (opts !== undefined && opts.allowPrototypes === undefined) {
        opts.allowPrototypes = true;
    }
    return function opineQuery(req, _res, next) {
        if (!req.query) {
            const value3 = parseUrl(req)?.query;
            req.query = queryParse(value3, opts);
        }
        next();
    };
};
const DOUBLE_SPACE_REGEXP = /\x20{2}/g;
const NEWLINE_REGEXP = /\n/g;
function createHtmlDocument(message6) {
    const body = escapeHtml(message6).replace(NEWLINE_REGEXP, "<br>").replace(DOUBLE_SPACE_REGEXP, " &nbsp;");
    return "<!DOCTYPE html>\n" + '<html lang="en">\n' + "<head>\n" + '<meta charset="utf-8">\n' + "<title>Error</title>\n" + "</head>\n" + "<body>\n" + "<pre>" + body + "</pre>\n" + "</body>\n" + "</html>\n";
}
function finalHandler(req, res) {
    return function(err) {
        let headers2;
        let msg1;
        let status;
        if (err) {
            status = getErrorStatusCode(err);
            if (status === undefined) {
                status = getResponseStatusCode(res);
            } else {
                headers2 = getErrorHeaders(err);
            }
            msg1 = getErrorMessage(err, status);
        } else {
            status = 404;
            msg1 = "Cannot " + req.method + " " + getResourceName(req);
        }
        send(req, res, status, headers2, msg1);
    };
}
function getErrorHeaders(err) {
    if (!err.headers || typeof err.headers !== "object") {
        return undefined;
    }
    const headers2 = Object.create(null);
    const keys = Object.keys(err.headers);
    for(let i5 = 0; i5 < keys.length; i5++){
        const key = keys[i5];
        headers2[key] = err.headers[key];
    }
    return headers2;
}
function getErrorMessage(err, status) {
    let msg1 = err.stack;
    if (!msg1 && typeof err.toString === "function") {
        msg1 = err.toString();
    }
    return msg1 || STATUS_TEXT.get(status);
}
function getErrorStatusCode(err) {
    if (typeof err.status === "number" && err.status >= 400 && err.status < 600) {
        return err.status;
    }
    return undefined;
}
function getResourceName(req) {
    try {
        return parseUrl(req).pathname;
    } catch (e) {
        return "resource";
    }
}
function getResponseStatusCode(res) {
    let status = res.status;
    if (typeof status !== "number" || status < 400 || status > 599) {
        status = 500;
    }
    return status;
}
function send(req, res, status, headers2, message6) {
    const body = createHtmlDocument(message6);
    res.status = status;
    res.statusMessage = STATUS_TEXT.get(status);
    setHeaders(res, headers2);
    res.set("Content-Security-Policy", "default-src 'none'");
    res.set("X-Content-Type-Options", "nosniff");
    res.set("Content-Type", "text/html; charset=utf-8");
    if (req.method !== "HEAD") {
        res.body = body;
    }
    if (!res.written) {
        req.respond(res);
    }
}
function setHeaders(res, headers2) {
    if (!headers2) {
        return;
    }
    const keys = Object.keys(headers2);
    for(let i5 = 0; i5 < keys.length; i5++){
        const key = keys[i5];
        res.set(key, headers2[key]);
    }
}
function entitytag(entity) {
    if (entity.length === 0) {
        return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
    }
    if (entity instanceof Uint8Array) {
        const decoder2 = new TextDecoder();
        entity = decoder2.decode(entity);
    }
    const sha1 = new Sha1();
    sha1.update(entity);
    sha1.digest();
    const hash = sha1.toString().substring(0, 27);
    const len = typeof entity === "string" ? encoder.encode(entity).byteLength : entity.byteLength;
    return `"${len.toString(16)}-${hash}"`;
}
function isstats(obj) {
    return obj && typeof obj === "object" && "atime" in obj && "mtime" in obj && "birthtime" in obj && "size" in obj && typeof obj.size === "number";
}
function stattag(stat) {
    const mtime = new Date(stat.mtime).getTime().toString(16);
    const size7 = stat.size.toString(16);
    return '"' + size7 + "-" + mtime + '"';
}
function etag(entity, options) {
    if (entity == null) {
        throw new TypeError("argument entity is required");
    }
    let entityObj = entity;
    if (typeof entity === "string") {
        try {
            entityObj = JSON.parse(entity);
        } catch (_) {
        }
    }
    const isStats = isstats(entityObj);
    const weak = options && typeof options.weak === "boolean" ? options.weak : isStats;
    if (!isStats && typeof entity !== "string" && !(entity instanceof Uint8Array)) {
        throw new TypeError("argument entity must be string, Uint8Array, or Deno.FileInfo");
    }
    const tag = isStats ? stattag(entityObj) : entitytag(entity);
    return weak ? `W/${tag}` : tag;
}
function createETagGenerator(options) {
    return function generateETag(body) {
        return etag(body, options);
    };
}
const etag1 = createETagGenerator({
    weak: false
});
const wetag = createETagGenerator({
    weak: true
});
const compileETag = function(value3) {
    let fn;
    if (typeof value3 === "function") {
        return value3;
    }
    switch(value3){
        case true:
            fn = wetag;
            break;
        case false: break;
        case "strong":
            fn = etag1;
            break;
        case "weak":
            fn = wetag;
            break;
        default:
            throw new TypeError(`unknown value for etag function: ${value3}`);
    }
    return fn;
};
function newObject() {
    return {
    };
}
function parseExtendedQueryString(str2) {
    return lib.parse(str2, {
        allowPrototypes: true
    });
}
function compileQueryParser(value3) {
    if (typeof value3 === "function") {
        return value3;
    }
    switch(value3){
        case true:
            return parse3;
        case false:
            return newObject;
        case "extended":
            return parseExtendedQueryString;
        case "simple":
            return parse3;
        default:
            throw new TypeError(`unknown value for query parser function: ${value3}`);
    }
}
function forwarded(req) {
    if (!req) {
        throw new TypeError("argument req is required");
    }
    const proxyAddrs = parse17(req.headers.get("x-forwarded-for") ?? "");
    const { hostname: socketAddr  } = req.conn.remoteAddr;
    const addrs = [
        socketAddr
    ].concat(proxyAddrs);
    return addrs;
}
function parse17(header) {
    const list = [];
    let start = header.length;
    let end = header.length;
    for(let i5 = header.length - 1; i5 >= 0; i5--){
        switch(header.charCodeAt(i5)){
            case 32:
                if (start === end) {
                    start = end = i5;
                }
                break;
            case 44:
                if (start !== end) {
                    list.push(header.substring(start, end));
                }
                start = end = i5;
                break;
            default:
                start = i5;
                break;
        }
    }
    if (start !== end) {
        list.push(header.substring(start, end));
    }
    return list;
}
const DIGIT_REGEXP = /^[0-9]+$/;
const isip = ipaddr.isValid;
const parseip = ipaddr.parse;
const IP_RANGES = {
    linklocal: [
        "169.254.0.0/16",
        "fe80::/10"
    ],
    loopback: [
        "127.0.0.1/8",
        "::1/128"
    ],
    uniquelocal: [
        "10.0.0.0/8",
        "172.16.0.0/12",
        "192.168.0.0/16",
        "fc00::/7"
    ]
};
function all1(req, trust) {
    const addrs = forwarded(req);
    if (!trust) {
        return addrs;
    }
    if (typeof trust !== "function") {
        trust = compile(trust);
    }
    for(var i5 = 0; i5 < addrs.length - 1; i5++){
        if (trust(addrs[i5], i5)) continue;
        addrs.length = i5 + 1;
    }
    return addrs;
}
function compile(value3) {
    if (!value3) {
        throw new TypeError("argument is required");
    }
    let trust;
    if (typeof value3 === "string") {
        trust = [
            value3
        ];
    } else if (Array.isArray(value3)) {
        trust = value3.slice();
    } else {
        throw new TypeError("unsupported trust argument");
    }
    for(var i5 = 0; i5 < trust.length; i5++){
        value3 = trust[i5];
        if (!Object.prototype.hasOwnProperty.call(IP_RANGES, value3)) {
            continue;
        }
        value3 = IP_RANGES[value3];
        trust.splice.apply(trust, [
            i5,
            1,
            ...value3
        ]);
        i5 += value3.length - 1;
    }
    return compileTrust(compileRangeSubnets(trust));
}
function compileRangeSubnets(arr) {
    const rangeSubnets = new Array(arr.length);
    for(let i5 = 0; i5 < arr.length; i5++){
        rangeSubnets[i5] = parseipNotation(arr[i5]);
    }
    return rangeSubnets;
}
function compileTrust(rangeSubnets) {
    const len = rangeSubnets.length;
    return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
}
function parseipNotation(note) {
    const pos = note.lastIndexOf("/");
    const str2 = pos !== -1 ? note.substring(0, pos) : note;
    if (!isip(str2)) {
        throw new TypeError("invalid IP address: " + str2);
    }
    let ip = parseip(str2);
    if (pos === -1 && ip.kind() === "ipv6" && ip.isIPv4MappedAddress()) {
        ip = ip.toIPv4Address();
    }
    const max = ip.kind() === "ipv6" ? 128 : 32;
    let range = pos !== -1 ? note.substring(pos + 1, note.length) : null;
    if (range === null) {
        range = max;
    } else if (DIGIT_REGEXP.test(range)) {
        range = parseInt(range, 10);
    } else if (ip.kind() === "ipv4" && isip(range)) {
        range = parseNetmask(range);
    } else {
        range = null;
    }
    if (range <= 0 || range > max) {
        throw new TypeError("invalid range on address: " + note);
    }
    return [
        ip,
        range
    ];
}
function parseNetmask(netmask) {
    const ip = parseip(netmask);
    const kind = ip.kind();
    return kind === "ipv4" ? ip.prefixLengthFromSubnetMask() : null;
}
function proxyaddr(req, trust) {
    if (!req) {
        throw new TypeError("req argument is required");
    }
    if (!trust) {
        throw new TypeError("trust argument is required");
    }
    const addrs = all1(req, trust);
    const addr = addrs[addrs.length - 1];
    return addr;
}
function trustNone() {
    return false;
}
function trustMulti(subnets) {
    return function trust(addr) {
        if (!isip(addr)) return false;
        const ip = parseip(addr);
        let ipconv;
        const kind = ip.kind();
        for(let i5 = 0; i5 < subnets.length; i5++){
            const subnet = subnets[i5];
            const subnetip = subnet[0];
            const subnetkind = subnetip.kind();
            const subnetrange = subnet[1];
            let trusted = ip;
            if (kind !== subnetkind) {
                if (subnetkind === "ipv4" && !ip.isIPv4MappedAddress()) {
                    continue;
                }
                if (!ipconv) {
                    ipconv = subnetkind === "ipv4" ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
                }
                trusted = ipconv;
            }
            if (trusted.match(subnetip, subnetrange)) {
                return true;
            }
        }
        return false;
    };
}
function trustSingle(subnet) {
    const subnetip = subnet[0];
    const subnetkind = subnetip.kind();
    const subnetisipv4 = subnetkind === "ipv4";
    const subnetrange = subnet[1];
    return function trust(addr) {
        if (!isip(addr)) return false;
        let ip = parseip(addr);
        const kind = ip.kind();
        if (kind !== subnetkind) {
            if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
                return false;
            }
            ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
        }
        return ip.match(subnetip, subnetrange);
    };
}
function compileTrust1(value3) {
    if (typeof value3 === "function") return value3;
    if (value3 === true) {
        return function() {
            return true;
        };
    }
    if (typeof value3 === "number") {
        return function(_, i5) {
            return i5 < value3;
        };
    }
    if (typeof value3 === "string") {
        value3 = value3.split(/ *, */);
    }
    return compile(value3 || []);
}
function tryStat(path4) {
    try {
        return Deno.statSync(path4);
    } catch (e) {
        return undefined;
    }
}
function toPath(pathLike) {
    return pathLike.startsWith("file:") ? fromFileUrl2(pathLike) : pathLike;
}
class View {
    constructor(fileName, options1 = {
    }){
        this.defaultEngine = options1.defaultEngine;
        this.ext = extname2(fileName);
        this.name = fileName;
        if (Array.isArray(options1.root)) {
            this.root = options1.root.map(toPath);
        } else {
            this.root = toPath(options1.root);
        }
        if (!this.ext && !this.defaultEngine) {
            throw new Error("No default engine was specified and no extension was provided.");
        }
        if (!this.ext) {
            this.ext = this.defaultEngine[0] !== "." ? `.${this.defaultEngine}` : this.defaultEngine;
            fileName += this.ext;
        }
        if (!options1.engines[this.ext]) {
            throw new Error(`Could not find a view engine for extension "${this.ext}"`);
        }
        this.engine = options1.engines[this.ext];
        this.path = this.lookup(fileName);
    }
    resolve(dir, file) {
        let path4 = join2(dir, file);
        let stat = tryStat(path4);
        if (stat && stat.isFile) {
            return path4;
        }
        const ext = this.ext;
        path4 = join2(dir, basename2(file, ext), `index${ext}`);
        stat = tryStat(path4);
        if (stat && stat.isFile) {
            return path4;
        }
    }
    lookup(name) {
        const roots = [].concat(this.root);
        let path4;
        for(let i5 = 0; i5 < roots.length && !path4; i5++){
            const root = roots[i5];
            const loc = resolve2(root, name);
            const dir = dirname2(loc);
            const file = basename2(loc);
            path4 = this.resolve(dir, file);
        }
        return path4;
    }
    async render(options, callback) {
        const out = await this.engine(this.path, options);
        callback(undefined, out);
    }
}
const create3 = Object.create;
const setPrototypeOf2 = Object.setPrototypeOf;
const slice = Array.prototype.slice;
const trustProxyDefaultSymbol = "@@symbol:trust_proxy_default";
const app = {
};
app.init = function init1() {
    this.cache = {
    };
    this.engines = {
    };
    this.settings = {
    };
    this.defaultConfiguration();
};
app.defaultConfiguration = function defaultConfiguration() {
    this.enable("x-powered-by");
    this.set("etag", "weak");
    this.set("query parser", "extended");
    this.set("subdomain offset", 2);
    this.set("trust proxy", false);
    Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
        configurable: true,
        value: true
    });
    const self = this;
    this.on("mount", function onmount(parent) {
        if (self.settings[trustProxyDefaultSymbol] === true && typeof parent.settings["trust proxy fn"] === "function") {
            delete self.settings["trust proxy"];
            delete self.settings["trust proxy fn"];
        }
        setPrototypeOf2(self.request, parent.request);
        setPrototypeOf2(self.response, parent.response);
        setPrototypeOf2(self.engines, parent.engines);
        setPrototypeOf2(self.settings, parent.settings);
    });
    this.locals = create3(null);
    this.mountpath = "/";
    this.locals.settings = this.settings;
    this.set("view", View);
    this.set("views", resolve2("views"));
    this.set("jsonp callback name", "callback");
    this.enable("view cache");
};
app.lazyrouter = function lazyrouter() {
    if (!this._router) {
        this._router = new Router({
            caseSensitive: this.enabled("case sensitive routing"),
            strict: this.enabled("strict routing")
        });
        this._router.use(query(this.get("query parser fn")));
        this._router.use(init1(this));
    }
};
app.handle = function handle2(req, res, next) {
    const router = this._router;
    next = next || finalHandler(req, res);
    if (!router) {
        return next();
    }
    router.handle(req, res, next);
};
const isPath = (thing)=>typeof thing === "string" || thing instanceof RegExp
;
app.use = function use1(...args) {
    const firstArg = args[0];
    const [path4, ...nonPathArgs] = (Array.isArray(firstArg) ? isPath(firstArg[0]) : isPath(firstArg)) ? args : [
        "/",
        ...args
    ];
    const fns = nonPathArgs.flat(Infinity);
    if (fns.length === 0) {
        throw new TypeError("app.use() requires a middleware function");
    }
    this.lazyrouter();
    const router = this._router;
    fns.forEach(function(fn) {
        if (!fn || !fn.handle || !fn.set) {
            return router.use(path4, fn);
        }
        fn.mountpath = path4;
        fn.parent = this;
        router.use(path4, function mounted_app(req, res, next) {
            const orig = req.app;
            fn.handle(req, res, (err)=>{
                setPrototypeOf2(req, orig.request);
                setPrototypeOf2(res, orig.response);
                next(err);
            });
        });
        fn.emit("mount", this);
    }, this);
    return this;
};
app.route = function route1(prefix2) {
    this.lazyrouter();
    return this._router.route(prefix2);
};
app.engine = function engine(ext, fn) {
    const extension = ext[0] !== "." ? `.${ext}` : ext;
    this.engines[extension] = fn;
    return this;
};
app.param = function param1(name, fn) {
    this.lazyrouter();
    if (Array.isArray(name)) {
        for(var i5 = 0; i5 < name.length; i5++){
            this.param(name[i5], fn);
        }
        return this;
    }
    this._router.param(name, fn);
    return this;
};
app.set = function set(setting, value3) {
    if (arguments.length === 1) {
        return this.settings[setting];
    }
    this.settings[setting] = value3;
    switch(setting){
        case "etag":
            this.set("etag fn", compileETag(value3));
            break;
        case "query parser":
            this.set("query parser fn", compileQueryParser(value3));
            break;
        case "trust proxy":
            this.set("trust proxy fn", compileTrust1(value3));
            Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
                configurable: true,
                value: false
            });
            break;
    }
    return this;
};
app.path = function path4() {
    return this.parent ? this.parent.path() + this.mountpath : "";
};
app.enabled = function enabled(setting) {
    return Boolean(this.set(setting));
};
app.disabled = function disabled(setting) {
    return !this.set(setting);
};
app.enable = function enable(setting) {
    return this.set(setting, true);
};
app.disable = function disable(setting) {
    return this.set(setting, false);
};
methods.forEach((method)=>{
    app[method] = function(path5) {
        if (method === "get" && arguments.length === 1) {
            return this.set(path5);
        }
        this.lazyrouter();
        const route2 = this._router.route(path5);
        route2[method].apply(route2, slice.call(arguments, 1));
        return this;
    };
});
app.all = function all2(path5) {
    this.lazyrouter();
    const route2 = this._router.route(path5);
    const args = slice.call(arguments, 1);
    for(let i6 = 0; i6 < methods.length; i6++){
        route2[methods[i6]].apply(route2, args);
    }
    return this;
};
async function tryRender(view, options2, callback) {
    try {
        await view.render(options2, callback);
    } catch (err) {
        callback(err);
    }
}
app.render = function render(name, options2, callback = ()=>{
}) {
    const cache = this.cache;
    const engines = this.engines;
    const renderOptions = {
    };
    let done = callback;
    let view;
    name = name.startsWith("file:") ? fromFileUrl2(name) : name;
    if (typeof options2 === "function") {
        done = options2;
        options2 = {
        };
    }
    merge3(renderOptions, this.locals);
    if (options2._locals) {
        merge3(renderOptions, options2._locals);
    }
    merge3(renderOptions, options2);
    if (renderOptions.cache == null) {
        renderOptions.cache = this.enabled("view cache");
    }
    if (renderOptions.cache) {
        view = cache[name];
    }
    if (!view) {
        const View1 = this.get("view");
        view = new View1(name, {
            defaultEngine: this.get("view engine"),
            engines,
            root: this.get("views")
        });
        if (!view.path) {
            const dirs = Array.isArray(view.root) && view.root.length > 1 ? `directories "${view.root.slice(0, -1).join('", "')}" or "${view.root[view.root.length - 1]}"` : `directory "${view.root}"`;
            const err = new Error(`Failed to lookup view "${name}" in views ${dirs}`);
            err.view = view;
            return done(err);
        }
        if (renderOptions.cache) {
            cache[name] = view;
        }
    }
    tryRender(view, renderOptions, done);
};
app.listen = function listen(options2, callback) {
    if (typeof options2 === "undefined") {
        options2 = {
            port: 0
        };
    } else if (typeof options2 === "number") {
        options2 = `:${options2}`;
    }
    const isTlsOptions = typeof options2 !== "string" && typeof options2.certFile !== "undefined";
    const server = isTlsOptions ? serveTLS(options2) : serve(options2);
    const start = async ()=>{
        try {
            for await (const request of server){
                this(request);
            }
        } catch (serverError) {
            if (server) {
                try {
                    server.close();
                } catch (err) {
                    if (!(err instanceof Deno.errors.BadResource)) {
                        throw err;
                    }
                }
            }
            throw serverError;
        }
    };
    start();
    if (callback && typeof callback === "function") callback();
    return server;
};
function defineGetter(obj, name, getter) {
    Object.defineProperty(obj, name, {
        configurable: true,
        enumerable: true,
        get: getter
    });
}
const CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
function fresh1(reqHeaders, resHeaders) {
    const modifiedSince = reqHeaders["if-modified-since"];
    const noneMatch = reqHeaders["if-none-match"];
    if (!modifiedSince && !noneMatch) {
        return false;
    }
    const cacheControl = reqHeaders["cache-control"];
    if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
        return false;
    }
    if (noneMatch && noneMatch !== "*") {
        const etag2 = resHeaders["etag"];
        if (!etag2) {
            return false;
        }
        let etagStale = true;
        const matches = parseTokenList(noneMatch);
        for(let i6 = 0; i6 < matches.length; i6++){
            const match1 = matches[i6];
            if (match1 === etag2 || match1 === "W/" + etag2 || "W/" + match1 === etag2) {
                etagStale = false;
                break;
            }
        }
        if (etagStale) {
            return false;
        }
    }
    if (modifiedSince) {
        const lastModified = resHeaders["last-modified"];
        const modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince));
        if (modifiedStale) {
            return false;
        }
    }
    return true;
}
function parseHttpDate(date) {
    const timestamp = date && Date.parse(date);
    return typeof timestamp === "number" ? timestamp : NaN;
}
function parseTokenList(str2) {
    const list = [];
    let start = 0;
    let end = 0;
    for(let i6 = 0, len = str2.length; i6 < len; i6++){
        switch(str2.charCodeAt(i6)){
            case 32:
                if (start === end) {
                    start = end = i6 + 1;
                }
                break;
            case 44:
                list.push(str2.substring(start, end));
                start = end = i6 + 1;
                break;
            default:
                end = i6 + 1;
                break;
        }
    }
    list.push(str2.substring(start, end));
    return list;
}
const request = Object.create(ServerRequest.prototype);
request.accepts = function(...args) {
    const accept = new Accepts(this.headers);
    return accept.types.call(accept, args.flat(1));
};
request.acceptsCharsets = function(...args) {
    const accept = new Accepts(this.headers);
    return accept.charsets.call(accept, args.flat(1));
};
request.acceptsEncodings = function(...args) {
    const accept = new Accepts(this.headers);
    return accept.encodings.call(accept, args.flat(1));
};
request.acceptsLanguages = function(...args) {
    const accept = new Accepts(this.headers);
    return accept.languages.call(accept, args.flat(1));
};
request.get = function get(name) {
    const lc = name.toLowerCase();
    switch(lc){
        case "referer":
        case "referrer":
            return this.headers.get("referrer") || this.headers.get("referer") || undefined;
        default:
            return this.headers.get(lc) || undefined;
    }
};
request.range = function range(size7, options2) {
    const range1 = this.get("Range");
    if (!range1) return;
    return rangeParser_1(size7, range1, options2);
};
request.is = function is1(types4) {
    let arr = types4;
    if (!Array.isArray(types4)) {
        arr = new Array(arguments.length);
        for(let i6 = 0; i6 < arr.length; i6++){
            arr[i6] = arguments[i6];
        }
    }
    return typeofrequest(this.headers, arr);
};
defineGetter(request, "protocol", function protocol() {
    const proto = this.proto.includes("https") ? "https" : "http";
    const trust = this.app.get("trust proxy fn");
    const { hostname: remoteAddress  } = this.conn.remoteAddr;
    if (!trust(remoteAddress, 0)) {
        return proto;
    }
    const header = this.get("X-Forwarded-Proto") ?? proto;
    const index = header.indexOf(",");
    return index !== -1 ? header.substring(0, index).trim() : header.trim();
});
defineGetter(request, "secure", function secure() {
    return this.protocol === "https";
});
defineGetter(request, "ip", function ip() {
    const trust = this.app.get("trust proxy fn");
    return proxyaddr(this, trust);
});
defineGetter(request, "ips", function ips() {
    const trust = this.app.get("trust proxy fn");
    const addrs = all1(this, trust);
    addrs.reverse().pop();
    return addrs;
});
defineGetter(request, "subdomains", function subdomains() {
    const hostname = this.hostname;
    if (!hostname) return [];
    const offset = this.app.get("subdomain offset");
    const subdomains1 = !isIP(hostname) ? hostname.split(".").reverse() : [
        hostname
    ];
    return subdomains1.slice(offset);
});
defineGetter(request, "path", function path5() {
    return (parseUrl(this) || {
    }).pathname;
});
defineGetter(request, "hostname", function hostname() {
    const trust = this.app.get("trust proxy fn");
    let host = this.get("X-Forwarded-Host");
    const { hostname: remoteAddress  } = this.conn.remoteAddr;
    if (!host || !trust(remoteAddress, 0)) {
        host = this.get("Host");
    } else if (host.indexOf(",") !== -1) {
        host = host.substring(0, host.indexOf(",")).trimRight();
    }
    if (!host) return;
    const offset = host[0] === "[" ? host.indexOf("]") + 1 : 0;
    const index = host.indexOf(":", offset);
    return index !== -1 ? host.substring(0, index) : host;
});
defineGetter(request, "fresh", function() {
    const method = this.method;
    const res = this.res;
    const status = res.status;
    if ("GET" !== method && "HEAD" !== method) {
        return false;
    }
    if (status >= 200 && status < 300 || 304 === status) {
        return fresh1(Object.fromEntries(this.headers), {
            "etag": res.get("ETag"),
            "last-modified": res.get("Last-Modified")
        });
    }
    return false;
});
defineGetter(request, "stale", function stale() {
    return !this.fresh;
});
defineGetter(request, "xhr", function xhr() {
    const val = this.get("X-Requested-With") || "";
    return val.toLowerCase() === "xmlhttprequest";
});
const ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
const HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
const NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
const QUOTE_REGEXP = /([\\"])/g;
const TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
const TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
function getLatin1(val) {
    return String(val).replace(NON_LATIN1_REGEXP, "?");
}
function createParams(filename) {
    if (filename === undefined) {
        return;
    }
    const params = {
    };
    if (typeof filename !== "string") {
        throw new TypeError("filename must be a string");
    }
    const name = basename2(filename);
    const isQuotedString = TEXT_REGEXP.test(name);
    const fallbackName = getLatin1(name);
    const hasFallback = typeof fallbackName === "string" && fallbackName !== name;
    if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
        params["filename*"] = name;
    }
    if (isQuotedString || hasFallback) {
        params.filename = hasFallback ? fallbackName : name;
    }
    return params;
}
function qString(val) {
    const str2 = String(val);
    return '"' + str2.replace(QUOTE_REGEXP, "\\$1") + '"';
}
function pencode(__char) {
    return "%" + String(__char).charCodeAt(0).toString(16).toUpperCase();
}
function uString(val) {
    const str2 = String(val);
    const encoded = encodeURIComponent(str2).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
    return "UTF-8''" + encoded;
}
function format12({ type: type2 , parameters  }) {
    if (!type2 || typeof type2 !== "string" || !TOKEN_REGEXP.test(type2)) {
        throw new TypeError("invalid type");
    }
    let string = String(type2).toLowerCase();
    if (parameters && typeof parameters === "object") {
        let param2;
        const params = Object.keys(parameters).sort();
        for(let i6 = 0; i6 < params.length; i6++){
            param2 = params[i6];
            const val = param2.substr(-1) === "*" ? uString(parameters[param2]) : qString(parameters[param2]);
            string += "; " + param2 + "=" + val;
        }
    }
    return string;
}
const contentDisposition = (type2, filename)=>{
    const parameters = createParams(filename);
    return format12({
        type: type2,
        parameters
    });
};
function stringify1(value3, replacer, spaces, escape) {
    let json = replacer || spaces ? JSON.stringify(value3, replacer, spaces) : JSON.stringify(value3);
    if (escape) {
        json = json.replace(/[<>&]/g, function(c) {
            switch(c.charCodeAt(0)){
                case 60:
                    return "\\u003c";
                case 62:
                    return "\\u003e";
                case 38:
                    return "\\u0026";
                default:
                    return c;
            }
        });
    }
    return json;
}
function acceptParams(str2) {
    const parts = str2.split(/ *; */);
    const ret = {
        value: parts[0],
        quality: 1,
        params: {
        }
    };
    for(let i6 = 1; i6 < parts.length; ++i6){
        const pms = parts[i6].split(/ *= */);
        if ("q" === pms[0]) {
            ret.quality = parseFloat(pms[1]);
        } else {
            ret.params[pms[0]] = pms[1];
        }
    }
    return ret;
}
const normalizeType1 = function(type2) {
    return ~type2.indexOf("/") ? acceptParams(type2) : {
        value: lookup(type2),
        params: {
        }
    };
};
const normalizeTypes = function(types4) {
    const ret = [];
    for(let i6 = 0; i6 < types4.length; ++i6){
        ret.push(normalizeType1(types4[i6]));
    }
    return ret;
};
function hasCookieNameProperty(value3) {
    return value3 && typeof value3 === "object" && typeof value3.name === "string";
}
function hasCookieRequiredProperties(value3) {
    return hasCookieNameProperty(value3) && typeof value3.value === "string";
}
class Response1 {
    status = 200;
    headers = new Headers();
    written = false;
    append(field, value) {
        if (Array.isArray(value)) {
            for(let i6 = 0, len = value.length; i6 < len; i6++){
                this.headers.append(field, value[i6]);
            }
        } else {
            this.headers.append(field, value);
        }
        return this;
    }
    attachment(filename) {
        if (filename) {
            this.type(extname2(filename));
        }
        this.set("Content-Disposition", contentDisposition("attachment", filename));
        return this;
    }
    cookie(nameOrCookie) {
        let cookie;
        if (typeof nameOrCookie === "string") {
            cookie = {
                ...arguments[2],
                name: nameOrCookie,
                value: arguments[1] ?? ""
            };
        } else if (hasCookieRequiredProperties(nameOrCookie)) {
            cookie = nameOrCookie;
        } else {
            throw new TypeError("response.cookie, args provided do not match one of the supported signatures: " + Array.prototype.join.call(arguments, ", "));
        }
        if (cookie.path == null) {
            cookie.path = "/";
        }
        setCookie(this, cookie);
        return this;
    }
    clearCookie(nameOrCookie) {
        if (typeof nameOrCookie === "string") {
            setCookie(this, {
                path: "/",
                ...arguments[1],
                value: "",
                expires: new Date(0),
                name: nameOrCookie
            });
        } else if (hasCookieNameProperty(nameOrCookie)) {
            setCookie(this, {
                path: "/",
                ...nameOrCookie,
                value: "",
                expires: new Date(0)
            });
        } else {
            throw new TypeError("res.clearCookie, args provided do not match one of the supported signatures: " + Array.prototype.join.call(arguments, ", "));
        }
        return this;
    }
    async download(path, filename) {
        this.set("Content-Disposition", contentDisposition("attachment", filename || path));
        try {
            await this.sendFile(path);
        } catch (err) {
            this.unset("Content-Disposition");
            throw err;
        }
    }
    async end(body) {
        if (body) {
            this.body = body;
        }
        this.written = true;
        await this.req.respond(this);
    }
    etag(chunk) {
        const etagFn = this.app.get("etag fn");
        if (typeof etagFn === "function" && typeof chunk.length) {
            const etag2 = etagFn(chunk);
            if (etag2) {
                this.set("ETag", etag2);
            }
        }
        return this;
    }
    format(obj) {
        const req = this.req;
        const next = req.next;
        const { default: fn , ...rest } = obj;
        const keys = Object.keys(rest);
        const accepts = keys.length > 0 ? req.accepts(keys) : false;
        this.vary("Accept");
        if (accepts) {
            const key = Array.isArray(accepts) ? accepts[0] : accepts;
            this.set("Content-Type", normalizeType1(key).value);
            obj[key](req, this, next);
        } else if (fn) {
            fn();
        } else {
            const err = new Error("Not Acceptable");
            err.status = err.statusCode = 406;
            err.types = normalizeTypes(keys).map(function(o) {
                return o.value;
            });
            next(err);
        }
        return this;
    }
    get(field) {
        return this.headers.get(field.toLowerCase()) || "";
    }
    json(body) {
        const app1 = this.app;
        const replacer = app1.get("json replacer");
        const spaces = app1.get("json spaces");
        const escape = app1.get("json escape");
        body = stringify1(body, replacer, spaces, escape);
        if (!this.get("Content-Type")) {
            this.type("application/json");
        }
        return this.send(body);
    }
    jsonp(body) {
        const app1 = this.app;
        const replacer = app1.get("json replacer");
        const spaces = app1.get("json spaces");
        const escape = app1.get("json escape");
        body = stringify1(body, replacer, spaces, escape);
        let callback = this.req.query[app1.get("jsonp callback name")];
        if (Array.isArray(callback)) {
            callback = callback[0];
        }
        if (typeof callback === "string" && callback.length !== 0) {
            this.set("X-Content-Type-Options", "nosniff");
            this.type("text/javascript");
            callback = callback.replace(/[^\[\]\w$.]/g, "");
            body = body.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
            body = `/**/ typeof ${callback} === 'function' && ${callback}(${body});`;
        } else if (!this.get("Content-Type")) {
            this.set("X-Content-Type-Options", "nosniff");
            this.set("Content-Type", "application/json");
        }
        return this.send(body);
    }
    links(links) {
        let currentLink = this.get("Link");
        if (currentLink) {
            currentLink += ", ";
        }
        const link = currentLink + Object.entries(links).map(([rel, field])=>`<${field}>; rel="${rel}"`
        ).join(", ");
        return this.set("Link", link);
    }
    location(url) {
        const loc = url === "back" ? this.req.get("Referrer") || "/" : url;
        return this.set("Location", encodeUrl(loc));
    }
    redirect() {
        let address;
        let body = "";
        let status;
        if (arguments.length === 0) {
            throw new TypeError("res.redirect: requires a location url");
        } else if (arguments.length === 1) {
            address = arguments[0] + "";
            status = 302;
        } else {
            if (typeof arguments[0] !== "number" || Number.isNaN(arguments[0])) {
                throw new TypeError("res.redirect: expected status code to be a valid number");
            }
            address = arguments[1] + "";
            status = arguments[0];
        }
        address = this.location(address).get("Location");
        this.format({
            text: function _renderRedirectBody() {
                body = `${STATUS_TEXT.get(status)}. Redirecting to ${address}`;
            },
            html: function _renderRedirectHtmlBoby() {
                const u = escapeHtml(address);
                body = `<p>${STATUS_TEXT.get(status)}. Redirecting to <a href="${u}">${u}</a></p>`;
            },
            default: function _renderDefaultRedirectBody() {
                body = "";
            }
        });
        this.status = status;
        if (this.req.method === "HEAD") {
            this.end();
        } else {
            this.end(body);
        }
    }
    render(view, options = {
    }, callback) {
        const app1 = this.req.app;
        const req = this.req;
        const self = this;
        let done = callback;
        if (typeof options === "function") {
            done = options;
            options = {
            };
        }
        options._locals = self.locals;
        done = done || function(err, str2) {
            if (err) {
                return req.next(err);
            }
            self.send(str2);
        };
        app1.render(view, options, done);
    }
    send(body) {
        let chunk;
        let isUndefined = body === undefined;
        if (isUndefined || body === null) {
            body = "";
        }
        switch(typeof body){
            case "string":
                chunk = body;
                break;
            case "boolean":
            case "number":
                return this.json(body);
            case "object":
            default:
                if (body instanceof Uint8Array || typeof body.read === "function") {
                    chunk = body;
                    if (!this.get("Content-Type")) {
                        this.type("bin");
                    }
                } else {
                    return this.json(body);
                }
        }
        if (typeof chunk === "string" && !this.get("Content-Type")) {
            this.type("html");
        }
        if (!this.get("ETag") && (typeof chunk === "string" || chunk instanceof Uint8Array) && !isUndefined) {
            this.etag(chunk);
        }
        if (this.req.fresh) {
            this.status = 304;
        }
        if (this.status === 204 || this.status === 304) {
            this.unset("Content-Type");
            this.unset("Content-Length");
            this.unset("Transfer-Encoding");
            chunk = "";
        }
        if (this.req.method === "HEAD") {
            this.end();
        } else {
            this.end(chunk);
        }
        return this;
    }
    async sendFile(path) {
        path = path.startsWith("file:") ? fromFileUrl2(path) : path;
        const stats = await Deno.stat(path);
        if (stats.isDirectory) {
            return this.req.next();
        }
        const body = await Deno.readFile(path);
        if (stats.mtime) {
            this.set("Last-Modified", stats.mtime.toUTCString());
        }
        if (!this.get("ETag")) {
            this.etag(stats);
        }
        if (!this.get("Content-Type")) {
            this.type(extname2(path));
        }
        return this.send(body);
    }
    sendStatus(code) {
        const body = STATUS_TEXT.get(code) || String(code);
        this.setStatus(code);
        this.type("txt");
        return this.send(body);
    }
    set(field, value) {
        if (arguments.length === 2) {
            const lowerCaseField = (field + "").toLowerCase();
            const coercedVal = value + "";
            if (lowerCaseField === "content-type") {
                this.type(coercedVal);
            } else {
                this.headers.set(lowerCaseField, coercedVal);
            }
        } else if (typeof field === "object" && field) {
            const entries = Object.entries(field);
            for (const [key, val] of entries){
                this.set(key, val);
            }
        }
        return this;
    }
    setStatus(code) {
        this.status = code;
        return this;
    }
    type(type) {
        const ct = contentType(type) || "application/octet-stream";
        this.headers.set("content-type", ct);
        return this;
    }
    unset(field) {
        this.headers.delete(field);
        return this;
    }
    vary(field) {
        vary(this.headers, field);
        return this;
    }
}
const hasOwnProperty = Object.prototype.hasOwnProperty;
function mergeDescriptors(dest, src, redefine = true) {
    Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name) {
        if (!redefine && hasOwnProperty.call(dest, name)) {
            return;
        }
        const descriptor = Object.getOwnPropertyDescriptor(src, name);
        Object.defineProperty(dest, name, descriptor);
    });
    return dest;
}
const response = Object.create(Response1.prototype);
function opine() {
    const app1 = (req, res = new Response1(), next)=>{
        app1.handle(req, res, next);
    };
    const eventEmitter = Evt.create();
    app1.emit = (event, arg)=>eventEmitter.post([
            event,
            arg
        ])
    ;
    app1.on = (event, arg)=>eventEmitter.$attach(to(event), arg)
    ;
    mergeDescriptors(app1, app, false);
    app1.request = Object.create(request, {
        app: {
            configurable: true,
            enumerable: true,
            writable: true,
            value: app1
        }
    });
    app1.response = Object.create(response, {
        app: {
            configurable: true,
            enumerable: true,
            writable: true,
            value: app1
        }
    });
    app1.init();
    return app1;
}
const App = ()=>{
    return __default.createElement("div", null, __default.createElement("h1", null, "Hello Deno Land!"), __default.createElement("p", null, "You clicked the \u{1f995} ", " times"));
};
const app1 = opine();
const browserBundlePath = "/browser.js";
console.log(__default1.renderToString());
const js = `import React from "https://dev.jspm.io/react@16.13.1";\nimport ReactDOM from "https://dev.jspm.io/react-dom@16.13.1";\nconst App = ${App};\nReactDOM.hydrate(React.createElement(App), document.body);`;
const html = `<html><head><script type="module" src="${browserBundlePath}"></script><style>* { font-family: Helvetica; }</style></head><body><div id="root">${__default1.renderToString(__default.createElement(App, null))}</div></body></html>`;
app1.use(browserBundlePath, (req, res, next)=>{
    res.type("application/javascript").send(js);
});
app1.use("/", (req, res, next)=>{
    res.type("text/html").send(html);
});
app1.listen({
    port: 17123
});
console.log(`React SSR App listening on port ${17123}`);
